"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sparqljson_parse_1 = require("sparqljson-parse");
/**
 * Converts SPARQL JSON results to a tree-based structure by splitting variables on a certain delimiter.
 */
class Converter {
    constructor(settings) {
        settings = settings || { delimiter: '_' };
        settings.prefixVariableQuestionMark = false;
        this.delimiter = settings.delimiter || '_';
        this.parser = new sparqljson_parse_1.SparqlJsonParser(settings);
        this.materializeRdfJsTerms = settings.materializeRdfJsTerms;
    }
    /**
     * Adds a value to a tree.
     * @param tree A tree datastructure.
     * @param {string[]} path The path of keys in the tree.
     * @param {Term} value A value to add.
     * @param {string} lastKeyPath The accumulated key path (separated by the given delimiter)
     *                             through recursive calls, can be empty.
     * @param {ISchema} schema A schema.
     * @param {boolean} materializeRdfJsTerms If RDFJS terms should be materialized.
     * @param {string} delimiter The string to join key paths by.
     */
    static addValueToTree(tree, path, value, lastKeyPath, schema, materializeRdfJsTerms, delimiter) {
        const key = path[0];
        const keyPath = lastKeyPath ? (lastKeyPath + delimiter + key) : key;
        const singularize = schema.singularizeVariables[keyPath];
        if (path.length === 1) {
            // Leaf nodes
            const setValue = materializeRdfJsTerms ? value.value : value;
            if (singularize) {
                if (!tree[key]) {
                    tree[key] = setValue;
                }
            }
            else {
                if (!tree[key]) {
                    tree[key] = [];
                }
                tree[key].push(setValue);
            }
        }
        else {
            // Inner nodes
            let nextNode;
            if (singularize) {
                if (!tree[key]) {
                    tree[key] = {};
                }
                nextNode = tree[key];
            }
            else {
                if (!tree[key]) {
                    tree[key] = [];
                }
                nextNode = {};
                tree[key].push(nextNode);
            }
            Converter.addValueToTree(nextNode, path.slice(1), value, keyPath, schema, materializeRdfJsTerms, delimiter);
        }
    }
    /**
     * Convert a complete SPARQL JSON response to a GraphQL results tree.
     * @param sparqlResponse A SPARQL JSON response.
     * @param {ISchema} schema A schema.
     * @return {any} A GraphQL results tree.
     */
    sparqlJsonResultsToTree(sparqlResponse, schema) {
        return this.bindingsToTree(this.parser.parseJsonResults(sparqlResponse), schema || { singularizeVariables: {} });
    }
    /**
     * Convert an array of bindings to a GraphQL results tree.
     * @param {IBindings[]} bindingsArray An array of bindings.
     * @param {ISchema} schema A schema.
     * @return {any} A GraphQL results tree.
     */
    bindingsToTree(bindingsArray, schema) {
        const singularRoot = schema && schema.singularizeVariables[''];
        const tree = singularRoot ? {} : [];
        for (const bindings of bindingsArray) {
            let subTree = tree;
            if (!singularRoot) {
                subTree = {};
                tree.push(subTree);
            }
            for (const key in bindings) {
                const path = key.split(this.delimiter);
                const value = bindings[key];
                Converter.addValueToTree(subTree, path, value, '', schema, this.materializeRdfJsTerms, this.delimiter);
            }
        }
        return tree;
    }
}
exports.Converter = Converter;
//# sourceMappingURL=Converter.js.map