{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/**\n * Dependencies\n */\nvar _require = require('whatwg-url'),\n    URL = _require.URL;\n\nvar assert = require('assert');\n\nvar crypto = require('@trust/webcrypto');\n\nvar base64url = require('base64url');\n\nvar fetch = require('node-fetch');\n\nvar Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nvar FormUrlEncoded = require('./FormUrlEncoded');\n\nvar IDToken = require('./IDToken');\n\nvar Session = require('./Session');\n\nvar onHttpError = require('./onHttpError');\n\nvar HttpError = require('standard-http-error');\n/**\n * AuthenticationResponse\n */\n\n\nvar AuthenticationResponse =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * @param rp {RelyingParty}\n   * @param [redirect] {string} req.query\n   * @param [body] {string} req.body.text\n   * @param session {Session|Storage} req.session or localStorage or similar\n   * @param params {object} hashmap\n   * @param mode {string} 'query'/'fragment'/'form_post',\n   *   determined in `parseResponse()`\n   */\n  function AuthenticationResponse(_ref) {\n    var rp = _ref.rp,\n        redirect = _ref.redirect,\n        body = _ref.body,\n        session = _ref.session,\n        mode = _ref.mode,\n        _ref$params = _ref.params,\n        params = _ref$params === void 0 ? {} : _ref$params;\n\n    _classCallCheck(this, AuthenticationResponse);\n\n    this.rp = rp;\n    this.redirect = redirect;\n    this.body = body;\n    this.session = session;\n    this.mode = mode;\n    this.params = params;\n  }\n  /**\n   * validateResponse\n   *\n   * @description\n   * Authentication response validation.\n   *\n   * @param {string|Object} response\n   *\n   * @returns {Promise<Session>}\n   */\n\n\n  _createClass(AuthenticationResponse, null, [{\n    key: \"validateResponse\",\n    value: function validateResponse(response) {\n      return Promise.resolve(response).then(this.parseResponse).then(this.errorResponse).then(this.matchRequest).then(this.validateStateParam).then(this.validateResponseMode).then(this.validateResponseParams).then(this.exchangeAuthorizationCode).then(this.validateIDToken).then(Session.fromAuthResponse);\n    }\n    /**\n     * parseResponse\n     *\n     * @param {object} response\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"parseResponse\",\n    value: function parseResponse(response) {\n      var redirect = response.redirect,\n          body = response.body; // response must be either a redirect uri or request body, but not both\n\n      if (redirect && body || !redirect && !body) {\n        throw new HttpError(400, 'Invalid response mode');\n      } // parse redirect uri\n\n\n      if (redirect) {\n        var url = new URL(redirect);\n        var search = url.search,\n            hash = url.hash;\n\n        if (search && hash || !search && !hash) {\n          throw new HttpError(400, 'Invalid response mode');\n        }\n\n        if (search) {\n          response.params = FormUrlEncoded.decode(search.substring(1));\n          response.mode = 'query';\n        }\n\n        if (hash) {\n          response.params = FormUrlEncoded.decode(hash.substring(1));\n          response.mode = 'fragment';\n        }\n      } // parse request form body\n\n\n      if (body) {\n        response.params = FormUrlEncoded.decode(body);\n        response.mode = 'form_post';\n      }\n\n      return response;\n    }\n    /**\n     * errorResponse\n     *\n     * @param {AuthenticationResponse} response\n     *\n     * @throws {Error} If response params include the OAuth2 'error' param,\n     *   throws an error based on it.\n     *\n     * @returns {AuthenticationResponse} Chainable\n     *\n     * @todo Figure out HTTP status code (typically 400, 401 or 403)\n     *   based on the OAuth2/OIDC `error` code, probably using an external library\n     */\n\n  }, {\n    key: \"errorResponse\",\n    value: function errorResponse(response) {\n      var errorCode = response.params.error;\n\n      if (errorCode) {\n        var errorParams = {};\n        errorParams['error'] = errorCode;\n        errorParams['error_description'] = response.params['error_description'];\n        errorParams['error_uri'] = response.params['error_uri'];\n        errorParams['state'] = response.params['state'];\n        var error = new Error(\"AuthenticationResponse error: \".concat(errorCode));\n        error.info = errorParams;\n        throw error;\n      }\n\n      return response;\n    }\n    /**\n     * matchRequest\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"matchRequest\",\n    value: function matchRequest(response) {\n      var rp = response.rp,\n          params = response.params,\n          session = response.session;\n      var state = params.state;\n      var issuer = rp.provider.configuration.issuer;\n\n      if (!state) {\n        throw new Error('Missing state parameter in authentication response');\n      }\n\n      var key = \"\".concat(issuer, \"/requestHistory/\").concat(state);\n      var request = session[key];\n\n      if (!request) {\n        throw new Error('Mismatching state parameter in authentication response');\n      }\n\n      response.request = JSON.parse(request);\n      return response;\n    }\n    /**\n     * validateStateParam\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateStateParam\",\n    value: function validateStateParam(response) {\n      var octets = new Uint8Array(response.request.state);\n      var encoded = response.params.state;\n      return crypto.subtle.digest({\n        name: 'SHA-256'\n      }, octets).then(function (digest) {\n        if (encoded !== base64url(Buffer.from(digest))) {\n          throw new Error('Mismatching state parameter in authentication response');\n        }\n\n        return response;\n      });\n    }\n    /**\n     * validateResponseMode\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateResponseMode\",\n    value: function validateResponseMode(response) {\n      if (response.request.response_type !== 'code' && response.mode === 'query') {\n        throw new Error('Invalid response mode');\n      }\n\n      return response;\n    }\n    /**\n     * validateResponseParams\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateResponseParams\",\n    value: function validateResponseParams(response) {\n      var request = response.request,\n          params = response.params;\n      var expectedParams = request.response_type.split(' ');\n\n      if (expectedParams.includes('code')) {\n        assert(params.code, 'Missing authorization code in authentication response'); // TODO assert novelty of code\n      }\n\n      if (expectedParams.includes('id_token')) {\n        assert(params.id_token, 'Missing id_token in authentication response');\n      }\n\n      if (expectedParams.includes('token')) {\n        assert(params.access_token, 'Missing access_token in authentication response');\n        assert(params.token_type, 'Missing token_type in authentication response');\n      }\n\n      return response;\n    }\n    /**\n     * exchangeAuthorizationCode\n     *\n     * @param {Object} response\n     * @returns {Promise} response object\n     */\n\n  }, {\n    key: \"exchangeAuthorizationCode\",\n    value: function exchangeAuthorizationCode(response) {\n      var rp = response.rp,\n          params = response.params,\n          request = response.request;\n      var code = params.code; // only exchange the authorization code when the response type is \"code\"\n\n      if (!code || request['response_type'] !== 'code') {\n        return Promise.resolve(response);\n      }\n\n      var provider = rp.provider,\n          registration = rp.registration;\n      var id = registration['client_id'];\n      var secret = registration['client_secret']; // verify the client is not public\n\n      if (!secret) {\n        return Promise.reject(new Error('Client cannot exchange authorization code because ' + 'it is not a confidential client'));\n      } // initialize token request arguments\n\n\n      var endpoint = provider.configuration.token_endpoint;\n      var method = 'POST'; // initialize headers\n\n      var headers = new Headers({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }); // initialize the token request parameters\n\n      var bodyContents = {\n        'grant_type': 'authorization_code',\n        'code': code,\n        'redirect_uri': request['redirect_uri'] // determine client authentication method\n\n      };\n      var authMethod = registration['token_endpoint_auth_method'] || 'client_secret_basic'; // client secret basic authentication\n\n      if (authMethod === 'client_secret_basic') {\n        var credentials = new Buffer(\"\".concat(id, \":\").concat(secret)).toString('base64');\n        headers.set('Authorization', \"Basic \".concat(credentials));\n      } // client secret post authentication\n\n\n      if (authMethod === 'client_secret_post') {\n        bodyContents['client_id'] = id;\n        bodyContents['client_secret'] = secret;\n      }\n\n      var body = FormUrlEncoded.encode(bodyContents); // TODO\n      // client_secret_jwt authentication\n      // private_key_jwt\n      // make the token request\n\n      return fetch(endpoint, {\n        method: method,\n        headers: headers,\n        body: body\n      }).then(onHttpError('Error exchanging authorization code')).then(function (tokenResponse) {\n        return tokenResponse.json();\n      }).then(function (tokenResponse) {\n        assert(tokenResponse['access_token'], 'Missing access_token in token response');\n        assert(tokenResponse['token_type'], 'Missing token_type in token response');\n        assert(tokenResponse['id_token'], 'Missing id_token in token response'); // anything else?\n        // IS THIS THE RIGHT THING TO DO HERE?\n\n        response.params = Object.assign(response.params, tokenResponse);\n        return response;\n      });\n    }\n    /**\n     * validateIDToken\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateIDToken\",\n    value: function validateIDToken(response) {\n      // only validate the ID Token if present in the response\n      if (!response.params.id_token) {\n        return Promise.resolve(response);\n      }\n\n      return Promise.resolve(response).then(AuthenticationResponse.decryptIDToken).then(AuthenticationResponse.decodeIDToken).then(AuthenticationResponse.validateIssuer).then(AuthenticationResponse.validateAudience).then(AuthenticationResponse.resolveKeys).then(AuthenticationResponse.verifySignature).then(AuthenticationResponse.validateExpires).then(AuthenticationResponse.verifyNonce).then(AuthenticationResponse.validateAcr).then(AuthenticationResponse.validateAuthTime).then(AuthenticationResponse.validateAccessTokenHash).then(AuthenticationResponse.validateAuthorizationCodeHash);\n    }\n    /**\n     * decryptIDToken\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"decryptIDToken\",\n    value: function decryptIDToken(response) {\n      // TODO\n      return Promise.resolve(response);\n    }\n    /**\n     * decodeIDToken\n     *\n     * Note: If the `id_token` is not present in params, this method does not\n     * get called (short-circuited in `validateIDToken()`).\n     *\n     * @param response {AuthenticationResponse}\n     * @param response.params {object}\n     * @param [response.params.id_token] {string} IDToken encoded as a JWT\n     *\n     * @returns {AuthenticationResponse} Chainable\n     */\n\n  }, {\n    key: \"decodeIDToken\",\n    value: function decodeIDToken(response) {\n      var jwt = response.params.id_token;\n\n      try {\n        response.decoded = IDToken.decode(jwt);\n      } catch (decodeError) {\n        var error = new HttpError(400, 'Error decoding ID Token');\n        error.cause = decodeError;\n        error.info = {\n          id_token: jwt\n        };\n        throw error;\n      }\n\n      return response;\n    }\n    /**\n     * validateIssuer\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateIssuer\",\n    value: function validateIssuer(response) {\n      var configuration = response.rp.provider.configuration;\n      var payload = response.decoded.payload; // validate issuer of token matches this relying party's provider\n\n      if (payload.iss !== configuration.issuer) {\n        throw new Error('Mismatching issuer in ID Token');\n      }\n\n      return response;\n    }\n    /**\n     * validateAudience\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateAudience\",\n    value: function validateAudience(response) {\n      var registration = response.rp.registration;\n      var _response$decoded$pay = response.decoded.payload,\n          aud = _response$decoded$pay.aud,\n          azp = _response$decoded$pay.azp; // validate audience includes this relying party\n\n      if (typeof aud === 'string' && aud !== registration['client_id']) {\n        throw new Error('Mismatching audience in id_token');\n      } // validate audience includes this relying party\n\n\n      if (Array.isArray(aud) && !aud.includes(registration['client_id'])) {\n        throw new Error('Mismatching audience in id_token');\n      } // validate authorized party is present if required\n\n\n      if (Array.isArray(aud) && !azp) {\n        throw new Error('Missing azp claim in id_token');\n      } // validate authorized party is this relying party\n\n\n      if (azp && azp !== registration['client_id']) {\n        throw new Error('Mismatching azp claim in id_token');\n      }\n\n      return response;\n    }\n    /**\n     * resolveKeys\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"resolveKeys\",\n    value: function resolveKeys(response) {\n      var rp = response.rp;\n      var provider = rp.provider;\n      var decoded = response.decoded;\n      return Promise.resolve(provider.jwks).then(function (jwks) {\n        return jwks ? jwks : rp.jwks();\n      }).then(function (jwks) {\n        if (decoded.resolveKeys(jwks)) {\n          return Promise.resolve(response);\n        } else {\n          throw new Error('Cannot resolve signing key for ID Token');\n        }\n      });\n    }\n    /**\n     * verifySignature\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"verifySignature\",\n    value: function verifySignature(response) {\n      var alg = response.decoded.header.alg;\n      var registration = response.rp.registration;\n      var expectedAlgorithm = registration['id_token_signed_response_alg'] || 'RS256'; // validate signing algorithm matches expectation\n\n      if (alg !== expectedAlgorithm) {\n        throw new Error(\"Expected ID Token to be signed with \".concat(expectedAlgorithm));\n      }\n\n      return response.decoded.verify().then(function (verified) {\n        if (!verified) {\n          throw new Error('Invalid ID Token signature');\n        }\n\n        return response;\n      });\n    }\n    /**\n     * validateExpires\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateExpires\",\n    value: function validateExpires(response) {\n      var exp = response.decoded.payload.exp; // validate expiration of token\n\n      if (exp <= Math.floor(Date.now() / 1000)) {\n        throw new Error('Expired ID Token');\n      }\n\n      return response;\n    }\n    /**\n     * verifyNonce\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"verifyNonce\",\n    value: function verifyNonce(response) {\n      var octets = new Uint8Array(response.request.nonce);\n      var nonce = response.decoded.payload.nonce;\n\n      if (!nonce) {\n        throw new Error('Missing nonce in ID Token');\n      }\n\n      return crypto.subtle.digest({\n        name: 'SHA-256'\n      }, octets).then(function (digest) {\n        if (nonce !== base64url(Buffer.from(digest))) {\n          throw new Error('Mismatching nonce in ID Token');\n        }\n\n        return response;\n      });\n    }\n    /**\n     * validateAcr\n     *\n     * @param {Object} response\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"validateAcr\",\n    value: function validateAcr(response) {\n      // TODO\n      return response;\n    }\n    /**\n     * validateAuthTime\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateAuthTime\",\n    value: function validateAuthTime(response) {\n      // TODO\n      return response;\n    }\n    /**\n     * validateAccessTokenHash\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateAccessTokenHash\",\n    value: function validateAccessTokenHash(response) {\n      // TODO\n      return response;\n    }\n    /**\n     * validateAuthorizationCodeHash\n     *\n     * @param {Object} response\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"validateAuthorizationCodeHash\",\n    value: function validateAuthorizationCodeHash(response) {\n      // TODO\n      return response;\n    }\n  }]);\n\n  return AuthenticationResponse;\n}();\n/**\n * Export\n */\n\n\nmodule.exports = AuthenticationResponse;","map":null,"metadata":{},"sourceType":"script"}