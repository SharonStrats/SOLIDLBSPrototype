{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/**\n * Dependencies\n */\nvar assert = require('assert');\n\nvar base64url = require('base64url');\n\nvar crypto = require('@trust/webcrypto');\n\nvar _require = require('@solid/jose'),\n    JWT = _require.JWT;\n\nvar FormUrlEncoded = require('./FormUrlEncoded');\n\nvar _require2 = require('whatwg-url'),\n    URL = _require2.URL;\n/**\n * Authentication Request\n */\n\n\nvar AuthenticationRequest =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function AuthenticationRequest() {\n    _classCallCheck(this, AuthenticationRequest);\n  }\n\n  _createClass(AuthenticationRequest, null, [{\n    key: \"create\",\n\n    /**\n     * create\n     *\n     * @description\n     * Create a new authentication request with generated state and nonce,\n     * validate presence of required parameters, serialize the request data and\n     * persist it to the session, and return a promise for an authentication\n     * request URI.\n     *\n     * @param {RelyingParty} rp – instance of RelyingParty\n     * @param {Object} options - optional request parameters\n     * @param {Object} session – reference to localStorage or other session object\n     *\n     * @returns {Promise}\n     */\n    value: function create(rp, options, session) {\n      var provider = rp.provider,\n          defaults = rp.defaults,\n          registration = rp.registration;\n      var issuer, endpoint, client, params;\n      return Promise.resolve().then(function () {\n        // validate presence of OP configuration, RP client registration,\n        // and default parameters\n        assert(provider.configuration, 'RelyingParty provider OpenID Configuration is missing');\n        assert(defaults.authenticate, 'RelyingParty default authentication parameters are missing');\n        assert(registration, 'RelyingParty client registration is missing'); // define basic elements of the request\n\n        issuer = provider.configuration.issuer;\n        endpoint = provider.configuration.authorization_endpoint;\n        client = {\n          client_id: registration.client_id\n        };\n        params = Object.assign(defaults.authenticate, client, options); // validate presence of required configuration and parameters\n\n        assert(issuer, 'Missing issuer in provider OpenID Configuration');\n        assert(endpoint, 'Missing authorization_endpoint in provider OpenID Configuration');\n        assert(params.scope, 'Missing scope parameter in authentication request');\n        assert(params.response_type, 'Missing response_type parameter in authentication request');\n        assert(params.client_id, 'Missing client_id parameter in authentication request');\n        assert(params.redirect_uri, 'Missing redirect_uri parameter in authentication request'); // generate state and nonce random octets\n\n        params.state = Array.from(crypto.getRandomValues(new Uint8Array(16)));\n        params.nonce = Array.from(crypto.getRandomValues(new Uint8Array(16))); // hash the state and nonce parameter values\n\n        return Promise.all([crypto.subtle.digest({\n          name: 'SHA-256'\n        }, new Uint8Array(params.state)), crypto.subtle.digest({\n          name: 'SHA-256'\n        }, new Uint8Array(params.nonce))]);\n      }) // serialize the request with original values, store in session by\n      // encoded state param, and replace state/nonce octets with encoded\n      // digests\n      .then(function (digests) {\n        var state = base64url(Buffer.from(digests[0]));\n        var nonce = base64url(Buffer.from(digests[1]));\n        var key = \"\".concat(issuer, \"/requestHistory/\").concat(state); // store the request params for response validation\n        // with serialized octet values for state and nonce\n\n        session[key] = JSON.stringify(params); // replace state and nonce octets with base64url encoded digests\n\n        params.state = state;\n        params.nonce = nonce;\n      }).then(function () {\n        return AuthenticationRequest.generateSessionKeys();\n      }).then(function (sessionKeys) {\n        AuthenticationRequest.storeSessionKeys(sessionKeys, params, session);\n      }) // optionally encode a JWT with the request parameters\n      // and replace params with `{ request: <jwt> }\n      .then(function () {\n        if (provider.configuration.request_parameter_supported) {\n          return AuthenticationRequest.encodeRequestParams(params).then(function (encodedParams) {\n            params = encodedParams;\n          });\n        }\n      }) // render the request URI and terminate the algorithm\n      .then(function () {\n        var url = new URL(endpoint);\n        url.search = FormUrlEncoded.encode(params);\n        return url.href;\n      });\n    }\n  }, {\n    key: \"generateSessionKeys\",\n    value: function generateSessionKeys() {\n      return crypto.subtle.generateKey({\n        name: \"RSASSA-PKCS1-v1_5\",\n        modulusLength: 2048,\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        hash: {\n          name: \"SHA-256\"\n        }\n      }, true, [\"sign\", \"verify\"]).then(function (keyPair) {\n        // returns a keypair object\n        return Promise.all([crypto.subtle.exportKey('jwk', keyPair.publicKey), crypto.subtle.exportKey('jwk', keyPair.privateKey)]);\n      }).then(function (jwkPair) {\n        var _jwkPair = _slicedToArray(jwkPair, 2),\n            publicJwk = _jwkPair[0],\n            privateJwk = _jwkPair[1];\n\n        return {\n          public: publicJwk,\n          private: privateJwk\n        };\n      });\n    }\n  }, {\n    key: \"storeSessionKeys\",\n    value: function storeSessionKeys(sessionKeys, params, session) {\n      // store the private one in session, public one goes into params\n      session['oidc.session.privateKey'] = JSON.stringify(sessionKeys.private);\n      params.key = sessionKeys.public;\n    }\n  }, {\n    key: \"encodeRequestParams\",\n    value: function encodeRequestParams(params) {\n      var excludeParams = ['scope', 'client_id', 'response_type', 'state'];\n      var keysToEncode = Object.keys(params).filter(function (key) {\n        return !excludeParams.includes(key);\n      });\n      var payload = {};\n      keysToEncode.forEach(function (key) {\n        payload[key] = params[key];\n      });\n      var requestParamJwt = new JWT({\n        header: {\n          alg: 'none'\n        },\n        payload: payload\n      }, {\n        filter: false\n      });\n      return requestParamJwt.encode().then(function (requestParamCompact) {\n        var newParams = {\n          scope: params['scope'],\n          client_id: params['client_id'],\n          response_type: params['response_type'],\n          request: requestParamCompact,\n          state: params['state']\n        };\n        return newParams;\n      });\n    }\n  }]);\n\n  return AuthenticationRequest;\n}();\n/**\n * Export\n */\n\n\nmodule.exports = AuthenticationRequest;","map":null,"metadata":{},"sourceType":"script"}