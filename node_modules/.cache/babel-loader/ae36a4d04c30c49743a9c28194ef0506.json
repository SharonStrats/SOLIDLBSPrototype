{"ast":null,"code":"/*\n * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar URDNA2015 = require('./URDNA2015');\n\nvar util = require('./util');\n\nmodule.exports =\n/*#__PURE__*/\nfunction (_URDNA) {\n  _inherits(URDNA2012, _URDNA);\n\n  function URDNA2012(options) {\n    var _this;\n\n    _classCallCheck(this, URDNA2012);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(URDNA2012).call(this, options));\n    _this.name = 'URGNA2012';\n    _this.hashAlgorithm = 'sha1';\n    return _this;\n  } // helper for modifying component during Hash First Degree Quads\n\n\n  _createClass(URDNA2012, [{\n    key: \"modifyFirstDegreeComponent\",\n    value: function modifyFirstDegreeComponent(id, component, key) {\n      if (component.termType !== 'BlankNode') {\n        return component;\n      }\n\n      component = util.clone(component);\n\n      if (key === 'name') {\n        component.value = '_:g';\n      } else {\n        component.value = component.value === id ? '_:a' : '_:z';\n      }\n\n      return component;\n    } // helper for getting a related predicate\n\n  }, {\n    key: \"getRelatedPredicate\",\n    value: function getRelatedPredicate(quad) {\n      return quad.predicate.value;\n    } // helper for creating hash to related blank nodes map\n\n  }, {\n    key: \"createHashToRelated\",\n    value: function createHashToRelated(id, issuer, callback) {\n      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that\n      // identify related blank nodes.\n\n      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to\n      // quads map for the key identifier.\n\n      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:\n\n      self.forEach(quads, function (quad, idx, callback) {\n        // 3.1) If the quad's subject is a blank node that does not match\n        // identifier, set hash to the result of the Hash Related Blank Node\n        // algorithm, passing the blank node identifier for subject as related,\n        // quad, path identifier issuer as issuer, and p as position.\n        var position;\n        var related;\n\n        if (quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {\n          related = quad.subject.value;\n          position = 'p';\n        } else if (quad.object.termType === 'BlankNode' && quad.object.value !== id) {\n          // 3.2) Otherwise, if quad's object is a blank node that does not match\n          // identifier, to the result of the Hash Related Blank Node algorithm,\n          // passing the blank node identifier for object as related, quad, path\n          // identifier issuer as issuer, and r as position.\n          related = quad.object.value;\n          position = 'r';\n        } else {\n          // 3.3) Otherwise, continue to the next quad.\n          return callback();\n        } // 3.4) Add a mapping of hash to the blank node identifier for the\n        // component that matched (subject or object) to hash to related blank\n        // nodes map, adding an entry as necessary.\n\n\n        self.hashRelatedBlankNode(related, quad, issuer, position, function (err, hash) {\n          if (err) {\n            return callback(err);\n          }\n\n          if (hash in hashToRelated) {\n            hashToRelated[hash].push(related);\n          } else {\n            hashToRelated[hash] = [related];\n          }\n\n          callback();\n        });\n      }, function (err) {\n        return callback(err, hashToRelated);\n      });\n    }\n  }]);\n\n  return URDNA2012;\n}(URDNA2015);","map":null,"metadata":{},"sourceType":"script"}