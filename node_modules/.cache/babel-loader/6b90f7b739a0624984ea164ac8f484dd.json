{"ast":null,"code":"var _regeneratorRuntime = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Url = require('url');\n\nvar path = require(\"path\");\n\nvar _require = require('node-fetch'),\n    Response = _require.Response;\n\nvar contentTypeLookup = require('mime-types').contentType;\n\nvar SolidRest =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function SolidRest(handlers) {\n    var _this = this;\n\n    _classCallCheck(this, SolidRest);\n\n    this.storageHandlers = {};\n    handlers.forEach(function (handler) {\n      _this.storageHandlers[handler.prefix] = handler;\n    });\n  }\n\n  _createClass(SolidRest, [{\n    key: \"storage\",\n    value: function storage(options) {\n      if (!this.storageHandlers[options.rest_prefix]) throw \"Did not recognize prefix \" + options.rest_prefix;\n      return this.storageHandlers[options.rest_prefix];\n    }\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(uri, options) {\n        var self, pathname, scheme, prefix, _ref, _ref2, objectType, objectExists, contents, _ref3, _ref4, status, turtleContents, headers, _ref5, _ref6, _status, _contents, _headers, _ref7, _ref8, _status2, _headers2, _ref9, _ref10, _status3, _headers3, link, slug, _ref11, _ref12, _status4, _headers4, _ref13, _ref14, _status5, _headers5, _ref15, _ref16, _status6, _undefined, _headers6, _ref17, _ref18, putStatus, putHeaders, _response, _container2turtle, _container2turtle2, _getHeaders;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _getHeaders = function _ref24(pathname, options) {\n                  var fn = pathname.replace(/.*\\//, '');\n                  var headers = typeof self.storage(options).getHeaders != \"undefined\" ? self.storage(options).getHeaders(pathname, options) : {};\n                  headers.location = headers.location || options.url;\n                  headers.date = headers.date || new Date(Date.now()).toISOString();\n                  headers.allow = headers.allow || ['OPTIONS, HEAD, GET, PATCH, POST, PUT, DELETE'];\n                  headers['x-powered-by'] = headers['x-powered-by'] || self.storage(options).name;\n                  headers.link = headers.link || options.objectType === \"Container\" ? \"<.meta>; rel=\\\"describedBy\\\", <.acl>; rel=\\\"acl\\\",\" + \"<http://www.w3.org/ns/ldp#Container>; rel=\\\"type\\\",\" + \"<http://www.w3.org/ns/ldp#BasicContainer>; rel=\\\"type\\\"\" : \"<\".concat(fn, \".meta>; rel=\\\"describedBy\\\", <\").concat(fn, \".acl>; rel=\\\"acl\\\",\") + \"<http://www.w3.org/ns/ldp#Resource>; rel=\\\"type\\\"\";\n                  headers['content-type'] = headers['content-type'] || options.objectType === \"Container\" ? \"text/turtle\" : contentTypeLookup(path.extname(pathname));\n                  return headers;\n                };\n\n                _container2turtle2 = function _ref23() {\n                  _container2turtle2 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee(pathname, options, contentsArray) {\n                    var filenames, folder, str2, str, i, fn, _ref19, _ref20, ftype, e;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (!(typeof self.storage(options).container2turtle != \"undefined\")) {\n                              _context.next = 2;\n                              break;\n                            }\n\n                            return _context.abrupt(\"return\", self.storage(options).container2turtle(pathname, options, contentsArray));\n\n                          case 2:\n                            filenames = contentsArray.filter(function (item) {\n                              if (!item.endsWith('.acl') && !item.endsWith('.meta')) {\n                                return item;\n                              }\n                            });\n                            folder = options.url;\n                            if (!folder.endsWith(\"/\")) folder = folder + \"/\";\n                            str2 = \"\";\n                            str = \"@prefix ldp: <http://www.w3.org/ns/ldp#>.\\n\" + \"<> a ldp:BasicContainer, ldp:Container\";\n\n                            if (!filenames.length) {\n                              _context.next = 26;\n                              break;\n                            }\n\n                            str = str + \"; ldp:contains\\n\";\n                            i = 0;\n\n                          case 10:\n                            if (!(i < filenames.length)) {\n                              _context.next = 25;\n                              break;\n                            }\n\n                            fn = filenames[i];\n                            _context.next = 14;\n                            return self.storage(options).getObjectType(pathname + fn);\n\n                          case 14:\n                            _ref19 = _context.sent;\n                            _ref20 = _slicedToArray(_ref19, 2);\n                            ftype = _ref20[0];\n                            e = _ref20[1];\n                            if (ftype === \"Container\" && !fn.endsWith(\"/\")) fn = fn + \"/\"; //        let prefix = options.rest_prefix===\"file\" ? \"\" : options.rest_prefix\n                            //        fn = options.scheme+\"//\"+prefix+pathname + fn\n\n                            str = str + \"  <\".concat(fn, \">,\\n\");\n                            ftype = ftype === \"Container\" ? \"a ldp:Container; a ldp:BasicContainer.\" : \"a ldp:Resource.\";\n                            str2 = str2 + \"  <\".concat(fn, \"> \").concat(ftype, \"\\n\");\n\n                          case 22:\n                            i++;\n                            _context.next = 10;\n                            break;\n\n                          case 25:\n                            str = str.replace(/,\\n$/, \"\");\n\n                          case 26:\n                            str = str + \".\\n\" + str2; // str = _makeStream(str);\n\n                            return _context.abrupt(\"return\", [200, str]);\n\n                          case 28:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n                  return _container2turtle2.apply(this, arguments);\n                };\n\n                _container2turtle = function _ref22(_x3, _x4, _x5) {\n                  return _container2turtle2.apply(this, arguments);\n                };\n\n                _response = function _ref21(body, options) {\n                  var status = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : options.status;\n                  options.status = status;\n                  options.headers = Object.assign(_getHeaders(pathname, options), options.headers);\n                  return new Response(body, options);\n                };\n\n                self = this;\n                options = Object.assign({}, options);\n                options.headers = options.headers || {};\n                options.url = decodeURIComponent(uri);\n                pathname = decodeURIComponent(Url.parse(uri).pathname);\n                options.method = (options.method || options.Method || 'GET').toUpperCase();\n                scheme = Url.parse(uri).protocol;\n                prefix = scheme.match(\"file\") ? 'file' : uri.replace(scheme + '//', '').replace(/\\/.*/, '');\n                options.scheme = scheme;\n                options.rest_prefix = prefix;\n                _context2.next = 16;\n                return self.storage(options).getObjectType(pathname, options);\n\n              case 16:\n                _ref = _context2.sent;\n                _ref2 = _slicedToArray(_ref, 2);\n                objectType = _ref2[0];\n                objectExists = _ref2[1];\n                options.objectType = objectType;\n                options.objectExists = objectExists;\n                /* GET\n                */\n\n                if (!(options.method === 'GET')) {\n                  _context2.next = 50;\n                  break;\n                }\n\n                if (objectExists) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _response(null, options, 404));\n\n              case 25:\n                if (!(objectType === \"Container\")) {\n                  _context2.next = 40;\n                  break;\n                }\n\n                _context2.next = 28;\n                return self.storage(options).getContainer(pathname, options);\n\n              case 28:\n                contents = _context2.sent;\n                _context2.next = 31;\n                return _container2turtle(pathname, options, contents);\n\n              case 31:\n                _ref3 = _context2.sent;\n                _ref4 = _slicedToArray(_ref3, 3);\n                status = _ref4[0];\n                turtleContents = _ref4[1];\n                headers = _ref4[2];\n                Object.assign(options.headers, headers);\n                return _context2.abrupt(\"return\", _response(turtleContents, options, status));\n\n              case 40:\n                if (!(objectType === \"Resource\")) {\n                  _context2.next = 50;\n                  break;\n                }\n\n                _context2.next = 43;\n                return self.storage(options).getResource(pathname, options);\n\n              case 43:\n                _ref5 = _context2.sent;\n                _ref6 = _slicedToArray(_ref5, 3);\n                _status = _ref6[0];\n                _contents = _ref6[1];\n                _headers = _ref6[2];\n                Object.assign(options.headers, _headers);\n                return _context2.abrupt(\"return\", _response(_contents, options, _status));\n\n              case 50:\n                if (!(options.method === 'HEAD')) {\n                  _context2.next = 56;\n                  break;\n                }\n\n                if (objectExists) {\n                  _context2.next = 55;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _response(null, options, 404));\n\n              case 55:\n                return _context2.abrupt(\"return\", _response(null, options, 200));\n\n              case 56:\n                if (!(options.method === \"DELETE\")) {\n                  _context2.next = 81;\n                  break;\n                }\n\n                if (objectExists) {\n                  _context2.next = 59;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _response(null, options, 404));\n\n              case 59:\n                if (!(objectType === \"Container\")) {\n                  _context2.next = 70;\n                  break;\n                }\n\n                _context2.next = 62;\n                return self.storage(options).deleteContainer(pathname, options);\n\n              case 62:\n                _ref7 = _context2.sent;\n                _ref8 = _slicedToArray(_ref7, 3);\n                _status2 = _ref8[0];\n                _headers2 = _ref8[2];\n                Object.assign(options.headers, _headers2);\n                return _context2.abrupt(\"return\", _response(null, options, _status2));\n\n              case 70:\n                if (!(objectType === 'Resource')) {\n                  _context2.next = 81;\n                  break;\n                }\n\n                _context2.next = 73;\n                return self.storage(options).deleteResource(pathname, options);\n\n              case 73:\n                _ref9 = _context2.sent;\n                _ref10 = _slicedToArray(_ref9, 3);\n                _status3 = _ref10[0];\n                _headers3 = _ref10[2];\n                Object.assign(options.headers, _headers3);\n                return _context2.abrupt(\"return\", _response(null, options, _status3));\n\n              case 81:\n                if (!(options.method === \"POST\")) {\n                  _context2.next = 109;\n                  break;\n                }\n\n                if (objectExists) {\n                  _context2.next = 84;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _response(null, options, 404));\n\n              case 84:\n                link = options.headers.Link || options.headers.link;\n                slug = options.headers.Slug || options.headers.slug;\n\n                if (!slug.match(/\\//)) {\n                  _context2.next = 88;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _response(null, options, 400));\n\n              case 88:\n                // Now returns 400 instead of 404\n                pathname = path.join(pathname, slug);\n\n                if (!(link && link.match(\"Container\"))) {\n                  _context2.next = 100;\n                  break;\n                }\n\n                _context2.next = 92;\n                return self.storage(options).postContainer(pathname, options);\n\n              case 92:\n                _ref11 = _context2.sent;\n                _ref12 = _slicedToArray(_ref11, 3);\n                _status4 = _ref12[0];\n                _headers4 = _ref12[2];\n                Object.assign(options.headers, _headers4);\n                return _context2.abrupt(\"return\", _response(null, options, _status4));\n\n              case 100:\n                if (!(link && link.match(\"Resource\"))) {\n                  _context2.next = 109;\n                  break;\n                }\n\n                _context2.next = 103;\n                return self.storage(options).putResource(pathname, options);\n\n              case 103:\n                _ref13 = _context2.sent;\n                _ref14 = _slicedToArray(_ref13, 3);\n                _status5 = _ref14[0];\n                _headers5 = _ref14[2];\n                Object.assign(options.headers, _headers5);\n                return _context2.abrupt(\"return\", _response(null, options, _status5));\n\n              case 109:\n                if (!(options.method === 'PUT')) {\n                  _context2.next = 132;\n                  break;\n                }\n\n                if (!(objectType === \"Container\")) {\n                  _context2.next = 112;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _response(null, options, 409));\n\n              case 112:\n                _context2.next = 114;\n                return self.storage(options).makeContainers(pathname, options);\n\n              case 114:\n                _ref15 = _context2.sent;\n                _ref16 = _slicedToArray(_ref15, 3);\n                _status6 = _ref16[0];\n                _undefined = _ref16[1];\n                _headers6 = _ref16[2];\n                Object.assign(options.headers, _headers6);\n\n                if (!(_status6 !== 200 && _status6 !== 201)) {\n                  _context2.next = 122;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _response(null, options, _status6));\n\n              case 122:\n                _context2.next = 124;\n                return self.storage(options).putResource(pathname, options);\n\n              case 124:\n                _ref17 = _context2.sent;\n                _ref18 = _slicedToArray(_ref17, 3);\n                putStatus = _ref18[0];\n                putHeaders = _ref18[2];\n                Object.assign(options.headers, putHeaders); // Note: The headers from makeContainers are also returned here\n\n                return _context2.abrupt(\"return\", _response(null, options, putStatus));\n\n              case 132:\n                return _context2.abrupt(\"return\", _response(null, options, 405));\n\n              case 133:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetch(_x, _x2) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }() // end of fetch()\n\n  }]);\n\n  return SolidRest;\n}(); // end of SolidRest()\n\n\nmodule.exports = exports = SolidRest;\n/* END */\n\n/*\nrequired\n  getObjectType\n  getResouce\n  getContainer\n  putResource\n  postResource\n  postContainer\n  deleteResource\n  deleteContainer\n  makeContainers\noptional\n  getHeaders\n  text\n  json\n*/","map":null,"metadata":{},"sourceType":"script"}