{"ast":null,"code":"var _regeneratorRuntime = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _require = require('url'),\n    URL = _require.URL,\n    resolve = _require.resolve,\n    parseUrl = _require.parse;\n\nvar https = require('https');\n\nvar querystring = require('querystring');\n\nvar RelyingParty = require('@solid/oidc-rp');\n\nvar PoPToken = require('@solid/oidc-rp/lib/PoPToken'); // Fake redirect URL\n\n\nvar redirectUrl = 'http://example.org/';\n\nvar SolidClient =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function SolidClient(_ref) {\n    var identityManager = _ref.identityManager;\n\n    _classCallCheck(this, SolidClient);\n\n    this._identityManager = identityManager;\n  }\n  /**\n   * Logs the user in with the given identity provider\n   *\n   * @param identityProvider string The URL of the identity provider\n   * @param credentials object An object with username and password keys\n   *\n   * @returns Promise<Session> A session for the given user\n   */\n\n\n  _createClass(SolidClient, [{\n    key: \"login\",\n    value: function () {\n      var _login = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(identityProvider, credentials) {\n        var relyingParty, username, session;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.getRelyingParty(identityProvider);\n\n              case 2:\n                relyingParty = _context.sent;\n                // Load or create a session\n                username = credentials.username;\n                session = this._identityManager.getSession(relyingParty, username);\n\n                if (!(!session || this.isExpired(session))) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 8;\n                return this.createSession(relyingParty, credentials);\n\n              case 8:\n                session = _context.sent;\n\n                this._identityManager.addSession(relyingParty, username, session);\n\n              case 10:\n                return _context.abrupt(\"return\", session);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function login(_x, _x2) {\n        return _login.apply(this, arguments);\n      }\n\n      return login;\n    }()\n    /**\n     * Logs the user in with the given identity provider\n     *\n     * @param relyingParty RelyingParty The relying party\n     * @param credentials object An object with username and password keys\n     *\n     * @returns Promise<Session> A session for the given user\n     */\n\n  }, {\n    key: \"createSession\",\n    value: function () {\n      var _createSession = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(relyingParty, credentials) {\n        var authData, authUrl, loginParams, accessUrl, session;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Obtain the authorization URL\n                authData = {};\n                _context2.next = 3;\n                return relyingParty.createRequest({\n                  redirect_uri: redirectUrl\n                }, authData);\n\n              case 3:\n                authUrl = _context2.sent;\n                _context2.next = 6;\n                return this.getLoginParams(authUrl);\n\n              case 6:\n                loginParams = _context2.sent;\n                _context2.next = 9;\n                return this.performLogin(loginParams.loginUrl, loginParams, credentials);\n\n              case 9:\n                accessUrl = _context2.sent;\n                _context2.next = 12;\n                return relyingParty.validateResponse(accessUrl, authData);\n\n              case 12:\n                session = _context2.sent;\n                return _context2.abrupt(\"return\", session);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function createSession(_x3, _x4) {\n        return _createSession.apply(this, arguments);\n      }\n\n      return createSession;\n    }()\n    /**\n     * Creates an access token for the given URL.\n     *\n     * @param url string\n     * @param session Session\n     *\n     * @returns Promise<string> An access token\n     */\n\n  }, {\n    key: \"createToken\",\n    value: function () {\n      var _createToken = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(url, session) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", PoPToken.issueFor(url, session));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function createToken(_x5, _x6) {\n        return _createToken.apply(this, arguments);\n      }\n\n      return createToken;\n    }()\n    /**\n     * Obtains a relying party for the given identity provider.\n     *\n     * @param identityProvider string The URL of the identity provider\n     *\n     * @returns Promise<RelyingParty> A relying party\n     */\n\n  }, {\n    key: \"getRelyingParty\",\n    value: function () {\n      var _getRelyingParty = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(identityProvider) {\n        var relyingParty, providerSettings;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // Try to load an existing relying party\n                providerSettings = this._identityManager.getProviderSettings(identityProvider);\n\n                if (!providerSettings) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                relyingParty = RelyingParty.from(providerSettings);\n                _context4.next = 9;\n                break;\n\n              case 5:\n                _context4.next = 7;\n                return this.registerRelyingParty(identityProvider);\n\n              case 7:\n                relyingParty = _context4.sent;\n\n                this._identityManager.addProviderSettings(relyingParty);\n\n              case 9:\n                return _context4.abrupt(\"return\", relyingParty);\n\n              case 10:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getRelyingParty(_x7) {\n        return _getRelyingParty.apply(this, arguments);\n      }\n\n      return getRelyingParty;\n    }()\n    /**\n     * Registers a relying party for the given identity provider.\n     *\n     * @param identityProvider string The URL of the identity provider\n     *\n     * @returns Promise<RelyingParty> A relying party\n     */\n\n  }, {\n    key: \"registerRelyingParty\",\n    value: function () {\n      var _registerRelyingParty = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(identityProvider) {\n        var responseType, registration, options;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                responseType = 'id_token token';\n                registration = {\n                  issuer: identityProvider,\n                  grant_types: ['implicit'],\n                  redirect_uris: [redirectUrl],\n                  response_types: [responseType],\n                  scope: 'openid profile'\n                };\n                options = {\n                  defaults: {\n                    authenticate: {\n                      redirect_uri: redirectUrl,\n                      response_type: responseType\n                    }\n                  }\n                };\n                return _context5.abrupt(\"return\", RelyingParty.register(identityProvider, registration, options));\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function registerRelyingParty(_x8) {\n        return _registerRelyingParty.apply(this, arguments);\n      }\n\n      return registerRelyingParty;\n    }()\n    /**\n     * Obtains the login parameters through the given authentication URL.\n     *\n     * @param authUrl String The authentication URL\n     *\n     * @returns Promise<object> A key/value object of login parameters\n     */\n\n  }, {\n    key: \"getLoginParams\",\n    value: function () {\n      var _getLoginParams = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(authUrl) {\n        var authorizationPage, loginPageUrl, loginPage, passwordForm, loginUrl, loginParams, match, inputRegex;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.fetch(authUrl);\n\n              case 2:\n                authorizationPage = _context6.sent;\n                loginPageUrl = resolve(authUrl, authorizationPage.headers.location);\n                _context6.next = 6;\n                return this.fetch(loginPageUrl);\n\n              case 6:\n                loginPage = _context6.sent;\n                // Extract the password form's target URL\n                passwordForm = loginPage.body.match(/<form[^]*?<\\/form>/)[0];\n                loginUrl = resolve(loginPageUrl, passwordForm.match(/action=\"([^\"]+)\"/)[1]); // Extract the password form's hidden fields\n\n                loginParams = {\n                  loginUrl: loginUrl\n                };\n                inputRegex = /<input.*?name=\"([^\"]+)\".*?value=\"([^\"]+)\"/g;\n\n                while (match = inputRegex.exec(passwordForm)) {\n                  loginParams[match[1]] = match[2];\n                }\n\n                return _context6.abrupt(\"return\", loginParams);\n\n              case 13:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getLoginParams(_x9) {\n        return _getLoginParams.apply(this, arguments);\n      }\n\n      return getLoginParams;\n    }()\n    /**\n     * Sends the login information to the login page.\n     *\n     * @param loginUrl string The URL of the login page\n     * @param loginParams object The login parameters\n     * @param credentials object The user's credentials\n     *\n     * @returns Promise<string> An access URL.\n     */\n\n  }, {\n    key: \"performLogin\",\n    value: function () {\n      var _performLogin = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(loginUrl, loginParams, credentials) {\n        var options, postData, loginResponse, message, cause, authUrl, cookie, consentUrl, search, consPostData, consOptions, consentResponse, authResponse, accessUrl;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                // Set the credentials\n                loginParams.username = credentials.username;\n                loginParams.password = credentials.password; // Perform the login POST request\n\n                options = parseUrl(loginUrl);\n                postData = querystring.stringify(loginParams);\n                options.method = 'POST';\n                options.headers = {\n                  'Content-Type': 'application/x-www-form-urlencoded',\n                  'Content-Length': postData.length\n                };\n                _context7.next = 8;\n                return this.fetch(options, postData);\n\n              case 8:\n                loginResponse = _context7.sent;\n\n                if (!(loginResponse.statusCode !== 302)) {\n                  _context7.next = 13;\n                  break;\n                }\n\n                message = loginResponse.body.match(/<strong>(.*?)<\\/strong>/);\n                cause = message ? message[1] : 'unknown cause';\n                throw new Error(\"Could not log in: \".concat(cause));\n\n              case 13:\n                // Redirect to the authentication page, passing the session cookie\n                authUrl = loginResponse.headers.location;\n                cookie = loginResponse.headers['set-cookie'][0].replace(/;.*/, ''); // Handle the new consent page in 5.1.1\n\n                if (!this.isAboveVersion511(loginResponse.headers['x-powered-by'])) {\n                  _context7.next = 29;\n                  break;\n                }\n\n                consentUrl = new URL(authUrl);\n                search = consentUrl.search.substring(1);\n                consPostData = JSON.parse('{\"' + decodeURIComponent(search).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/\\=/g, '\":\"') + '\"}');\n                consPostData.consent = true;\n                consPostData.access_mode = ['Read', 'Write', 'Append', 'Control'];\n                consPostData = querystring.stringify(consPostData);\n                consOptions = parseUrl(\"\".concat(consentUrl.origin).concat(consentUrl.pathname));\n                consOptions.method = 'POST';\n                consOptions.headers = {\n                  'Content-Type': 'application/x-www-form-urlencoded',\n                  'Content-Length': consPostData.length,\n                  cookie: cookie\n                };\n                _context7.next = 27;\n                return this.fetch(consOptions, consPostData);\n\n              case 27:\n                consentResponse = _context7.sent;\n                authUrl = consentResponse.headers.location;\n\n              case 29:\n                _context7.next = 31;\n                return this.fetch(Object.assign(parseUrl(authUrl), {\n                  headers: {\n                    cookie: cookie\n                  }\n                }));\n\n              case 31:\n                authResponse = _context7.sent;\n                // Obtain the access URL from the redirected response\n                accessUrl = authResponse.headers.location;\n                return _context7.abrupt(\"return\", accessUrl);\n\n              case 34:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function performLogin(_x10, _x11, _x12) {\n        return _performLogin.apply(this, arguments);\n      }\n\n      return performLogin;\n    }()\n  }, {\n    key: \"isAboveVersion511\",\n    value: function isAboveVersion511(version) {\n      return /^solid-server\\/5\\.(1\\.[1-9]|[2-9]|1\\d)/.test(version);\n    }\n    /**\n     * Fetches the given resource over HTTP.\n     *\n     * @param options object The request options\n     * @param data? string The request body\n     *\n     * @returns Promise<Response> The HTTP response with a body property\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function fetch(options, data) {\n      return new Promise(function (resolve, reject) {\n        var request = https.request(options);\n        request.end(data);\n        request.on('response', function (response) {\n          response.body = '';\n          response.on('data', function (data) {\n            return response.body += data;\n          });\n          response.on('end', function () {\n            return resolve(response);\n          });\n        });\n        request.on('error', reject);\n      });\n    }\n    /**\n     * Determines whether the session has expired.\n     *\n     * @param session object The session\n     *\n     * @returns boolean Whether the session has expired\n     */\n\n  }, {\n    key: \"isExpired\",\n    value: function isExpired(session) {\n      var now = Date.now() / 1000;\n      var expiry = session.idClaims && session.idClaims.exp || 0;\n      return expiry < now;\n    }\n  }]);\n\n  return SolidClient;\n}();\n\nmodule.exports = SolidClient;","map":null,"metadata":{},"sourceType":"script"}