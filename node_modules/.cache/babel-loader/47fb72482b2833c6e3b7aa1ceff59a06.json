{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _toArray = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toArray\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar JsonLdError = require('./JsonLdError');\n\nvar _require = require('./types'),\n    _isArray = _require.isArray,\n    _isObject = _require.isObject,\n    _isString = _require.isString,\n    _isUndefined = _require.isUndefined;\n\nvar _require2 = require('./graphTypes'),\n    _isList = _require2.isList,\n    _isValue = _require2.isValue,\n    _isGraph = _require2.isGraph,\n    _isSimpleGraph = _require2.isSimpleGraph,\n    _isSubjectReference = _require2.isSubjectReference;\n\nvar _require3 = require('./context'),\n    _expandIri = _require3.expandIri,\n    _getContextValue = _require3.getContextValue,\n    _isKeyword = _require3.isKeyword,\n    _processContext = _require3.process;\n\nvar _require4 = require('./url'),\n    _removeBase = _require4.removeBase;\n\nvar _require5 = require('./util'),\n    _addValue = _require5.addValue,\n    _asArray = _require5.asArray,\n    _compareShortestLeast = _require5.compareShortestLeast;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return the compacted value.\n */\n\napi.compact = function (_ref) {\n  var activeCtx = _ref.activeCtx,\n      _ref$activeProperty = _ref.activeProperty,\n      activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty,\n      element = _ref.element,\n      _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {} : _ref$options,\n      _ref$compactionMap = _ref.compactionMap,\n      compactionMap = _ref$compactionMap === void 0 ? function () {\n    return undefined;\n  } : _ref$compactionMap;\n\n  // recursively compact array\n  if (_isArray(element)) {\n    var rval = [];\n\n    for (var i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      var compacted = api.compact({\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        element: element[i],\n        options: options,\n        compactionMap: compactionMap\n      });\n\n      if (compacted === null) {\n        // TODO: use `await` to support async\n        compacted = compactionMap({\n          unmappedValue: element[i],\n          activeCtx: activeCtx,\n          activeProperty: activeProperty,\n          parent: element,\n          index: i,\n          options: options\n        });\n\n        if (compacted === undefined) {\n          continue;\n        }\n      }\n\n      rval.push(compacted);\n    }\n\n    if (options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      var container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n      if (container.length === 0) {\n        rval = rval[0];\n      }\n    }\n\n    return rval;\n  } // use any scoped context on activeProperty\n\n\n  var ctx = _getContextValue(activeCtx, activeProperty, '@context');\n\n  if (!_isUndefined(ctx)) {\n    // Note: spec's `from term` var is named `isPropertyTermScopedContext`\n    activeCtx = _processContext({\n      activeCtx: activeCtx,\n      localCtx: ctx,\n      isPropertyTermScopedContext: true,\n      options: options\n    });\n  } // recursively compact object\n\n\n  if (_isObject(element)) {\n    if (options.link && '@id' in element && options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      var linked = options.link[element['@id']];\n\n      for (var _i = 0; _i < linked.length; ++_i) {\n        if (linked[_i].expanded === element) {\n          return linked[_i].compacted;\n        }\n      }\n    } // do value compaction on @values and subject references\n\n\n    if (_isValue(element) || _isSubjectReference(element)) {\n      var _rval2 = api.compactValue({\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        value: element,\n        options: options\n      });\n\n      if (options.link && _isSubjectReference(element)) {\n        // store linked element\n        if (!options.link.hasOwnProperty(element['@id'])) {\n          options.link[element['@id']] = [];\n        }\n\n        options.link[element['@id']].push({\n          expanded: element,\n          compacted: _rval2\n        });\n      }\n\n      return _rval2;\n    } // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n\n\n    if (_isList(element)) {\n      var _container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n      if (_container.includes('@list')) {\n        return api.compact({\n          activeCtx: activeCtx,\n          activeProperty: activeProperty,\n          element: element['@list'],\n          options: options,\n          compactionMap: compactionMap\n        });\n      }\n    } // FIXME: avoid misuse of active property as an expanded property?\n\n\n    var insideReverse = activeProperty === '@reverse';\n    var _rval = {}; // revert type scoped context\n\n    activeCtx = activeCtx.revertTypeScopedContext();\n\n    if (options.link && '@id' in element) {\n      // store linked element\n      if (!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n\n      options.link[element['@id']].push({\n        expanded: element,\n        compacted: _rval\n      });\n    } // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n\n\n    var types = element['@type'] || [];\n\n    if (types.length > 1) {\n      types = Array.from(types).sort();\n    } // find all type-scoped contexts based on current context, prior to\n    // updating it\n\n\n    var typeContext = activeCtx;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var type = _step.value;\n        var compactedType = api.compactIri({\n          activeCtx: typeContext,\n          iri: type,\n          relativeTo: {\n            vocab: true\n          }\n        }); // Use any type-scoped context defined on this value\n\n        var _ctx = _getContextValue(typeContext, compactedType, '@context');\n\n        if (!_isUndefined(_ctx)) {\n          activeCtx = _processContext({\n            activeCtx: activeCtx,\n            localCtx: _ctx,\n            options: options,\n            isTypeScopedContext: true\n          });\n        }\n      } // process element keys in order\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var keys = Object.keys(element).sort();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var expandedProperty = _step2.value;\n        var expandedValue = element[expandedProperty]; // compact @id and @type(s)\n\n        if (expandedProperty === '@id' || expandedProperty === '@type') {\n          var _ret = function () {\n            // if using a type-scoped context, resolve type values against previous\n            // context\n            var isType = expandedProperty === '@type';\n            var valueContext = isType ? activeCtx.previousContext || activeCtx : activeCtx;\n\n            var compactedValue = _asArray(expandedValue).map(function (expandedIri) {\n              return api.compactIri({\n                activeCtx: valueContext,\n                iri: expandedIri,\n                relativeTo: {\n                  vocab: isType\n                }\n              });\n            });\n\n            if (compactedValue.length === 1) {\n              compactedValue = compactedValue[0];\n            } // use keyword alias and add value\n\n\n            var alias = api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedProperty,\n              relativeTo: {\n                vocab: true\n              }\n            });\n            var isArray = _isArray(compactedValue) && expandedValue.length === 0;\n\n            _addValue(_rval, alias, compactedValue, {\n              propertyIsArray: isArray\n            });\n\n            return \"continue\";\n          }();\n\n          if (_ret === \"continue\") continue;\n        } // handle @reverse\n\n\n        if (expandedProperty === '@reverse') {\n          // recursively compact expanded value\n          var compactedValue = api.compact({\n            activeCtx: activeCtx,\n            activeProperty: '@reverse',\n            element: expandedValue,\n            options: options,\n            compactionMap: compactionMap\n          }); // handle double-reversed properties\n\n          for (var compactedProperty in compactedValue) {\n            if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n              var value = compactedValue[compactedProperty];\n\n              var _container2 = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n\n              var useArray = _container2.includes('@set') || !options.compactArrays;\n\n              _addValue(_rval, compactedProperty, value, {\n                propertyIsArray: useArray\n              });\n\n              delete compactedValue[compactedProperty];\n            }\n          }\n\n          if (Object.keys(compactedValue).length > 0) {\n            // use keyword alias and add value\n            var alias = api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedProperty,\n              relativeTo: {\n                vocab: true\n              }\n            });\n\n            _addValue(_rval, alias, compactedValue);\n          }\n\n          continue;\n        }\n\n        if (expandedProperty === '@preserve') {\n          // compact using activeProperty\n          var _compactedValue = api.compact({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: expandedValue,\n            options: options,\n            compactionMap: compactionMap\n          });\n\n          if (!(_isArray(_compactedValue) && _compactedValue.length === 0)) {\n            _addValue(_rval, expandedProperty, _compactedValue);\n          }\n\n          continue;\n        } // handle @index property\n\n\n        if (expandedProperty === '@index') {\n          // drop @index if inside an @index container\n          var _container3 = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n          if (_container3.includes('@index')) {\n            continue;\n          } // use keyword alias and add value\n\n\n          var _alias = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n\n          _addValue(_rval, _alias, expandedValue);\n\n          continue;\n        } // skip array processing for keywords that aren't @graph or @list\n\n\n        if (expandedProperty !== '@graph' && expandedProperty !== '@list' && _isKeyword(expandedProperty)) {\n          // use keyword alias and add value as is\n          var _alias2 = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n\n          _addValue(_rval, _alias2, expandedValue);\n\n          continue;\n        } // Note: expanded value must be an array due to expansion algorithm.\n\n\n        if (!_isArray(expandedValue)) {\n          throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n        } // preserve empty arrays\n\n\n        if (expandedValue.length === 0) {\n          var itemActiveProperty = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            value: expandedValue,\n            relativeTo: {\n              vocab: true\n            },\n            reverse: insideReverse\n          });\n          var nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n          var nestResult = _rval;\n\n          if (nestProperty) {\n            _checkNestProperty(activeCtx, nestProperty, options);\n\n            if (!_isObject(_rval[nestProperty])) {\n              _rval[nestProperty] = {};\n            }\n\n            nestResult = _rval[nestProperty];\n          }\n\n          _addValue(nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n        } // recusively process array values\n\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = expandedValue[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var expandedItem = _step3.value;\n\n            // compact property and get container type\n            var _itemActiveProperty = api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedProperty,\n              value: expandedItem,\n              relativeTo: {\n                vocab: true\n              },\n              reverse: insideReverse\n            }); // if itemActiveProperty is a @nest property, add values to nestResult,\n            // otherwise rval\n\n\n            var _nestProperty = activeCtx.mappings.has(_itemActiveProperty) ? activeCtx.mappings.get(_itemActiveProperty)['@nest'] : null;\n\n            var _nestResult = _rval;\n\n            if (_nestProperty) {\n              _checkNestProperty(activeCtx, _nestProperty, options);\n\n              if (!_isObject(_rval[_nestProperty])) {\n                _rval[_nestProperty] = {};\n              }\n\n              _nestResult = _rval[_nestProperty];\n            }\n\n            var _container4 = _getContextValue(activeCtx, _itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate\n\n\n            var isGraph = _isGraph(expandedItem);\n\n            var isList = _isList(expandedItem);\n\n            var inner = void 0;\n\n            if (isList) {\n              inner = expandedItem['@list'];\n            } else if (isGraph) {\n              inner = expandedItem['@graph'];\n            } // recursively compact expanded item\n\n\n            var compactedItem = api.compact({\n              activeCtx: activeCtx,\n              activeProperty: _itemActiveProperty,\n              element: isList || isGraph ? inner : expandedItem,\n              options: options,\n              compactionMap: compactionMap\n            }); // handle @list\n\n            if (isList) {\n              // ensure @list value is an array\n              if (!_isArray(compactedItem)) {\n                compactedItem = [compactedItem];\n              }\n\n              if (!_container4.includes('@list')) {\n                // wrap using @list alias\n                compactedItem = _defineProperty({}, api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@list',\n                  relativeTo: {\n                    vocab: true\n                  }\n                }), compactedItem); // include @index from expanded @list, if any\n\n                if ('@index' in expandedItem) {\n                  compactedItem[api.compactIri({\n                    activeCtx: activeCtx,\n                    iri: '@index',\n                    relativeTo: {\n                      vocab: true\n                    }\n                  })] = expandedItem['@index'];\n                }\n              } else {\n                _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                  valueIsArray: true,\n                  allowDuplicate: true\n                });\n\n                continue;\n              }\n            } // Graph object compaction cases\n\n\n            if (isGraph) {\n              if (_container4.includes('@graph') && (_container4.includes('@id') || _container4.includes('@index') && _isSimpleGraph(expandedItem))) {\n                // get or create the map object\n                var mapObject = void 0;\n\n                if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n                  mapObject = _nestResult[_itemActiveProperty];\n                } else {\n                  _nestResult[_itemActiveProperty] = mapObject = {};\n                } // index on @id or @index or alias of @none\n\n\n                var key = (_container4.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@none',\n                  vocab: true\n                }); // add compactedItem to map, using value of `@id` or a new blank\n                // node identifier\n\n                _addValue(mapObject, key, compactedItem, {\n                  propertyIsArray: !options.compactArrays || _container4.includes('@set')\n                });\n              } else if (_container4.includes('@graph') && _isSimpleGraph(expandedItem)) {\n                // container includes @graph but not @id or @index and value is a\n                // simple graph object add compact value\n                _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                  propertyIsArray: !options.compactArrays || _container4.includes('@set')\n                });\n              } else {\n                // wrap using @graph alias, remove array if only one item and\n                // compactArrays not set\n                if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n                  compactedItem = compactedItem[0];\n                }\n\n                compactedItem = _defineProperty({}, api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@graph',\n                  relativeTo: {\n                    vocab: true\n                  }\n                }), compactedItem); // include @id from expanded graph, if any\n\n                if ('@id' in expandedItem) {\n                  compactedItem[api.compactIri({\n                    activeCtx: activeCtx,\n                    iri: '@id',\n                    relativeTo: {\n                      vocab: true\n                    }\n                  })] = expandedItem['@id'];\n                } // include @index from expanded graph, if any\n\n\n                if ('@index' in expandedItem) {\n                  compactedItem[api.compactIri({\n                    activeCtx: activeCtx,\n                    iri: '@index',\n                    relativeTo: {\n                      vocab: true\n                    }\n                  })] = expandedItem['@index'];\n                }\n\n                _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                  propertyIsArray: !options.compactArrays || _container4.includes('@set')\n                });\n              }\n            } else if (_container4.includes('@language') || _container4.includes('@index') || _container4.includes('@id') || _container4.includes('@type')) {\n              // handle language and index maps\n              // get or create the map object\n              var _mapObject = void 0;\n\n              if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n                _mapObject = _nestResult[_itemActiveProperty];\n              } else {\n                _nestResult[_itemActiveProperty] = _mapObject = {};\n              }\n\n              var _key = void 0;\n\n              if (_container4.includes('@language')) {\n                // if container is a language map, simplify compacted value to\n                // a simple string\n                if (_isValue(compactedItem)) {\n                  compactedItem = compactedItem['@value'];\n                }\n\n                _key = expandedItem['@language'];\n              } else if (_container4.includes('@index')) {\n                _key = expandedItem['@index'];\n              } else if (_container4.includes('@id')) {\n                var idKey = api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@id',\n                  vocab: true\n                });\n                _key = compactedItem[idKey];\n                delete compactedItem[idKey];\n              } else if (_container4.includes('@type')) {\n                var typeKey = api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@type',\n                  vocab: true\n                });\n\n                var _types = void 0;\n\n                var _asArray2 = _asArray(compactedItem[typeKey] || []);\n\n                var _asArray3 = _toArray(_asArray2);\n\n                _key = _asArray3[0];\n                _types = _asArray3.slice(1);\n\n                switch (_types.length) {\n                  case 0:\n                    delete compactedItem[typeKey];\n                    break;\n\n                  case 1:\n                    compactedItem[typeKey] = _types[0];\n                    break;\n\n                  default:\n                    compactedItem[typeKey] = _types;\n                    break;\n                }\n              } // if compacting this value which has no key, index on @none\n\n\n              if (!_key) {\n                _key = api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@none',\n                  vocab: true\n                });\n              } // add compact value to map object using key from expanded value\n              // based on the container type\n\n\n              _addValue(_mapObject, _key, compactedItem, {\n                propertyIsArray: _container4.includes('@set')\n              });\n            } else {\n              // use an array if: compactArrays flag is false,\n              // @container is @set or @list , value is an empty\n              // array, or key is @graph\n              var isArray = !options.compactArrays || _container4.includes('@set') || _container4.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value\n\n              _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                propertyIsArray: isArray\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return _rval;\n  } // only primitives remain which are already compact\n\n\n  return element;\n};\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\n\n\napi.compactIri = function (_ref2) {\n  var activeCtx = _ref2.activeCtx,\n      iri = _ref2.iri,\n      _ref2$value = _ref2.value,\n      value = _ref2$value === void 0 ? null : _ref2$value,\n      _ref2$relativeTo = _ref2.relativeTo,\n      relativeTo = _ref2$relativeTo === void 0 ? {\n    vocab: false\n  } : _ref2$relativeTo,\n      _ref2$reverse = _ref2.reverse,\n      reverse = _ref2$reverse === void 0 ? false : _ref2$reverse;\n\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  } // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n\n\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  var inverseCtx = activeCtx.getInverse(); // if term is a keyword, it may be compacted to a simple alias\n\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  } // use inverse context to pick a term if iri is relative to vocab\n\n\n  if (relativeTo.vocab && iri in inverseCtx) {\n    var defaultLanguage = activeCtx['@language'] || '@none'; // prefer @index if available in value\n\n    var containers = [];\n\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    } // if value is a preserve object, use its value\n\n\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    } // prefer most specific container including @graph, prefering @set\n    // variations\n\n\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // favor idmap if the graph is has an @id\n\n\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n\n      containers.push('@graph', '@graph@set', '@set'); // allow indexmap if the graph is not indexed\n\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // allow idmap if the graph does not have an @id\n\n\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    } // defaults for term selection based on type/language\n\n\n    var typeOrLanguage = '@language';\n    var typeOrLanguageValue = '@null';\n\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n\n      var list = value['@list'];\n\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        var commonLanguage = list.length === 0 ? defaultLanguage : null;\n        var commonType = null;\n\n        for (var i = 0; i < list.length; ++i) {\n          var item = list[i];\n          var itemLanguage = '@none';\n          var itemType = '@none';\n\n          if (_isValue(item)) {\n            if ('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          } // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n\n\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n\n      containers.push('@set');\n    } // do term selection\n\n\n    containers.push('@none'); // an index map can be used to index values using @none, so add as a low\n    // priority\n\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    } // values without type or language can use @language map\n\n\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n\n    if (term !== null) {\n      return term;\n    }\n  } // no term match, use @vocab if available\n\n\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      var vocab = activeCtx['@vocab'];\n\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        var suffix = iri.substr(vocab.length);\n\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  } // no term or @vocab match, check for possible CURIEs\n\n\n  var choice = null; // TODO: make FastCurieMap a class with a method to do this lookup\n\n  var partialMatches = [];\n  var iriMap = activeCtx.fastCurieMap; // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n\n  var maxPartialLength = iri.length - 1;\n\n  for (var _i2 = 0; _i2 < maxPartialLength && iri[_i2] in iriMap; ++_i2) {\n    iriMap = iriMap[iri[_i2]];\n\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  } // check partial matches in reverse order to prefer longest ones first\n\n\n  for (var _i3 = partialMatches.length - 1; _i3 >= 0; --_i3) {\n    var entry = partialMatches[_i3];\n    var terms = entry.terms;\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = terms[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _term = _step4.value;\n        // a CURIE is usable if:\n        // 1. it has no mapping, OR\n        // 2. value is null, which means we're not compacting an @value, AND\n        //   the mapping matches the IRI\n        var curie = _term + ':' + iri.substr(entry.iri.length);\n        var isUsableCurie = activeCtx.mappings.get(_term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri); // select curie if it is shorter or the same length but lexicographically\n        // less than the current choice\n\n        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n          choice = curie;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  } // return chosen curie\n\n\n  if (choice !== null) {\n    return choice;\n  } // compact IRI relative to base\n\n\n  if (!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  } // return IRI as is\n\n\n  return iri;\n};\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\n\n\napi.compactValue = function (_ref3) {\n  var activeCtx = _ref3.activeCtx,\n      activeProperty = _ref3.activeProperty,\n      value = _ref3.value,\n      options = _ref3.options;\n\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    var _type = _getContextValue(activeCtx, activeProperty, '@type');\n\n    var language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    var container = _getContextValue(activeCtx, activeProperty, '@container') || []; // whether or not the value has an @index that must be preserved\n\n    var preserveIndex = '@index' in value && !container.includes('@index'); // if there's no @index to preserve ...\n\n    if (!preserveIndex) {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === _type || value['@language'] === language) {\n        return value['@value'];\n      }\n    } // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n\n\n    var keyCount = Object.keys(value).length;\n    var isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    var hasDefaultLanguage = '@language' in activeCtx;\n\n    var isValueString = _isString(value['@value']);\n\n    var hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n\n    if (isValueOnlyKey && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    var rval = {}; // preserve @index\n\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx: activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    } // alias @value\n\n\n    rval[api.compactIri({\n      activeCtx: activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  } // value is a subject reference\n\n\n  var expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  var type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  var compacted = api.compactIri({\n    activeCtx: activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    }\n  }); // compact to scalar\n\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return _defineProperty({}, api.compactIri({\n    activeCtx: activeCtx,\n    iri: '@id',\n    relativeTo: {\n      vocab: true\n    }\n  }), compacted);\n};\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\n\n\napi.removePreserve = function (ctx, input, options) {\n  // recurse through arrays\n  if (_isArray(input)) {\n    var output = [];\n\n    for (var i = 0; i < input.length; ++i) {\n      var result = api.removePreserve(ctx, input[i], options); // drop nulls from arrays\n\n      if (result !== null) {\n        output.push(result);\n      }\n    }\n\n    input = output;\n  } else if (_isObject(input)) {\n    // remove @preserve\n    if ('@preserve' in input) {\n      if (input['@preserve'] === '@null') {\n        return null;\n      }\n\n      return input['@preserve'];\n    } // skip @values\n\n\n    if (_isValue(input)) {\n      return input;\n    } // recurse through @lists\n\n\n    if (_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    } // handle in-memory linked nodes\n\n\n    var idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (input.hasOwnProperty(idAlias)) {\n      var id = input[idAlias];\n\n      if (options.link.hasOwnProperty(id)) {\n        var idx = options.link[id].indexOf(input);\n\n        if (idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        } // prevent circular visitation\n\n\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    } // recurse through properties\n\n\n    var graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    for (var prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if (prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n\n      var _result = api.removePreserve(ctx, input[prop], options);\n\n      var container = _getContextValue(ctx, prop, '@container') || [];\n\n      if (options.compactArrays && _isArray(_result) && _result.length === 1 && container.length === 0 && prop !== graphAlias) {\n        _result = _result[0];\n      }\n\n      input[prop] = _result;\n    }\n  }\n\n  return input;\n};\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\n\n\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  } // preferences for the value of @type or @language\n\n\n  var prefs = []; // determine prefs for @id based on whether or not value compacts to a term\n\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isSubjectReference(value)) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    } // try to compact value to a term\n\n\n    var term = api.compactIri({\n      activeCtx: activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n\n  prefs.push('@none');\n  var containerMap = activeCtx.inverse[iri];\n\n  for (var ci = 0; ci < containers.length; ++ci) {\n    // if container not available in the map, continue\n    var container = containers[ci];\n\n    if (!(container in containerMap)) {\n      continue;\n    }\n\n    var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n\n    for (var pi = 0; pi < prefs.length; ++pi) {\n      // if type/language option not available in the map, continue\n      var pref = prefs[pi];\n\n      if (!(pref in typeOrLanguageValueMap)) {\n        continue;\n      } // select term\n\n\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\n\n\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}