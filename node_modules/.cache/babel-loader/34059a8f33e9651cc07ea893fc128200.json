{"ast":null,"code":"\"use strict\"; // Returns \"Type(value) is Object\" in ES terminology.\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n\nfunction getReferenceToBytes(bufferSource) {\n  // Node.js' Buffer does not allow subclassing for now, so we can get away with a prototype object check for perf.\n  if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {\n    return bufferSource;\n  }\n\n  if (bufferSource instanceof ArrayBuffer) {\n    return Buffer.from(bufferSource);\n  }\n\n  return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);\n}\n\nfunction getCopyToBytes(bufferSource) {\n  return Buffer.from(getReferenceToBytes(bufferSource));\n}\n\nfunction mixin(target, source) {\n  var keys = Object.getOwnPropertyNames(source);\n\n  for (var i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n}\n\nvar wrapperSymbol = Symbol(\"wrapper\");\nvar implSymbol = Symbol(\"impl\");\nvar sameObjectCaches = Symbol(\"SameObject caches\");\n\nfunction getSameObject(wrapper, prop, creator) {\n  if (!wrapper[sameObjectCaches]) {\n    wrapper[sameObjectCaches] = Object.create(null);\n  }\n\n  if (prop in wrapper[sameObjectCaches]) {\n    return wrapper[sameObjectCaches][prop];\n  }\n\n  wrapper[sameObjectCaches][prop] = creator();\n  return wrapper[sameObjectCaches][prop];\n}\n\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n}\n\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n}\n\nfunction tryWrapperForImpl(impl) {\n  var wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n}\n\nfunction tryImplForWrapper(wrapper) {\n  var impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n}\n\nvar iterInternalSymbol = Symbol(\"internal\");\nvar IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\nfunction isArrayIndexPropName(P) {\n  if (typeof P !== \"string\") {\n    return false;\n  }\n\n  var i = P >>> 0;\n\n  if (i === Math.pow(2, 32) - 1) {\n    return false;\n  }\n\n  var s = \"\".concat(i);\n\n  if (P !== s) {\n    return false;\n  }\n\n  return true;\n}\n\nvar supportsPropertyIndex = Symbol(\"supports property index\");\nvar supportedPropertyIndices = Symbol(\"supported property indices\");\nvar supportsPropertyName = Symbol(\"supports property name\");\nvar supportedPropertyNames = Symbol(\"supported property names\");\nvar indexedGet = Symbol(\"indexed property get\");\nvar indexedSetNew = Symbol(\"indexed property set new\");\nvar indexedSetExisting = Symbol(\"indexed property set existing\");\nvar namedGet = Symbol(\"named property get\");\nvar namedSetNew = Symbol(\"named property set new\");\nvar namedSetExisting = Symbol(\"named property set existing\");\nvar namedDelete = Symbol(\"named property delete\");\nmodule.exports = exports = {\n  isObject: isObject,\n  getReferenceToBytes: getReferenceToBytes,\n  getCopyToBytes: getCopyToBytes,\n  mixin: mixin,\n  wrapperSymbol: wrapperSymbol,\n  implSymbol: implSymbol,\n  getSameObject: getSameObject,\n  wrapperForImpl: wrapperForImpl,\n  implForWrapper: implForWrapper,\n  tryWrapperForImpl: tryWrapperForImpl,\n  tryImplForWrapper: tryImplForWrapper,\n  iterInternalSymbol: iterInternalSymbol,\n  IteratorPrototype: IteratorPrototype,\n  isArrayIndexPropName: isArrayIndexPropName,\n  supportsPropertyIndex: supportsPropertyIndex,\n  supportedPropertyIndices: supportedPropertyIndices,\n  supportsPropertyName: supportsPropertyName,\n  supportedPropertyNames: supportedPropertyNames,\n  indexedGet: indexedGet,\n  indexedSetNew: indexedSetNew,\n  indexedSetExisting: indexedSetExisting,\n  namedGet: namedGet,\n  namedSetNew: namedSetNew,\n  namedSetExisting: namedSetExisting,\n  namedDelete: namedDelete\n};","map":null,"metadata":{},"sourceType":"script"}