{"ast":null,"code":"/*\n * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar AsyncAlgorithm = require('./AsyncAlgorithm');\n\nvar IdentifierIssuer = require('./IdentifierIssuer');\n\nvar MessageDigest = require('./MessageDigest');\n\nvar Permutator = require('./Permutator');\n\nvar NQuads = require('./NQuads');\n\nvar util = require('./util');\n\nvar POSITIONS = {\n  subject: 's',\n  object: 'o',\n  graph: 'g'\n};\n\nmodule.exports =\n/*#__PURE__*/\nfunction (_AsyncAlgorithm) {\n  _inherits(URDNA2015, _AsyncAlgorithm);\n\n  function URDNA2015(options) {\n    var _this;\n\n    _classCallCheck(this, URDNA2015);\n\n    options = options || {};\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(URDNA2015).call(this, options));\n    _this.name = 'URDNA2015';\n    _this.options = Object.assign({}, options);\n    _this.blankNodeInfo = {};\n    _this.hashToBlankNodes = {};\n    _this.canonicalIssuer = new IdentifierIssuer('_:c14n');\n    _this.hashAlgorithm = 'sha256';\n    _this.quads;\n    return _this;\n  } // 4.4) Normalization Algorithm\n\n\n  _createClass(URDNA2015, [{\n    key: \"main\",\n    value: function main(dataset, callback) {\n      var self = this;\n      self.schedule.start = Date.now();\n      var result;\n      self.quads = dataset; // 1) Create the normalization state.\n      // Note: Optimize by generating non-normalized blank node map concurrently.\n\n      var nonNormalized = {};\n      self.waterfall([function (callback) {\n        // 2) For every quad in input dataset:\n        self.forEach(dataset, function (quad, idx, callback) {\n          // 2.1) For each blank node that occurs in the quad, add a reference\n          // to the quad using the blank node identifier in the blank node to\n          // quads map, creating a new entry if necessary.\n          self.forEachComponent(quad, function (component) {\n            if (component.termType !== 'BlankNode') {\n              return;\n            }\n\n            var id = component.value;\n\n            if (id in self.blankNodeInfo) {\n              self.blankNodeInfo[id].quads.push(quad);\n            } else {\n              nonNormalized[id] = true;\n              self.blankNodeInfo[id] = {\n                quads: [quad]\n              };\n            }\n          });\n          callback();\n        }, callback);\n      }, function (callback) {\n        // 3) Create a list of non-normalized blank node identifiers\n        // non-normalized identifiers and populate it using the keys from the\n        // blank node to quads map.\n        // Note: We use a map here and it was generated during step 2.\n        // 4) Initialize simple, a boolean flag, to true.\n        var simple = true; // 5) While simple is true, issue canonical identifiers for blank nodes:\n\n        self.whilst(function () {\n          return simple;\n        }, function (callback) {\n          // 5.1) Set simple to false.\n          simple = false; // 5.2) Clear hash to blank nodes map.\n\n          self.hashToBlankNodes = {};\n          self.waterfall([function (callback) {\n            // 5.3) For each blank node identifier identifier in\n            // non-normalized identifiers:\n            self.forEach(nonNormalized, function (value, id, callback) {\n              // 5.3.1) Create a hash, hash, according to the Hash First\n              // Degree Quads algorithm.\n              self.hashFirstDegreeQuads(id, function (err, hash) {\n                if (err) {\n                  return callback(err);\n                } // 5.3.2) Add hash and identifier to hash to blank nodes map,\n                // creating a new entry if necessary.\n\n\n                if (hash in self.hashToBlankNodes) {\n                  self.hashToBlankNodes[hash].push(id);\n                } else {\n                  self.hashToBlankNodes[hash] = [id];\n                }\n\n                callback();\n              });\n            }, callback);\n          }, function (callback) {\n            // 5.4) For each hash to identifier list mapping in hash to blank\n            // nodes map, lexicographically-sorted by hash:\n            var hashes = Object.keys(self.hashToBlankNodes).sort();\n            self.forEach(hashes, function (hash, i, callback) {\n              // 5.4.1) If the length of identifier list is greater than 1,\n              // continue to the next mapping.\n              var idList = self.hashToBlankNodes[hash];\n\n              if (idList.length > 1) {\n                return callback();\n              } // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n              // issuer and the single blank node identifier in identifier\n              // list, identifier, to issue a canonical replacement identifier\n              // for identifier.\n              // TODO: consider changing `getId` to `issue`\n\n\n              var id = idList[0];\n              self.canonicalIssuer.getId(id); // 5.4.3) Remove identifier from non-normalized identifiers.\n\n              delete nonNormalized[id]; // 5.4.4) Remove hash from the hash to blank nodes map.\n\n              delete self.hashToBlankNodes[hash]; // 5.4.5) Set simple to true.\n\n              simple = true;\n              callback();\n            }, callback);\n          }], callback);\n        }, callback);\n      }, function (callback) {\n        // 6) For each hash to identifier list mapping in hash to blank nodes\n        // map, lexicographically-sorted by hash:\n        var hashes = Object.keys(self.hashToBlankNodes).sort();\n        self.forEach(hashes, function (hash, idx, callback) {\n          // 6.1) Create hash path list where each item will be a result of\n          // running the Hash N-Degree Quads algorithm.\n          var hashPathList = []; // 6.2) For each blank node identifier identifier in identifier list:\n\n          var idList = self.hashToBlankNodes[hash];\n          self.waterfall([function (callback) {\n            self.forEach(idList, function (id, idx, callback) {\n              // 6.2.1) If a canonical identifier has already been issued for\n              // identifier, continue to the next identifier.\n              if (self.canonicalIssuer.hasId(id)) {\n                return callback();\n              } // 6.2.2) Create temporary issuer, an identifier issuer\n              // initialized with the prefix _:b.\n\n\n              var issuer = new IdentifierIssuer('_:b'); // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n              // issuer and identifier, to issue a new temporary blank node\n              // identifier for identifier.\n\n              issuer.getId(id); // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n              // temporary issuer, and append the result to the hash path\n              // list.\n\n              self.hashNDegreeQuads(id, issuer, function (err, result) {\n                if (err) {\n                  return callback(err);\n                }\n\n                hashPathList.push(result);\n                callback();\n              });\n            }, callback);\n          }, function (callback) {\n            // 6.3) For each result in the hash path list,\n            // lexicographically-sorted by the hash in result:\n            // TODO: use `String.localeCompare`?\n            hashPathList.sort(function (a, b) {\n              return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n            });\n            self.forEach(hashPathList, function (result, idx, callback) {\n              // 6.3.1) For each blank node identifier, existing identifier,\n              // that was issued a temporary identifier by identifier issuer\n              // in result, issue a canonical identifier, in the same order,\n              // using the Issue Identifier algorithm, passing canonical\n              // issuer and existing identifier.\n              for (var existing in result.issuer.existing) {\n                self.canonicalIssuer.getId(existing);\n              }\n\n              callback();\n            }, callback);\n          }], callback);\n        }, callback);\n      }, function (callback) {\n        /* Note: At this point all blank nodes in the set of RDF quads have been\n        assigned canonical identifiers, which have been stored in the canonical\n        issuer. Here each quad is updated by assigning each of its blank nodes\n        its new identifier. */\n        // 7) For each quad, quad, in input dataset:\n        var normalized = [];\n        self.waterfall([function (callback) {\n          self.forEach(self.quads, function (quad, idx, callback) {\n            // 7.1) Create a copy, quad copy, of quad and replace any existing\n            // blank node identifiers using the canonical identifiers\n            // previously issued by canonical issuer.\n            // Note: We optimize away the copy here.\n            self.forEachComponent(quad, function (component) {\n              if (component.termType === 'BlankNode' && !component.value.startsWith(self.canonicalIssuer.prefix)) {\n                component.value = self.canonicalIssuer.getId(component.value);\n              }\n            }); // 7.2) Add quad copy to the normalized dataset.\n\n            normalized.push(NQuads.serializeQuad(quad));\n            callback();\n          }, callback);\n        }, function (callback) {\n          // sort normalized output\n          normalized.sort(); // 8) Return the normalized dataset.\n\n          result = normalized.join('');\n          return callback();\n        }], callback);\n      }], function (err) {\n        return callback(err, result);\n      });\n    } // 4.6) Hash First Degree Quads\n\n  }, {\n    key: \"hashFirstDegreeQuads\",\n    value: function hashFirstDegreeQuads(id, callback) {\n      var self = this; // return cached hash\n\n      var info = self.blankNodeInfo[id];\n\n      if ('hash' in info) {\n        return callback(null, info.hash);\n      } // 1) Initialize nquads to an empty list. It will be used to store quads in\n      // N-Quads format.\n\n\n      var nquads = []; // 2) Get the list of quads quads associated with the reference blank node\n      // identifier in the blank node to quads map.\n\n      var quads = info.quads; // 3) For each quad quad in quads:\n\n      self.forEach(quads, function (quad, idx, callback) {\n        // 3.1) Serialize the quad in N-Quads format with the following special\n        // rule:\n        // 3.1.1) If any component in quad is an blank node, then serialize it\n        // using a special identifier as follows:\n        var copy = {\n          predicate: quad.predicate\n        };\n        self.forEachComponent(quad, function (component, key) {\n          // 3.1.2) If the blank node's existing blank node identifier matches the\n          // reference blank node identifier then use the blank node identifier\n          // _:a, otherwise, use the blank node identifier _:z.\n          copy[key] = self.modifyFirstDegreeComponent(id, component, key);\n        });\n        nquads.push(NQuads.serializeQuad(copy));\n        callback();\n      }, function (err) {\n        if (err) {\n          return callback(err);\n        } // 4) Sort nquads in lexicographical order.\n\n\n        nquads.sort(); // 5) Return the hash that results from passing the sorted, joined nquads\n        // through the hash algorithm.\n\n        var md = new MessageDigest(self.hashAlgorithm);\n\n        for (var i = 0; i < nquads.length; ++i) {\n          md.update(nquads[i]);\n        } // TODO: represent as byte buffer instead to cut memory usage in half\n\n\n        info.hash = md.digest();\n        callback(null, info.hash);\n      });\n    } // 4.7) Hash Related Blank Node\n\n  }, {\n    key: \"hashRelatedBlankNode\",\n    value: function hashRelatedBlankNode(related, quad, issuer, position, callback) {\n      var self = this; // 1) Set the identifier to use for related, preferring first the canonical\n      // identifier for related if issued, second the identifier issued by issuer\n      // if issued, and last, if necessary, the result of the Hash First Degree\n      // Quads algorithm, passing related.\n\n      var id;\n      self.waterfall([function (callback) {\n        if (self.canonicalIssuer.hasId(related)) {\n          id = self.canonicalIssuer.getId(related);\n          return callback();\n        }\n\n        if (issuer.hasId(related)) {\n          id = issuer.getId(related);\n          return callback();\n        }\n\n        self.hashFirstDegreeQuads(related, function (err, hash) {\n          if (err) {\n            return callback(err);\n          }\n\n          id = hash;\n          callback();\n        });\n      }], function (err) {\n        if (err) {\n          return callback(err);\n        } // 2) Initialize a string input to the value of position.\n        // Note: We use a hash object instead.\n\n\n        var md = new MessageDigest(self.hashAlgorithm);\n        md.update(position); // 3) If position is not g, append <, the value of the predicate in quad,\n        // and > to input.\n\n        if (position !== 'g') {\n          md.update(self.getRelatedPredicate(quad));\n        } // 4) Append identifier to input.\n\n\n        md.update(id); // 5) Return the hash that results from passing input through the hash\n        // algorithm.\n        // TODO: represent as byte buffer instead to cut memory usage in half\n\n        return callback(null, md.digest());\n      });\n    } // 4.8) Hash N-Degree Quads\n\n  }, {\n    key: \"hashNDegreeQuads\",\n    value: function hashNDegreeQuads(id, issuer, callback) {\n      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that\n      // identify related blank nodes.\n      // Note: 2) and 3) handled within `createHashToRelated`\n\n      var hashToRelated;\n      var md = new MessageDigest(self.hashAlgorithm);\n      self.waterfall([function (callback) {\n        return self.createHashToRelated(id, issuer, function (err, result) {\n          if (err) {\n            return callback(err);\n          }\n\n          hashToRelated = result;\n          callback();\n        });\n      }, function (callback) {\n        // 4) Create an empty string, data to hash.\n        // Note: We created a hash object `md` above instead.\n        // 5) For each related hash to blank node list mapping in hash to\n        // related blank nodes map, sorted lexicographically by related hash:\n        var hashes = Object.keys(hashToRelated).sort();\n        self.forEach(hashes, function (hash, idx, callback) {\n          // 5.1) Append the related hash to the data to hash.\n          md.update(hash); // 5.2) Create a string chosen path.\n\n          var chosenPath = ''; // 5.3) Create an unset chosen issuer variable.\n\n          var chosenIssuer; // 5.4) For each permutation of blank node list:\n\n          var permutator = new Permutator(hashToRelated[hash]);\n          self.whilst(function () {\n            return permutator.hasNext();\n          }, function (nextPermutation) {\n            var permutation = permutator.next(); // 5.4.1) Create a copy of issuer, issuer copy.\n\n            var issuerCopy = issuer.clone(); // 5.4.2) Create a string path.\n\n            var path = ''; // 5.4.3) Create a recursion list, to store blank node identifiers\n            // that must be recursively processed by this algorithm.\n\n            var recursionList = [];\n            self.waterfall([function (callback) {\n              // 5.4.4) For each related in permutation:\n              self.forEach(permutation, function (related, idx, callback) {\n                // 5.4.4.1) If a canonical identifier has been issued for\n                // related, append it to path.\n                if (self.canonicalIssuer.hasId(related)) {\n                  path += self.canonicalIssuer.getId(related);\n                } else {\n                  // 5.4.4.2) Otherwise:\n                  // 5.4.4.2.1) If issuer copy has not issued an identifier\n                  // for related, append related to recursion list.\n                  if (!issuerCopy.hasId(related)) {\n                    recursionList.push(related);\n                  } // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n                  // issuer copy and related and append the result to path.\n\n\n                  path += issuerCopy.getId(related);\n                } // 5.4.4.3) If chosen path is not empty and the length of path\n                // is greater than or equal to the length of chosen path and\n                // path is lexicographically greater than chosen path, then\n                // skip to the next permutation.\n\n\n                if (chosenPath.length !== 0 && path.length >= chosenPath.length && path > chosenPath) {\n                  // FIXME: may cause inaccurate total depth calculation\n                  return nextPermutation();\n                }\n\n                callback();\n              }, callback);\n            }, function (callback) {\n              // 5.4.5) For each related in recursion list:\n              self.forEach(recursionList, function (related, idx, callback) {\n                // 5.4.5.1) Set result to the result of recursively executing\n                // the Hash N-Degree Quads algorithm, passing related for\n                // identifier and issuer copy for path identifier issuer.\n                self.hashNDegreeQuads(related, issuerCopy, function (err, result) {\n                  if (err) {\n                    return callback(err);\n                  } // 5.4.5.2) Use the Issue Identifier algorithm, passing\n                  // issuer copy and related and append the result to path.\n\n\n                  path += issuerCopy.getId(related); // 5.4.5.3) Append <, the hash in result, and > to path.\n\n                  path += '<' + result.hash + '>'; // 5.4.5.4) Set issuer copy to the identifier issuer in\n                  // result.\n\n                  issuerCopy = result.issuer; // 5.4.5.5) If chosen path is not empty and the length of\n                  // path is greater than or equal to the length of chosen\n                  // path and path is lexicographically greater than chosen\n                  // path, then skip to the next permutation.\n\n                  if (chosenPath.length !== 0 && path.length >= chosenPath.length && path > chosenPath) {\n                    // FIXME: may cause inaccurate total depth calculation\n                    return nextPermutation();\n                  }\n\n                  callback();\n                });\n              }, callback);\n            }, function (callback) {\n              // 5.4.6) If chosen path is empty or path is lexicographically\n              // less than chosen path, set chosen path to path and chosen\n              // issuer to issuer copy.\n              if (chosenPath.length === 0 || path < chosenPath) {\n                chosenPath = path;\n                chosenIssuer = issuerCopy;\n              }\n\n              callback();\n            }], nextPermutation);\n          }, function (err) {\n            if (err) {\n              return callback(err);\n            } // 5.5) Append chosen path to data to hash.\n\n\n            md.update(chosenPath); // 5.6) Replace issuer, by reference, with chosen issuer.\n\n            issuer = chosenIssuer;\n            callback();\n          });\n        }, callback);\n      }], function (err) {\n        // 6) Return issuer and the hash that results from passing data to hash\n        // through the hash algorithm.\n        callback(err, {\n          hash: md.digest(),\n          issuer: issuer\n        });\n      });\n    } // helper for modifying component during Hash First Degree Quads\n\n  }, {\n    key: \"modifyFirstDegreeComponent\",\n    value: function modifyFirstDegreeComponent(id, component) {\n      if (component.termType !== 'BlankNode') {\n        return component;\n      }\n\n      component = util.clone(component);\n      component.value = component.value === id ? '_:a' : '_:z';\n      return component;\n    } // helper for getting a related predicate\n\n  }, {\n    key: \"getRelatedPredicate\",\n    value: function getRelatedPredicate(quad) {\n      return '<' + quad.predicate.value + '>';\n    } // helper for creating hash to related blank nodes map\n\n  }, {\n    key: \"createHashToRelated\",\n    value: function createHashToRelated(id, issuer, callback) {\n      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that\n      // identify related blank nodes.\n\n      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to\n      // quads map for the key identifier.\n\n      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:\n\n      self.forEach(quads, function (quad, idx, callback) {\n        // 3.1) For each component in quad, if component is the subject, object,\n        // and graph name and it is a blank node that is not identified by\n        // identifier:\n        self.forEach(quad, function (component, key, callback) {\n          if (key === 'predicate' || !(component.termType === 'BlankNode' && component.value !== id)) {\n            return callback();\n          } // 3.1.1) Set hash to the result of the Hash Related Blank Node\n          // algorithm, passing the blank node identifier for component as\n          // related, quad, path identifier issuer as issuer, and position as\n          // either s, o, or g based on whether component is a subject, object,\n          // graph name, respectively.\n\n\n          var related = component.value;\n          var position = POSITIONS[key];\n          self.hashRelatedBlankNode(related, quad, issuer, position, function (err, hash) {\n            if (err) {\n              return callback(err);\n            } // 3.1.2) Add a mapping of hash to the blank node identifier for\n            // component to hash to related blank nodes map, adding an entry as\n            // necessary.\n\n\n            if (hash in hashToRelated) {\n              hashToRelated[hash].push(related);\n            } else {\n              hashToRelated[hash] = [related];\n            }\n\n            callback();\n          });\n        }, callback);\n      }, function (err) {\n        return callback(err, hashToRelated);\n      });\n    } // helper that iterates over quad components (skips predicate)\n\n  }, {\n    key: \"forEachComponent\",\n    value: function forEachComponent(quad, op) {\n      for (var key in quad) {\n        // skip `predicate`\n        if (key === 'predicate') {\n          continue;\n        }\n\n        op(quad[key], key, quad);\n      }\n    }\n  }]);\n\n  return URDNA2015;\n}(AsyncAlgorithm);","map":null,"metadata":{},"sourceType":"script"}