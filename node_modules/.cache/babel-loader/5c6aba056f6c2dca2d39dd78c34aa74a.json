{"ast":null,"code":"'use strict';\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n  /**\n   * Escape\n   */\n\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n      return '#/' + value;\n    }\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target; // iterate through the tokens\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]; // set the property on the target location\n\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          } // handle missing target location based on \"mode\"\n\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          } // reference the next object in the path\n\n        } else {\n          current = current[token];\n        }\n      }\n    }\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      } // delete from the target\n\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPointer;","map":null,"metadata":{},"sourceType":"script"}