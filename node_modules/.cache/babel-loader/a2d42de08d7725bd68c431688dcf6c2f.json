{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\n/**\n * Dependencies\n */\nvar assert = require('assert');\n\nvar fetch = require('node-fetch');\n\nvar _require = require('whatwg-url'),\n    URL = _require.URL;\n\nvar Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nvar _require2 = require('@trust/json-document'),\n    JSONDocument = _require2.JSONDocument;\n\nvar _require3 = require('@solid/jose'),\n    JWKSet = _require3.JWKSet;\n\nvar AuthenticationRequest = require('./AuthenticationRequest');\n\nvar AuthenticationResponse = require('./AuthenticationResponse');\n\nvar RelyingPartySchema = require('./RelyingPartySchema');\n\nvar onHttpError = require('./onHttpError');\n\nvar FormUrlEncoded = require('./FormUrlEncoded');\n/**\n * RelyingParty\n *\n * @class\n * Client interface for OpenID Connect Relying Party.\n *\n * @example\n *  let client = RelyingParty({\n *    provider: {\n *      name: 'Anvil Research, Inc.',\n *      url: 'https://forge.anvil.io'\n *      // configuration\n *      // jwks\n *    },\n *    defaults: {\n *      popToken: false,\n *      authenticate: {\n *        response_type: 'code',\n *        display: 'popup',\n *        scope: 'openid profile email'\n *      },\n *      register: {\n *        client_name: 'Example',\n *        client_uri: 'https://example.com',\n *        logo_uri: 'https://example.com/assets/logo.png',\n *        redirect_uris: ['https://app.example.com/callback'],\n *        response_types: ['code', 'code id_token token'],\n *        grant_types: ['authorization_code'],\n *        default_max_age: 7200,\n *        post_logout_redirect_uris: ['https://app.example.com']\n *      },\n *    },\n *    registration: {\n *      // if you have it saved somewhere\n *    },\n *    store: localStorage || req.session\n *  })\n *\n *  client.discover() => Promise\n *  client.jwks() => Promise\n *  client.authenticate()\n *  client.authenticateUri()\n *  client.validateResponse(uri) => Promise\n *  client.userinfo() => Promise\n *  client.logout()\n */\n\n\nvar RelyingParty =\n/*#__PURE__*/\nfunction (_JSONDocument) {\n  \"use strict\";\n\n  _inherits(RelyingParty, _JSONDocument);\n\n  function RelyingParty() {\n    _classCallCheck(this, RelyingParty);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RelyingParty).apply(this, arguments));\n  }\n\n  _createClass(RelyingParty, [{\n    key: \"discover\",\n\n    /**\n     * Discover\n     *\n     * @description Fetches the issuer's OpenID Configuration.\n     * @returns {Promise<Object>} Resolves with the provider configuration response\n     */\n    value: function discover() {\n      var _this = this;\n\n      try {\n        var issuer = this.provider.url;\n        assert(issuer, 'RelyingParty provider must define \"url\"');\n        var url = new URL(issuer);\n        url.pathname = '.well-known/openid-configuration';\n        return fetch(url.toString()).then(onHttpError('Error fetching openid configuration')).then(function (response) {\n          return response.json().then(function (json) {\n            return _this.provider.configuration = json;\n          });\n        });\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    /**\n     * Register\n     *\n     * @description Register's a client with provider as a Relying Party\n     *\n     * @param options {Object}\n     * @returns {Promise<Object>} Resolves with the registration response object\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(options) {\n      var _this2 = this;\n\n      try {\n        var configuration = this.provider.configuration;\n        assert(configuration, 'OpenID Configuration is not initialized.');\n        assert(configuration.registration_endpoint, 'OpenID Configuration is missing registration_endpoint.');\n        var uri = configuration.registration_endpoint;\n        var method = 'post';\n        var headers = new Headers({\n          'Content-Type': 'application/json'\n        });\n        var params = this.defaults.register;\n        var body = JSON.stringify(Object.assign({}, params, options));\n        return fetch(uri, {\n          method: method,\n          headers: headers,\n          body: body\n        }).then(onHttpError('Error registering client')).then(function (response) {\n          return response.json().then(function (json) {\n            return _this2.registration = json;\n          });\n        });\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return JSON.stringify(this);\n    }\n    /**\n     * @description \n     * Retrieves an existing Relying Party registration for a provider which does \n     * not support dynamic registration and which requires pre-registration by\n     * some 'out of band' method.\n     *\n     * @param options {Object}\n     * @param idp {string} Key identifying which registration data should be retrieved.\n     * @returns {Promise<Object>} Resolves with the registration response object.\n     */\n\n  }, {\n    key: \"getRegistration\",\n    value: function getRegistration(options, idp, oobRegistration) {\n      var _this3 = this;\n\n      return Promise.resolve().then(function () {\n        return _this3.registration = oobRegistration.getRegistration(idp);\n      }).catch(function (error) {\n        throw error;\n      });\n    }\n    /**\n     * jwks\n     *\n     * @description Promises the issuer's JWK Set.\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"jwks\",\n    value: function jwks() {\n      var _this4 = this;\n\n      try {\n        var configuration = this.provider.configuration;\n        assert(configuration, 'OpenID Configuration is not initialized.');\n        assert(configuration.jwks_uri, 'OpenID Configuration is missing jwks_uri.');\n        var uri = configuration.jwks_uri;\n        return fetch(uri).then(onHttpError('Error resolving provider keys')).then(function (response) {\n          return response.json().then(function (json) {\n            return JWKSet.importKeys(json);\n          }).then(function (jwks) {\n            return _this4.provider.jwks = jwks;\n          });\n        });\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    /**\n     * createRequest\n     *\n     * @param options {Object} Authn request options hashmap\n     * @param options.redirect_uri {string}\n     * @param options.response_type {string} e.g. 'code' or 'id_token token'\n     * @param session {Session|Storage} req.session or localStorage\n     * @returns {Promise<string>} Authn request URL\n     */\n\n  }, {\n    key: \"createRequest\",\n    value: function createRequest(options, session) {\n      return AuthenticationRequest.create(this, options, session || this.store);\n    }\n    /**\n     * Validate Response\n     *\n     * @param response {string} req.query or req.body.text\n     * @param session {Session|Storage} req.session or localStorage or similar\n     *\n     * @returns {Promise<Session>}\n     */\n\n  }, {\n    key: \"validateResponse\",\n    value: function validateResponse(response) {\n      var session = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.store;\n      var options;\n\n      if (response.match(/^http(s?):\\/\\//)) {\n        options = {\n          rp: this,\n          redirect: response,\n          session: session\n        };\n      } else {\n        options = {\n          rp: this,\n          body: response,\n          session: session\n        };\n      }\n\n      var authResponse = new AuthenticationResponse(options);\n      return AuthenticationResponse.validateResponse(authResponse);\n    }\n    /**\n     * userinfo\n     *\n     * @description\n     * Promises the authenticated user's claims.\n     * access_token can be supplied directly. If not, it is retrieved from storage, if available. \n     * Depending on when userinfo is called, access_token may not yet have been saved to storage.\n     *\n     * @param accessToken {string=} Optional access token from current user session for use against the User Info endpoint\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"userinfo\",\n    value: function userinfo(accessToken) {\n      try {\n        var configuration = this.provider.configuration;\n        assert(configuration, 'OpenID Configuration is not initialized.');\n        assert(configuration.userinfo_endpoint, 'OpenID Configuration is missing userinfo_endpoint.');\n        accessToken = accessToken || this.store.access_token;\n        assert(accessToken, 'Missing access token.');\n        var uri = configuration.userinfo_endpoint;\n        var headers = new Headers({\n          'Content-Type': 'application/json',\n          'Authorization': \"Bearer \".concat(accessToken)\n        });\n        return fetch(uri, {\n          headers: headers\n        }).then(onHttpError('Error fetching userinfo')).then(function (response) {\n          return response.json();\n        });\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    /**\n     * logoutRequest\n     *\n     * Composes and returns the logout request URI, based on the OP's\n     * `end_session_endpoint`, with appropriate parameters.\n     *\n     * Note: Calling client code has the responsibility to clear the local\n     * session state (for example, by calling `rp.clearSession()`). In addition,\n     * some IdPs (such as Google) may not provide an `end_session_endpoint`,\n     * in which case, this method will return null.\n     *\n     * @see https://openid.net/specs/openid-connect-session-1_0.html#RPLogout\n     *\n     * @throws {Error} If provider config is not initialized\n     *\n     * @throws {Error} If `post_logout_redirect_uri` was provided without a\n     *   corresponding `id_token_hint`\n     *\n     * @param [options={}] {object}\n     *\n     * @param [options.id_token_hint] {string} RECOMMENDED.\n     *   Previously issued ID Token passed to the logout endpoint as\n     *   a hint about the End-User's current authenticated session with the\n     *   Client. This is used as an indication of the identity of the End-User\n     *   that the RP is requesting be logged out by the OP. The OP *need not* be\n     *   listed as an audience of the ID Token when it is used as an\n     *   `id_token_hint` value.\n     *\n     * @param [options.post_logout_redirect_uri] {string} OPTIONAL. URL to which\n     *   the RP is requesting that the End-User's User Agent be redirected after\n     *   a logout has been performed. The value MUST have been previously\n     *   registered with the OP, either using the `post_logout_redirect_uris`\n     *   Registration parameter or via another mechanism. If supplied, the OP\n     *   SHOULD honor this request following the logout.\n     *\n     *   Note: The requirement to validate the uri for previous registration means\n     *   that, in practice, the `id_token_hint` is REQUIRED if\n     *   `post_logout_redirect_uri` is used. Otherwise, the OP has no way to get\n     *   the `client_id` to load the saved client registration, to validate the\n     *   uri. The only way it can get it is by decoding the `id_token_hint`.\n     *\n     * @param [options.state] {string} OPTIONAL. Opaque value used by the RP to\n     *   maintain state between the logout request and the callback to the\n     *   endpoint specified by the `post_logout_redirect_uri` query parameter. If\n     *   included in the logout request, the OP passes this value back to the RP\n     *   using the `state` query parameter when redirecting the User Agent back to\n     *   the RP.\n     *\n     * TODO: In the future, consider adding `response_mode` param, for the OP to\n     *   determine how to return the `state` back the RP.\n     *   @see http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\n     *\n     * TODO: Handle special cases for popular providers (Google, MSFT)\n     *\n     * @returns {string|null} Logout uri (or null if no end_session_endpoint was\n     *   provided in the IdP config)\n     */\n\n  }, {\n    key: \"logoutRequest\",\n    value: function logoutRequest() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var id_token_hint = options.id_token_hint,\n          post_logout_redirect_uri = options.post_logout_redirect_uri,\n          state = options.state;\n      var configuration;\n      assert(this.provider, 'OpenID Configuration is not initialized');\n      configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized');\n\n      if (!configuration.end_session_endpoint) {\n        console.log(\"OpenId Configuration for \" + \"\".concat(configuration.issuer, \" is missing end_session_endpoint\"));\n        return null;\n      }\n\n      if (post_logout_redirect_uri && !id_token_hint) {\n        throw new Error('id_token_hint is required when using post_logout_redirect_uri');\n      }\n\n      var params = {};\n\n      if (id_token_hint) {\n        params.id_token_hint = id_token_hint;\n      }\n\n      if (post_logout_redirect_uri) {\n        params.post_logout_redirect_uri = post_logout_redirect_uri;\n      }\n\n      if (state) {\n        params.state = state;\n      }\n\n      var url = new URL(configuration.end_session_endpoint);\n      url.search = FormUrlEncoded.encode(params);\n      return url.href;\n    }\n    /**\n     * Logout\n     *\n     * @deprecated\n     *\n     * TODO: Add deprecation warnings, then remove. Client code should\n     *   use `logoutRequest()` instead\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      var _this5 = this;\n\n      var configuration;\n\n      try {\n        assert(this.provider, 'OpenID Configuration is not initialized.');\n        configuration = this.provider.configuration;\n        assert(configuration, 'OpenID Configuration is not initialized.');\n      } catch (error) {\n        return Promise.reject(error);\n      }\n\n      if (!configuration.end_session_endpoint) {\n        this.clearSession();\n        return Promise.resolve(undefined);\n      }\n\n      var uri = configuration.end_session_endpoint;\n      var method = 'get';\n      return fetch(uri, {\n        method: method,\n        credentials: 'include'\n      }).then(onHttpError('Error logging out')).then(function () {\n        return _this5.clearSession();\n      }); // TODO: Validate `frontchannel_logout_uri` if necessary\n\n      /**\n       * frontchannel_logout_uri - OPTIONAL. RP URL that will cause the RP to log\n       * itself out when rendered in an iframe by the OP.\n       *\n       * An `iss` (issuer) query parameter and a `sid`\n       * (session ID) query parameter MAY be included by the OP to enable the RP\n       * to validate the request and to determine which of the potentially\n       * multiple sessions is to be logged out. If a sid (session ID) query\n       * parameter is included, an iss (issuer) query parameter MUST also be\n       * included.\n       * @see https://openid.net/specs/openid-connect-frontchannel-1_0.html#RPLogout\n       */\n    }\n  }, {\n    key: \"clearSession\",\n    value: function clearSession() {\n      var session = this.store;\n\n      if (!session) {\n        return;\n      }\n\n      delete session[SESSION_PRIVATE_KEY];\n    }\n    /**\n     * @param uri {string} Target Resource Server URI\n     * @param idToken {IDToken} ID Token to be embedded in the PoP token\n     *\n     * @returns {Promise<PoPToken>}\n     */\n\n  }, {\n    key: \"popTokenFor\",\n    value: function popTokenFor(uri, idToken) {\n      return PoPToken.issueFor(uri, idToken);\n    }\n  }], [{\n    key: \"from\",\n\n    /**\n     * from\n     *\n     * @description\n     * Create a RelyingParty instance from a previously registered client.\n     *\n     * @param {Object} data\n     * @returns {Promise<RelyingParty>}\n     */\n    value: function from(data) {\n      var rp = new RelyingParty(data);\n      var validation = rp.validate(); // schema validation\n\n      if (!validation.valid) {\n        return Promise.reject(new Error(JSON.stringify(validation)));\n      }\n\n      var jwks = rp.provider.jwks; // request the JWK Set if missing\n\n      if (!jwks) {\n        return rp.jwks().then(function () {\n          return rp;\n        });\n      } // otherwise import the JWK Set to webcrypto\n\n\n      return JWKSet.importKeys(jwks).then(function (jwks) {\n        rp.provider.jwks = jwks;\n        return rp;\n      });\n    }\n    /**\n     * register\n     *\n     * @param issuer {string} Provider URL\n     * @param registration {Object} Client dynamic registration options\n     * @param options {Object}\n     * @param options.defaults\n     * @param [options.store] {Session|Storage}\n     * @param [oobRegistration] {Object} Object providing getRegistration(key) function for out-of-band registrations\n     * @param [idpId] {string} A tag identifying the provider used for looking up out-of-band registration data.\n     * @returns {Promise<RelyingParty>} RelyingParty instance, registered.\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(issuer, registration, options, idpId, oobRegistration) {\n      var rp = new RelyingParty({\n        provider: {\n          url: issuer\n        },\n        defaults: Object.assign({}, options.defaults),\n        store: options.store\n      });\n      return Promise.resolve().then(function () {\n        return rp.discover();\n      }).then(function () {\n        return rp.jwks();\n      }).then(function () {\n        assert(rp.provider.configuration, 'OpenID Configuration is not initialized.');\n        return rp.provider.configuration.registration_endpoint ? rp.register(registration) : rp.getRegistration(registration, idpId, oobRegistration);\n      }).then(function () {\n        return rp;\n      });\n    }\n  }, {\n    key: \"schema\",\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return RelyingPartySchema;\n    }\n  }]);\n\n  return RelyingParty;\n}(JSONDocument);\n\nvar SESSION_PRIVATE_KEY = 'oidc.session.privateKey';\nRelyingParty.SESSION_PRIVATE_KEY = SESSION_PRIVATE_KEY;\nmodule.exports = RelyingParty;","map":null,"metadata":{},"sourceType":"script"}