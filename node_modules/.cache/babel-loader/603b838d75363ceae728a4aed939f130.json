{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs'; // The next ID for new blank nodes\n\nvar blankNodePrefix = 0,\n    blankNodeCount = 0; // ## Constructor\n\nvar N3Parser =\n/*#__PURE__*/\nfunction () {\n  function N3Parser(options) {\n    _classCallCheck(this, N3Parser);\n\n    this._contextStack = [];\n    this._graph = null; // Set the document IRI\n\n    options = options || {};\n\n    this._setBase(options.baseIRI);\n\n    options.factory && initDataFactory(this, options.factory); // Set supported features depending on the format\n\n    var format = typeof options.format === 'string' ? options.format.match(/\\w*$/)[0].toLowerCase() : '',\n        isTurtle = format === 'turtle',\n        isTriG = format === 'trig',\n        isNTriples = /triple/.test(format),\n        isNQuads = /quad/.test(format),\n        isN3 = this._n3Mode = /n3/.test(format),\n        isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) this._readPredicateOrNamedGraph = this._readPredicate;\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3); // Disable relative IRIs in N-Triples or N-Quads mode\n\n    if (isLineMode) this._resolveRelativeIRI = function (iri) {\n      return '';\n    };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({\n      lineMode: isLineMode,\n      n3: isN3\n    }); // Disable explicit quantifiers by default\n\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  } // ## Static class methods\n  // ### `_resetBlankNodeIds` restarts blank node identification\n\n\n  _createClass(N3Parser, [{\n    key: \"_blank\",\n    // ## Private methods\n    // ### `_blank` creates a new blank node\n    value: function _blank() {\n      return this._blankNode('b' + blankNodeCount++);\n    } // ### `_setBase` sets the base IRI to resolve relative IRIs\n\n  }, {\n    key: \"_setBase\",\n    value: function _setBase(baseIRI) {\n      if (!baseIRI) this._base = null;else {\n        // Remove fragment if present\n        var fragmentPos = baseIRI.indexOf('#');\n        if (fragmentPos >= 0) baseIRI = baseIRI.substr(0, fragmentPos); // Set base IRI and its components\n\n        this._base = baseIRI;\n        this._basePath = baseIRI.indexOf('/') < 0 ? baseIRI : baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n        baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n        this._baseRoot = baseIRI[0];\n        this._baseScheme = baseIRI[1];\n      }\n    } // ### `_saveContext` stores the current parsing context\n    // when entering a new scope (list, blank node, formula)\n\n  }, {\n    key: \"_saveContext\",\n    value: function _saveContext(type, graph, subject, predicate, object) {\n      var n3Mode = this._n3Mode;\n\n      this._contextStack.push({\n        subject: subject,\n        predicate: predicate,\n        object: object,\n        graph: graph,\n        type: type,\n        inverse: n3Mode ? this._inversePredicate : false,\n        blankPrefix: n3Mode ? this._prefixes._ : '',\n        quantified: n3Mode ? this._quantified : null\n      }); // The settings below only apply to N3 streams\n\n\n      if (n3Mode) {\n        // Every new scope resets the predicate direction\n        this._inversePredicate = false; // In N3, blank nodes are scoped to a formula\n        // (using a dot as separator, as a blank node label cannot start with it)\n\n        this._prefixes._ = this._graph ? this._graph.id.substr(2) + '.' : '.'; // Quantifiers are scoped to a formula\n\n        this._quantified = Object.create(this._quantified);\n      }\n    } // ### `_restoreContext` restores the parent context\n    // when leaving a scope (list, blank node, formula)\n\n  }, {\n    key: \"_restoreContext\",\n    value: function _restoreContext() {\n      var context = this._contextStack.pop(),\n          n3Mode = this._n3Mode;\n\n      this._subject = context.subject;\n      this._predicate = context.predicate;\n      this._object = context.object;\n      this._graph = context.graph; // The settings below only apply to N3 streams\n\n      if (n3Mode) {\n        this._inversePredicate = context.inverse;\n        this._prefixes._ = context.blankPrefix;\n        this._quantified = context.quantified;\n      }\n    } // ### `_readInTopContext` reads a token when in the top context\n\n  }, {\n    key: \"_readInTopContext\",\n    value: function _readInTopContext(token) {\n      switch (token.type) {\n        // If an EOF token arrives in the top context, signal that we're done\n        case 'eof':\n          if (this._graph !== null) return this._error('Unclosed graph', token);\n          delete this._prefixes._;\n          return this._callback(null, null, this._prefixes);\n        // It could be a prefix declaration\n\n        case 'PREFIX':\n          this._sparqlStyle = true;\n\n        case '@prefix':\n          return this._readPrefix;\n        // It could be a base declaration\n\n        case 'BASE':\n          this._sparqlStyle = true;\n\n        case '@base':\n          return this._readBaseIRI;\n        // It could be a graph\n\n        case '{':\n          if (this._supportsNamedGraphs) {\n            this._graph = '';\n            this._subject = null;\n            return this._readSubject;\n          }\n\n        case 'GRAPH':\n          if (this._supportsNamedGraphs) return this._readNamedGraphLabel;\n        // Otherwise, the next token must be a subject\n\n        default:\n          return this._readSubject(token);\n      }\n    } // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n\n  }, {\n    key: \"_readEntity\",\n    value: function _readEntity(token, quantifier) {\n      var value;\n\n      switch (token.type) {\n        // Read a relative or absolute IRI\n        case 'IRI':\n        case 'typeIRI':\n          var iri = this._resolveIRI(token.value);\n\n          if (iri === '') return this._error('Invalid IRI', token);\n          value = this._namedNode(iri);\n          break;\n        // Read a prefixed name\n\n        case 'type':\n        case 'prefixed':\n          var prefix = this._prefixes[token.prefix];\n          if (prefix === undefined) return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n          value = this._namedNode(prefix + token.value);\n          break;\n        // Read a blank node\n\n        case 'blank':\n          value = this._blankNode(this._prefixes[token.prefix] + token.value);\n          break;\n        // Read a variable\n\n        case 'var':\n          value = this._variable(token.value.substr(1));\n          break;\n        // Everything else is not an entity\n\n        default:\n          return this._error('Expected entity but got ' + token.type, token);\n      } // In N3 mode, replace the entity if it is quantified\n\n\n      if (!quantifier && this._n3Mode && value.id in this._quantified) value = this._quantified[value.id];\n      return value;\n    } // ### `_readSubject` reads a quad's subject\n\n  }, {\n    key: \"_readSubject\",\n    value: function _readSubject(token) {\n      this._predicate = null;\n\n      switch (token.type) {\n        case '[':\n          // Start a new quad with a new blank node as subject\n          this._saveContext('blank', this._graph, this._subject = this._blank(), null, null);\n\n          return this._readBlankNodeHead;\n\n        case '(':\n          // Start a new list\n          this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n\n          this._subject = null;\n          return this._readListItem;\n\n        case '{':\n          // Start a new formula\n          if (!this._n3Mode) return this._error('Unexpected graph', token);\n\n          this._saveContext('formula', this._graph, this._graph = this._blank(), null, null);\n\n          return this._readSubject;\n\n        case '}':\n          // No subject; the graph in which we are reading is closed instead\n          return this._readPunctuation(token);\n\n        case '@forSome':\n          if (!this._n3Mode) return this._error('Unexpected \"@forSome\"', token);\n          this._subject = null;\n          this._predicate = this.N3_FORSOME;\n          this._quantifier = this._blankNode;\n          return this._readQuantifierList;\n\n        case '@forAll':\n          if (!this._n3Mode) return this._error('Unexpected \"@forAll\"', token);\n          this._subject = null;\n          this._predicate = this.N3_FORALL;\n          this._quantifier = this._variable;\n          return this._readQuantifierList;\n\n        default:\n          // Read the subject entity\n          if ((this._subject = this._readEntity(token)) === undefined) return; // In N3 mode, the subject might be a path\n\n          if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph);\n      } // The next token must be a predicate,\n      // or, if the subject was actually a graph IRI, a named graph\n\n\n      return this._readPredicateOrNamedGraph;\n    } // ### `_readPredicate` reads a quad's predicate\n\n  }, {\n    key: \"_readPredicate\",\n    value: function _readPredicate(token) {\n      var type = token.type;\n\n      switch (type) {\n        case 'inverse':\n          this._inversePredicate = true;\n\n        case 'abbreviation':\n          this._predicate = this.ABBREVIATIONS[token.value];\n          break;\n\n        case '.':\n        case ']':\n        case '}':\n          // Expected predicate didn't come, must have been trailing semicolon\n          if (this._predicate === null) return this._error('Unexpected ' + type, token);\n          this._subject = null;\n          return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n\n        case ';':\n          // Additional semicolons can be safely ignored\n          return this._predicate !== null ? this._readPredicate : this._error('Expected predicate but got ;', token);\n\n        case 'blank':\n          if (!this._n3Mode) return this._error('Disallowed blank node as predicate', token);\n\n        default:\n          if ((this._predicate = this._readEntity(token)) === undefined) return;\n      } // The next token must be an object\n\n\n      return this._readObject;\n    } // ### `_readObject` reads a quad's object\n\n  }, {\n    key: \"_readObject\",\n    value: function _readObject(token) {\n      switch (token.type) {\n        case 'literal':\n          // Regular literal, can still get a datatype or language\n          if (token.prefix.length === 0) {\n            this._literalValue = token.value;\n            return this._readDataTypeOrLang;\n          } // Pre-datatyped string literal (prefix stores the datatype)\n          else this._object = this._literal(token.value, this._namedNode(token.prefix));\n\n          break;\n\n        case '[':\n          // Start a new quad with a new blank node as subject\n          this._saveContext('blank', this._graph, this._subject, this._predicate, this._subject = this._blank());\n\n          return this._readBlankNodeHead;\n\n        case '(':\n          // Start a new list\n          this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n\n          this._subject = null;\n          return this._readListItem;\n\n        case '{':\n          // Start a new formula\n          if (!this._n3Mode) return this._error('Unexpected graph', token);\n\n          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blank());\n\n          return this._readSubject;\n\n        default:\n          // Read the object entity\n          if ((this._object = this._readEntity(token)) === undefined) return; // In N3 mode, the object might be a path\n\n          if (this._n3Mode) return this._getPathReader(this._getContextEndReader());\n      }\n\n      return this._getContextEndReader();\n    } // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n\n  }, {\n    key: \"_readPredicateOrNamedGraph\",\n    value: function _readPredicateOrNamedGraph(token) {\n      return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n    } // ### `_readGraph` reads a graph\n\n  }, {\n    key: \"_readGraph\",\n    value: function _readGraph(token) {\n      if (token.type !== '{') return this._error('Expected graph but got ' + token.type, token); // The \"subject\" we read is actually the GRAPH's label\n\n      this._graph = this._subject, this._subject = null;\n      return this._readSubject;\n    } // ### `_readBlankNodeHead` reads the head of a blank node\n\n  }, {\n    key: \"_readBlankNodeHead\",\n    value: function _readBlankNodeHead(token) {\n      if (token.type === ']') {\n        this._subject = null;\n        return this._readBlankNodeTail(token);\n      } else {\n        this._predicate = null;\n        return this._readPredicate(token);\n      }\n    } // ### `_readBlankNodeTail` reads the end of a blank node\n\n  }, {\n    key: \"_readBlankNodeTail\",\n    value: function _readBlankNodeTail(token) {\n      if (token.type !== ']') return this._readBlankNodePunctuation(token); // Store blank node quad\n\n      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this blank node\n\n      var empty = this._predicate === null;\n\n      this._restoreContext(); // If the blank node was the subject, continue reading the predicate\n\n\n      if (this._object === null) // If the blank node was empty, it could be a named graph label\n        return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank; // If the blank node was the object, restore previous context and read punctuation\n      else return this._getContextEndReader();\n    } // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n\n  }, {\n    key: \"_readPredicateAfterBlank\",\n    value: function _readPredicateAfterBlank(token) {\n      switch (token.type) {\n        case '.':\n        case '}':\n          // No predicate is coming if the triple is terminated here\n          this._subject = null;\n          return this._readPunctuation(token);\n\n        default:\n          return this._readPredicate(token);\n      }\n    } // ### `_readListItem` reads items from a list\n\n  }, {\n    key: \"_readListItem\",\n    value: function _readListItem(token) {\n      var item = null,\n          // The item of the list\n      list = null,\n          // The list itself\n      previousList = this._subject,\n          // The previous list that contains this list\n      stack = this._contextStack,\n          // The stack of parent contexts\n      parent = stack[stack.length - 1],\n          // The parent containing the current list\n      next = this._readListItem; // The next function to execute\n\n      switch (token.type) {\n        case '[':\n          // Stack the current list quad and start a new quad with a blank node as subject\n          this._saveContext('blank', this._graph, list = this._blank(), this.RDF_FIRST, this._subject = item = this._blank());\n\n          next = this._readBlankNodeHead;\n          break;\n\n        case '(':\n          // Stack the current list quad and start a new list\n          this._saveContext('list', this._graph, list = this._blank(), this.RDF_FIRST, this.RDF_NIL);\n\n          this._subject = null;\n          break;\n\n        case ')':\n          // Closing the list; restore the parent context\n          this._restoreContext(); // If this list is contained within a parent list, return the membership quad here.\n          // This will be `<parent list element> rdf:first <this list>.`.\n\n\n          if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._emit(this._subject, this._predicate, this._object, this._graph); // Was this list the parent's subject?\n\n          if (this._predicate === null) {\n            // The next token is the predicate\n            next = this._readPredicate; // No list tail if this was an empty list\n\n            if (this._subject === this.RDF_NIL) return next;\n          } // The list was in the parent context's object\n          else {\n              next = this._getContextEndReader(); // No list tail if this was an empty list\n\n              if (this._object === this.RDF_NIL) return next;\n            } // Close the list by making the head nil\n\n\n          list = this.RDF_NIL;\n          break;\n\n        case 'literal':\n          // Regular literal, can still get a datatype or language\n          if (token.prefix.length === 0) {\n            this._literalValue = token.value;\n            next = this._readListItemDataTypeOrLang;\n          } // Pre-datatyped string literal (prefix stores the datatype)\n          else {\n              item = this._literal(token.value, this._namedNode(token.prefix));\n              next = this._getContextEndReader();\n            }\n\n          break;\n\n        default:\n          if ((item = this._readEntity(token)) === undefined) return;\n      } // Create a new blank node if no item head was assigned yet\n\n\n      if (list === null) this._subject = list = this._blank(); // Is this the first element of the list?\n\n      if (previousList === null) {\n        // This list is either the subject or the object of its parent\n        if (parent.predicate === null) parent.subject = list;else parent.object = list;\n      } else {\n        // Continue the previous list with the current list\n        this._emit(previousList, this.RDF_REST, list, this._graph);\n      } // If an item was read, add it to the list\n\n\n      if (item !== null) {\n        // In N3 mode, the item might be a path\n        if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n          // Create a new context to add the item's path\n          this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n\n          this._subject = item, this._predicate = null; // _readPath will restore the context and output the item\n\n          return this._getPathReader(this._readListItem);\n        } // Output the item\n\n\n        this._emit(list, this.RDF_FIRST, item, this._graph);\n      }\n\n      return next;\n    } // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n\n  }, {\n    key: \"_readDataTypeOrLang\",\n    value: function _readDataTypeOrLang(token) {\n      return this._completeLiteral(token, false);\n    } // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n\n  }, {\n    key: \"_readListItemDataTypeOrLang\",\n    value: function _readListItemDataTypeOrLang(token) {\n      return this._completeLiteral(token, true);\n    } // ### `_completeLiteral` completes a literal with an optional datatype or language\n\n  }, {\n    key: \"_completeLiteral\",\n    value: function _completeLiteral(token, listItem) {\n      switch (token.type) {\n        // Create a datatyped literal\n        case 'type':\n        case 'typeIRI':\n          var datatype = this._readEntity(token);\n\n          if (datatype === undefined) return; // No datatype means an error occurred\n\n          this._object = this._literal(this._literalValue, datatype);\n          token = null;\n          break;\n        // Create a language-tagged string\n\n        case 'langcode':\n          this._object = this._literal(this._literalValue, token.value);\n          token = null;\n          break;\n        // Create a simple string literal\n\n        default:\n          this._object = this._literal(this._literalValue);\n      } // If this literal was part of a list, write the item\n      // (we could also check the context stack, but passing in a flag is faster)\n\n\n      if (listItem) this._emit(this._subject, this.RDF_FIRST, this._object, this._graph); // If the token was consumed, continue with the rest of the input\n\n      if (token === null) return this._getContextEndReader(); // Otherwise, consume the token now\n      else {\n          this._readCallback = this._getContextEndReader();\n          return this._readCallback(token);\n        }\n    } // ### `_readFormulaTail` reads the end of a formula\n\n  }, {\n    key: \"_readFormulaTail\",\n    value: function _readFormulaTail(token) {\n      if (token.type !== '}') return this._readPunctuation(token); // Store the last quad of the formula\n\n      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this formula\n\n      this._restoreContext(); // If the formula was the subject, continue reading the predicate.\n      // If the formula was the object, read punctuation.\n\n\n      return this._object === null ? this._readPredicate : this._getContextEndReader();\n    } // ### `_readPunctuation` reads punctuation between quads or quad parts\n\n  }, {\n    key: \"_readPunctuation\",\n    value: function _readPunctuation(token) {\n      var next,\n          subject = this._subject,\n          graph = this._graph,\n          inversePredicate = this._inversePredicate;\n\n      switch (token.type) {\n        // A closing brace ends a graph\n        case '}':\n          if (this._graph === null) return this._error('Unexpected graph closing', token);\n          if (this._n3Mode) return this._readFormulaTail(token);\n          this._graph = null;\n        // A dot just ends the statement, without sharing anything with the next\n\n        case '.':\n          this._subject = null;\n          next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n          if (inversePredicate) this._inversePredicate = false;\n          break;\n        // Semicolon means the subject is shared; predicate and object are different\n\n        case ';':\n          next = this._readPredicate;\n          break;\n        // Comma means both the subject and predicate are shared; the object is different\n\n        case ',':\n          next = this._readObject;\n          break;\n\n        default:\n          // An entity means this is a quad (only allowed if not already inside a graph)\n          if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n            next = this._readQuadPunctuation;\n            break;\n          }\n\n          return this._error('Expected punctuation to follow \"' + this._object.id + '\"', token);\n      } // A quad has been completed now, so return it\n\n\n      if (subject !== null) {\n        var predicate = this._predicate,\n            object = this._object;\n        if (!inversePredicate) this._emit(subject, predicate, object, graph);else this._emit(object, predicate, subject, graph);\n      }\n\n      return next;\n    } // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n\n  }, {\n    key: \"_readBlankNodePunctuation\",\n    value: function _readBlankNodePunctuation(token) {\n      var next;\n\n      switch (token.type) {\n        // Semicolon means the subject is shared; predicate and object are different\n        case ';':\n          next = this._readPredicate;\n          break;\n        // Comma means both the subject and predicate are shared; the object is different\n\n        case ',':\n          next = this._readObject;\n          break;\n\n        default:\n          return this._error('Expected punctuation to follow \"' + this._object.id + '\"', token);\n      } // A quad has been completed now, so return it\n\n\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n      return next;\n    } // ### `_readQuadPunctuation` reads punctuation after a quad\n\n  }, {\n    key: \"_readQuadPunctuation\",\n    value: function _readQuadPunctuation(token) {\n      if (token.type !== '.') return this._error('Expected dot to follow quad', token);\n      return this._readInTopContext;\n    } // ### `_readPrefix` reads the prefix of a prefix declaration\n\n  }, {\n    key: \"_readPrefix\",\n    value: function _readPrefix(token) {\n      if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);\n      this._prefix = token.value;\n      return this._readPrefixIRI;\n    } // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n\n  }, {\n    key: \"_readPrefixIRI\",\n    value: function _readPrefixIRI(token) {\n      if (token.type !== 'IRI') return this._error('Expected IRI to follow prefix \"' + this._prefix + ':\"', token);\n\n      var prefixNode = this._readEntity(token);\n\n      this._prefixes[this._prefix] = prefixNode.value;\n\n      this._prefixCallback(this._prefix, prefixNode);\n\n      return this._readDeclarationPunctuation;\n    } // ### `_readBaseIRI` reads the IRI of a base declaration\n\n  }, {\n    key: \"_readBaseIRI\",\n    value: function _readBaseIRI(token) {\n      var iri = token.type === 'IRI' && this._resolveIRI(token.value);\n\n      if (!iri) return this._error('Expected valid IRI to follow base declaration', token);\n\n      this._setBase(iri);\n\n      return this._readDeclarationPunctuation;\n    } // ### `_readNamedGraphLabel` reads the label of a named graph\n\n  }, {\n    key: \"_readNamedGraphLabel\",\n    value: function _readNamedGraphLabel(token) {\n      switch (token.type) {\n        case 'IRI':\n        case 'blank':\n        case 'prefixed':\n          return this._readSubject(token), this._readGraph;\n\n        case '[':\n          return this._readNamedGraphBlankLabel;\n\n        default:\n          return this._error('Invalid graph label', token);\n      }\n    } // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n\n  }, {\n    key: \"_readNamedGraphBlankLabel\",\n    value: function _readNamedGraphBlankLabel(token) {\n      if (token.type !== ']') return this._error('Invalid graph label', token);\n      this._subject = this._blank();\n      return this._readGraph;\n    } // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n\n  }, {\n    key: \"_readDeclarationPunctuation\",\n    value: function _readDeclarationPunctuation(token) {\n      // SPARQL-style declarations don't have punctuation\n      if (this._sparqlStyle) {\n        this._sparqlStyle = false;\n        return this._readInTopContext(token);\n      }\n\n      if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);\n      return this._readInTopContext;\n    } // Reads a list of quantified symbols from a @forSome or @forAll statement\n\n  }, {\n    key: \"_readQuantifierList\",\n    value: function _readQuantifierList(token) {\n      var entity;\n\n      switch (token.type) {\n        case 'IRI':\n        case 'prefixed':\n          if ((entity = this._readEntity(token, true)) !== undefined) break;\n\n        default:\n          return this._error('Unexpected ' + token.type, token);\n      } // Without explicit quantifiers, map entities to a quantified entity\n\n\n      if (!this._explicitQuantifiers) this._quantified[entity.id] = this._quantifier('b' + blankNodeCount++); // With explicit quantifiers, output the reified quantifier\n      else {\n          // If this is the first item, start a new quantifier list\n          if (this._subject === null) this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blank(), this.QUANTIFIERS_GRAPH); // Otherwise, continue the previous list\n          else this._emit(this._subject, this.RDF_REST, this._subject = this._blank(), this.QUANTIFIERS_GRAPH); // Output the list item\n\n          this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n        }\n      return this._readQuantifierPunctuation;\n    } // Reads punctuation from a @forSome or @forAll statement\n\n  }, {\n    key: \"_readQuantifierPunctuation\",\n    value: function _readQuantifierPunctuation(token) {\n      // Read more quantifiers\n      if (token.type === ',') return this._readQuantifierList; // End of the quantifier list\n      else {\n          // With explicit quantifiers, close the quantifier list\n          if (this._explicitQuantifiers) {\n            this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n\n            this._subject = null;\n          } // Read a dot\n\n\n          this._readCallback = this._getContextEndReader();\n          return this._readCallback(token);\n        }\n    } // ### `_getPathReader` reads a potential path and then resumes with the given function\n\n  }, {\n    key: \"_getPathReader\",\n    value: function _getPathReader(afterPath) {\n      this._afterPath = afterPath;\n      return this._readPath;\n    } // ### `_readPath` reads a potential path\n\n  }, {\n    key: \"_readPath\",\n    value: function _readPath(token) {\n      switch (token.type) {\n        // Forward path\n        case '!':\n          return this._readForwardPath;\n        // Backward path\n\n        case '^':\n          return this._readBackwardPath;\n        // Not a path; resume reading where we left off\n\n        default:\n          var stack = this._contextStack,\n              parent = stack.length && stack[stack.length - 1]; // If we were reading a list item, we still need to output it\n\n          if (parent && parent.type === 'item') {\n            // The list item is the remaining subejct after reading the path\n            var item = this._subject; // Switch back to the context of the list\n\n            this._restoreContext(); // Output the list item\n\n\n            this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n          }\n\n          return this._afterPath(token);\n      }\n    } // ### `_readForwardPath` reads a '!' path\n\n  }, {\n    key: \"_readForwardPath\",\n    value: function _readForwardPath(token) {\n      var subject,\n          predicate,\n          object = this._blank(); // The next token is the predicate\n\n\n      if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's object\n\n      if (this._predicate === null) subject = this._subject, this._subject = object; // If we were reading an object, replace the subject by the path's object\n      else subject = this._object, this._object = object; // Emit the path's current quad and read its next section\n\n      this._emit(subject, predicate, object, this._graph);\n\n      return this._readPath;\n    } // ### `_readBackwardPath` reads a '^' path\n\n  }, {\n    key: \"_readBackwardPath\",\n    value: function _readBackwardPath(token) {\n      var subject = this._blank(),\n          predicate,\n          object; // The next token is the predicate\n\n\n      if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's subject\n\n      if (this._predicate === null) object = this._subject, this._subject = subject; // If we were reading an object, replace the subject by the path's subject\n      else object = this._object, this._object = subject; // Emit the path's current quad and read its next section\n\n      this._emit(subject, predicate, object, this._graph);\n\n      return this._readPath;\n    } // ### `_getContextEndReader` gets the next reader function at the end of a context\n\n  }, {\n    key: \"_getContextEndReader\",\n    value: function _getContextEndReader() {\n      var contextStack = this._contextStack;\n      if (!contextStack.length) return this._readPunctuation;\n\n      switch (contextStack[contextStack.length - 1].type) {\n        case 'blank':\n          return this._readBlankNodeTail;\n\n        case 'list':\n          return this._readListItem;\n\n        case 'formula':\n          return this._readFormulaTail;\n      }\n    } // ### `_emit` sends a quad through the callback\n\n  }, {\n    key: \"_emit\",\n    value: function _emit(subject, predicate, object, graph) {\n      this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n    } // ### `_error` emits an error message through the callback\n\n  }, {\n    key: \"_error\",\n    value: function _error(message, token) {\n      var err = new Error(message + ' on line ' + token.line + '.');\n      err.context = {\n        token: token,\n        line: token.line,\n        previousToken: this._lexer.previousToken\n      };\n\n      this._callback(err);\n\n      this._callback = noop;\n    } // ### `_resolveIRI` resolves an IRI against the base path\n\n  }, {\n    key: \"_resolveIRI\",\n    value: function _resolveIRI(iri) {\n      return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n    } // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n    // assuming that a base path has been set and that the IRI is indeed relative\n\n  }, {\n    key: \"_resolveRelativeIRI\",\n    value: function _resolveRelativeIRI(iri) {\n      // An empty relative IRI indicates the base IRI\n      if (!iri.length) return this._base; // Decide resolving strategy based in the first character\n\n      switch (iri[0]) {\n        // Resolve relative fragment IRIs against the base IRI\n        case '#':\n          return this._base + iri;\n        // Resolve relative query string IRIs by replacing the query string\n\n        case '?':\n          return this._base.replace(/(?:\\?.*)?$/, iri);\n        // Resolve root-relative IRIs at the root of the base IRI\n\n        case '/':\n          // Resolve scheme-relative IRIs to the scheme\n          return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n        // Resolve all other IRIs at the base IRI's path\n\n        default:\n          // Relative IRIs cannot contain a colon in the first path segment\n          return /^[^/:]*:/.test(iri) ? '' : this._removeDotSegments(this._basePath + iri);\n      }\n    } // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n\n  }, {\n    key: \"_removeDotSegments\",\n    value: function _removeDotSegments(iri) {\n      // Don't modify the IRI if it does not contain any dot segments\n      if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri)) return iri; // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n\n      var result = '',\n          length = iri.length,\n          i = -1,\n          pathStart = -1,\n          segmentStart = 0,\n          next = '/';\n\n      while (i < length) {\n        switch (next) {\n          // The path starts with the first slash after the authority\n          case ':':\n            if (pathStart < 0) {\n              // Skip two slashes before the authority\n              if (iri[++i] === '/' && iri[++i] === '/') // Skip to slash after the authority\n                while ((pathStart = i + 1) < length && iri[pathStart] !== '/') {\n                  i = pathStart;\n                }\n            }\n\n            break;\n          // Don't modify a query string or fragment\n\n          case '?':\n          case '#':\n            i = length;\n            break;\n          // Handle '/.' or '/..' path segments\n\n          case '/':\n            if (iri[i + 1] === '.') {\n              next = iri[++i + 1];\n\n              switch (next) {\n                // Remove a '/.' segment\n                case '/':\n                  result += iri.substring(segmentStart, i - 1);\n                  segmentStart = i + 1;\n                  break;\n                // Remove a trailing '/.' segment\n\n                case undefined:\n                case '?':\n                case '#':\n                  return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n                // Remove a '/..' segment\n\n                case '.':\n                  next = iri[++i + 1];\n\n                  if (next === undefined || next === '/' || next === '?' || next === '#') {\n                    result += iri.substring(segmentStart, i - 2); // Try to remove the parent path from result\n\n                    if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart); // Remove a trailing '/..' segment\n\n                    if (next !== '/') return result + '/' + iri.substr(i + 1);\n                    segmentStart = i + 1;\n                  }\n\n              }\n            }\n\n        }\n\n        next = iri[++i];\n      }\n\n      return result + iri.substring(segmentStart);\n    } // ## Public methods\n    // ### `parse` parses the N3 input and emits each parsed quad through the callback\n\n  }, {\n    key: \"parse\",\n    value: function parse(input, quadCallback, prefixCallback) {\n      var self = this; // The read callback is the next function to be executed when a token arrives.\n      // We start reading in the top context.\n\n      this._readCallback = this._readInTopContext;\n      this._sparqlStyle = false;\n      this._prefixes = Object.create(null);\n      this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : 'b' + blankNodePrefix++ + '_';\n      this._prefixCallback = prefixCallback || noop;\n      this._inversePredicate = false;\n      this._quantified = Object.create(null); // Parse synchronously if no quad callback is given\n\n      if (!quadCallback) {\n        var quads = [],\n            error;\n\n        this._callback = function (e, t) {\n          e ? error = e : t && quads.push(t);\n        };\n\n        this._lexer.tokenize(input).every(function (token) {\n          return self._readCallback = self._readCallback(token);\n        });\n\n        if (error) throw error;\n        return quads;\n      } // Parse asynchronously otherwise, executing the read callback when a token arrives\n\n\n      this._callback = quadCallback;\n\n      this._lexer.tokenize(input, function (error, token) {\n        if (error !== null) self._callback(error), self._callback = noop;else if (self._readCallback) self._readCallback = self._readCallback(token);\n      });\n    }\n  }], [{\n    key: \"_resetBlankNodeIds\",\n    value: function _resetBlankNodeIds() {\n      blankNodePrefix = blankNodeCount = 0;\n    }\n  }]);\n\n  return N3Parser;\n}(); // The empty function\n\n\nexport { N3Parser as default };\n\nfunction noop() {} // Initializes the parser with the given data factory\n\n\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  var namedNode = factory.namedNode;\n  parser._namedNode = namedNode;\n  parser._blankNode = factory.blankNode;\n  parser._literal = factory.literal;\n  parser._variable = factory.variable;\n  parser._quad = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph(); // Set common named nodes\n\n  parser.RDF_FIRST = namedNode(namespaces.rdf.first);\n  parser.RDF_REST = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies)\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\n\ninitDataFactory(N3Parser.prototype, N3DataFactory);","map":null,"metadata":{},"sourceType":"module"}