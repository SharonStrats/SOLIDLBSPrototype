{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _require = require('./context'),\n    isKeyword = _require.isKeyword;\n\nvar graphTypes = require('./graphTypes');\n\nvar types = require('./types');\n\nvar util = require('./util');\n\nvar JsonLdError = require('./JsonLdError');\n\nvar api = {};\nmodule.exports = api;\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\n\napi.createMergedNodeMap = function (input, options) {\n  options = options || {}; // produce a map of all subjects and name each bnode\n\n  var issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  var graphs = {\n    '@default': {}\n  };\n  api.createNodeMap(input, graphs, '@default', issuer); // add all non-default graphs to default graph\n\n  return api.mergeNodeMaps(graphs);\n};\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\n\n\napi.createNodeMap = function (input, graphs, graph, issuer, name, list) {\n  // recurse through array\n  if (types.isArray(input)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var node = _step.value;\n        api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return;\n  } // add non-object to list\n\n\n  if (!types.isObject(input)) {\n    if (list) {\n      list.push(input);\n    }\n\n    return;\n  } // add values to list\n\n\n  if (graphTypes.isValue(input)) {\n    if ('@type' in input) {\n      var type = input['@type']; // rename @type blank node\n\n      if (type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n\n    if (list) {\n      list.push(input);\n    }\n\n    return;\n  } else if (list && graphTypes.isList(input)) {\n    var _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({\n      '@list': _list\n    });\n    return;\n  } // Note: At this point, input must be a subject.\n  // spec requires @type to be named first, so assign names early\n\n\n  if ('@type' in input) {\n    var _types = input['@type'];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = _types[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _type = _step2.value;\n\n        if (_type.indexOf('_:') === 0) {\n          issuer.getId(_type);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } // get name for subject\n\n\n  if (types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ? issuer.getId(input['@id']) : input['@id'];\n  } // add subject reference to list\n\n\n  if (list) {\n    list.push({\n      '@id': name\n    });\n  } // create new subject or merge into existing one\n\n\n  var subjects = graphs[graph];\n  var subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  var properties = Object.keys(input).sort();\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var property = _step3.value;\n\n      // skip @id\n      if (property === '@id') {\n        continue;\n      } // handle reverse properties\n\n\n      if (property === '@reverse') {\n        var referencedNode = {\n          '@id': name\n        };\n        var reverseMap = input['@reverse'];\n\n        for (var reverseProperty in reverseMap) {\n          var items = reverseMap[reverseProperty];\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = items[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var item = _step4.value;\n              var itemName = item['@id'];\n\n              if (graphTypes.isBlankNode(item)) {\n                itemName = issuer.getId(itemName);\n              }\n\n              api.createNodeMap(item, graphs, graph, issuer, itemName);\n              util.addValue(subjects[itemName], reverseProperty, referencedNode, {\n                propertyIsArray: true,\n                allowDuplicate: false\n              });\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n\n        continue;\n      } // recurse into graph\n\n\n      if (property === '@graph') {\n        // add graph subjects map entry\n        if (!(name in graphs)) {\n          graphs[name] = {};\n        }\n\n        api.createNodeMap(input[property], graphs, name, issuer);\n        continue;\n      } // copy non-@type keywords\n\n\n      if (property !== '@type' && isKeyword(property)) {\n        if (property === '@index' && property in subject && (input[property] !== subject[property] || input[property]['@id'] !== subject[property]['@id'])) {\n          throw new JsonLdError('Invalid JSON-LD syntax; conflicting @index property detected.', 'jsonld.SyntaxError', {\n            code: 'conflicting indexes',\n            subject: subject\n          });\n        }\n\n        subject[property] = input[property];\n        continue;\n      } // iterate over objects\n\n\n      var objects = input[property]; // if property is a bnode, assign it a new id\n\n      if (property.indexOf('_:') === 0) {\n        property = issuer.getId(property);\n      } // ensure property is added for empty arrays\n\n\n      if (objects.length === 0) {\n        util.addValue(subject, property, [], {\n          propertyIsArray: true\n        });\n        continue;\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = objects[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var o = _step5.value;\n\n          if (property === '@type') {\n            // rename @type blank nodes\n            o = o.indexOf('_:') === 0 ? issuer.getId(o) : o;\n          } // handle embedded subject or subject reference\n\n\n          if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n            // relabel blank node @id\n            var id = graphTypes.isBlankNode(o) ? issuer.getId(o['@id']) : o['@id']; // add reference and recurse\n\n            util.addValue(subject, property, {\n              '@id': id\n            }, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n            api.createNodeMap(o, graphs, graph, issuer, id);\n          } else if (graphTypes.isValue(o)) {\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          } else if (graphTypes.isList(o)) {\n            // handle @list\n            var _list2 = [];\n            api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list2);\n            o = {\n              '@list': _list2\n            };\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          } else {\n            // handle @value\n            api.createNodeMap(o, graphs, graph, issuer, name);\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n};\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\n\n\napi.mergeNodeMapGraphs = function (graphs) {\n  var merged = {};\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = Object.keys(graphs).sort()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var name = _step6.value;\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = Object.keys(graphs[name]).sort()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var id = _step7.value;\n          var node = graphs[name][id];\n\n          if (!(id in merged)) {\n            merged[id] = {\n              '@id': id\n            };\n          }\n\n          var mergedNode = merged[id];\n          var _iteratorNormalCompletion8 = true;\n          var _didIteratorError8 = false;\n          var _iteratorError8 = undefined;\n\n          try {\n            for (var _iterator8 = Object.keys(node).sort()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n              var property = _step8.value;\n\n              if (isKeyword(property)) {\n                // copy keywords\n                mergedNode[property] = util.clone(node[property]);\n              } else {\n                // merge objects\n                var _iteratorNormalCompletion9 = true;\n                var _didIteratorError9 = false;\n                var _iteratorError9 = undefined;\n\n                try {\n                  for (var _iterator9 = node[property][Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                    var value = _step9.value;\n                    util.addValue(mergedNode, property, util.clone(value), {\n                      propertyIsArray: true,\n                      allowDuplicate: false\n                    });\n                  }\n                } catch (err) {\n                  _didIteratorError9 = true;\n                  _iteratorError9 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                      _iterator9.return();\n                    }\n                  } finally {\n                    if (_didIteratorError9) {\n                      throw _iteratorError9;\n                    }\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError8 = true;\n            _iteratorError8 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                _iterator8.return();\n              }\n            } finally {\n              if (_didIteratorError8) {\n                throw _iteratorError8;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = function (graphs) {\n  // add all non-default graphs to default graph\n  var defaultGraph = graphs['@default'];\n  var graphNames = Object.keys(graphs).sort();\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = graphNames[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var graphName = _step10.value;\n\n      if (graphName === '@default') {\n        continue;\n      }\n\n      var nodeMap = graphs[graphName];\n      var subject = defaultGraph[graphName];\n\n      if (!subject) {\n        defaultGraph[graphName] = subject = {\n          '@id': graphName,\n          '@graph': []\n        };\n      } else if (!('@graph' in subject)) {\n        subject['@graph'] = [];\n      }\n\n      var graph = subject['@graph'];\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = Object.keys(nodeMap).sort()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var id = _step11.value;\n          var node = nodeMap[id]; // only add full subjects\n\n          if (!graphTypes.isSubjectReference(node)) {\n            graph.push(node);\n          }\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n            _iterator11.return();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n\n  return defaultGraph;\n};","map":null,"metadata":{},"sourceType":"script"}