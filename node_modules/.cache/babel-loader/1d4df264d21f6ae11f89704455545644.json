{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n// **N3Store** objects store N3 quads by graph in memory.\nimport N3DataFactory from './N3DataFactory';\nimport { Readable } from 'stream';\nvar _N3DataFactory$intern = N3DataFactory.internal,\n    toId = _N3DataFactory$intern.toId,\n    fromId = _N3DataFactory$intern.fromId; // ## Constructor\n\nvar N3Store =\n/*#__PURE__*/\nfunction () {\n  function N3Store(quads, options) {\n    _classCallCheck(this, N3Store);\n\n    // The number of quads is initially zero\n    this._size = 0; // `_graphs` contains subject, predicate, and object indexes per graph\n\n    this._graphs = Object.create(null); // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n\n    this._blankNodeIndex = 0; // Shift parameters if `quads` is not given\n\n    if (!options && quads && !quads[0]) options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory; // Add quads if passed\n\n    if (quads) this.addQuads(quads);\n  } // ## Public properties\n  // ### `size` returns the number of quads in the store\n\n\n  _createClass(N3Store, [{\n    key: \"_addToIndex\",\n    // ## Private methods\n    // ### `_addToIndex` adds a quad to a three-layered index.\n    // Returns if the index has changed, if the entry did not already exist.\n    value: function _addToIndex(index0, key0, key1, key2) {\n      // Create layers as necessary\n      var index1 = index0[key0] || (index0[key0] = {});\n      var index2 = index1[key1] || (index1[key1] = {}); // Setting the key to _any_ value signals the presence of the quad\n\n      var existed = key2 in index2;\n      if (!existed) index2[key2] = null;\n      return !existed;\n    } // ### `_removeFromIndex` removes a quad from a three-layered index\n\n  }, {\n    key: \"_removeFromIndex\",\n    value: function _removeFromIndex(index0, key0, key1, key2) {\n      // Remove the quad from the index\n      var index1 = index0[key0],\n          index2 = index1[key1],\n          key;\n      delete index2[key2]; // Remove intermediary index layers if they are empty\n\n      for (key in index2) {\n        return;\n      }\n\n      delete index1[key1];\n\n      for (key in index1) {\n        return;\n      }\n\n      delete index0[key0];\n    } // ### `_findInIndex` finds a set of quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n    // `name0`, `name1`, and `name2` are the names of the keys at each level,\n    // used when reconstructing the resulting quad\n    // (for instance: _subject_, _predicate_, and _object_).\n    // Finally, `graph` will be the graph of the created quads.\n    // If `callback` is given, each result is passed through it\n    // and iteration halts when it returns truthy for any quad.\n    // If instead `array` is given, each result is added to the array.\n\n  }, {\n    key: \"_findInIndex\",\n    value: function _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n      var tmp,\n          index1,\n          index2,\n          varCount = !key0 + !key1 + !key2,\n          // depending on the number of variables, keys or reverse index are faster\n      entityKeys = varCount > 1 ? Object.keys(this._ids) : this._entities; // If a key is specified, use only that part of index 0.\n\n      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n      for (var value0 in index0) {\n        var entity0 = entityKeys[value0];\n\n        if (index1 = index0[value0]) {\n          // If a key is specified, use only that part of index 1.\n          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n          for (var value1 in index1) {\n            var entity1 = entityKeys[value1];\n\n            if (index2 = index1[value1]) {\n              // If a key is specified, use only that part of index 2, if it exists.\n              var values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create quads for all items found in index 2.\n\n              for (var l = 0; l < values.length; l++) {\n                var parts = {\n                  subject: null,\n                  predicate: null,\n                  object: null\n                };\n                parts[name0] = fromId(entity0, this._factory);\n                parts[name1] = fromId(entity1, this._factory);\n                parts[name2] = fromId(entityKeys[values[l]], this._factory);\n\n                var quad = this._factory.quad(parts.subject, parts.predicate, parts.object, fromId(graph, this._factory));\n\n                if (array) array.push(quad);else if (callback(quad)) return true;\n              }\n            }\n          }\n        }\n      }\n\n      return array;\n    } // ### `_loop` executes the callback on all keys of index 0\n\n  }, {\n    key: \"_loop\",\n    value: function _loop(index0, callback) {\n      for (var key0 in index0) {\n        callback(key0);\n      }\n    } // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n\n  }, {\n    key: \"_loopByKey0\",\n    value: function _loopByKey0(index0, key0, callback) {\n      var index1, key1;\n\n      if (index1 = index0[key0]) {\n        for (key1 in index1) {\n          callback(key1);\n        }\n      }\n    } // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n\n  }, {\n    key: \"_loopByKey1\",\n    value: function _loopByKey1(index0, key1, callback) {\n      var key0, index1;\n\n      for (key0 in index0) {\n        index1 = index0[key0];\n        if (index1[key1]) callback(key0);\n      }\n    } // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n\n  }, {\n    key: \"_loopBy2Keys\",\n    value: function _loopBy2Keys(index0, key0, key1, callback) {\n      var index1, index2, key2;\n\n      if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n        for (key2 in index2) {\n          callback(key2);\n        }\n      }\n    } // ### `_countInIndex` counts matching quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n\n  }, {\n    key: \"_countInIndex\",\n    value: function _countInIndex(index0, key0, key1, key2) {\n      var count = 0,\n          tmp,\n          index1,\n          index2; // If a key is specified, count only that part of index 0\n\n      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n      for (var value0 in index0) {\n        if (index1 = index0[value0]) {\n          // If a key is specified, count only that part of index 1\n          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n          for (var value1 in index1) {\n            if (index2 = index1[value1]) {\n              // If a key is specified, count the quad if it exists\n              if (key2) key2 in index2 && count++; // Otherwise, count all quads\n              else count += Object.keys(index2).length;\n            }\n          }\n        }\n      }\n\n      return count;\n    } // ### `_getGraphs` returns an array with the given graph,\n    // or all graphs if the argument is null or undefined.\n\n  }, {\n    key: \"_getGraphs\",\n    value: function _getGraphs(graph) {\n      if (!isString(graph)) return this._graphs;\n      var graphs = {};\n      graphs[graph] = this._graphs[graph];\n      return graphs;\n    } // ### `_uniqueEntities` returns a function that accepts an entity ID\n    // and passes the corresponding entity to callback if it hasn't occurred before.\n\n  }, {\n    key: \"_uniqueEntities\",\n    value: function _uniqueEntities(callback) {\n      var uniqueIds = Object.create(null),\n          entities = this._entities;\n      return function (id) {\n        if (!(id in uniqueIds)) {\n          uniqueIds[id] = true;\n          callback(fromId(entities[id]));\n        }\n      };\n    } // ## Public methods\n    // ### `addQuad` adds a new quad to the store.\n    // Returns if the quad index has changed, if the quad did not already exist.\n\n  }, {\n    key: \"addQuad\",\n    value: function addQuad(subject, predicate, object, graph) {\n      // Shift arguments if a quad object is given instead of components\n      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation\n\n      subject = toId(subject);\n      predicate = toId(predicate);\n      object = toId(object);\n      graph = toId(graph); // Find the graph that will contain the triple\n\n      var graphItem = this._graphs[graph]; // Create the graph if it doesn't exist yet\n\n      if (!graphItem) {\n        graphItem = this._graphs[graph] = {\n          subjects: {},\n          predicates: {},\n          objects: {}\n        }; // Freezing a graph helps subsequent `add` performance,\n        // and properties will never be modified anyway\n\n        Object.freeze(graphItem);\n      } // Since entities can often be long IRIs, we avoid storing them in every index.\n      // Instead, we have a separate index that maps entities to numbers,\n      // which are then used as keys in the other indexes.\n\n\n      var ids = this._ids;\n      var entities = this._entities;\n      subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n      predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n      object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n\n      var changed = this._addToIndex(graphItem.subjects, subject, predicate, object);\n\n      this._addToIndex(graphItem.predicates, predicate, object, subject);\n\n      this._addToIndex(graphItem.objects, object, subject, predicate); // The cached quad count is now invalid\n\n\n      this._size = null;\n      return changed;\n    } // ### `addQuads` adds multiple quads to the store\n\n  }, {\n    key: \"addQuads\",\n    value: function addQuads(quads) {\n      for (var i = 0; i < quads.length; i++) {\n        this.addQuad(quads[i]);\n      }\n    } // ### `import` adds a stream of quads to the store\n\n  }, {\n    key: \"import\",\n    value: function _import(stream) {\n      var self = this;\n      stream.on('data', function (quad) {\n        self.addQuad(quad);\n      });\n      return stream;\n    } // ### `removeQuad` removes a quad from the store if it exists\n\n  }, {\n    key: \"removeQuad\",\n    value: function removeQuad(subject, predicate, object, graph) {\n      // Shift arguments if a quad object is given instead of components\n      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation\n\n      subject = toId(subject);\n      predicate = toId(predicate);\n      object = toId(object);\n      graph = toId(graph); // Find internal identifiers for all components\n      // and verify the quad exists.\n\n      var graphItem,\n          ids = this._ids,\n          graphs = this._graphs,\n          subjects,\n          predicates;\n      if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false; // Remove it from all indexes\n\n      this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n\n      this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n\n      this._removeFromIndex(graphItem.objects, object, subject, predicate);\n\n      if (this._size !== null) this._size--; // Remove the graph if it is empty\n\n      for (subject in graphItem.subjects) {\n        return true;\n      }\n\n      delete graphs[graph];\n      return true;\n    } // ### `removeQuads` removes multiple quads from the store\n\n  }, {\n    key: \"removeQuads\",\n    value: function removeQuads(quads) {\n      for (var i = 0; i < quads.length; i++) {\n        this.removeQuad(quads[i]);\n      }\n    } // ### `remove` removes a stream of quads from the store\n\n  }, {\n    key: \"remove\",\n    value: function remove(stream) {\n      var self = this;\n      stream.on('data', function (quad) {\n        self.removeQuad(quad);\n      });\n      return stream;\n    } // ### `removeMatches` removes all matching quads from the store\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"removeMatches\",\n    value: function removeMatches(subject, predicate, object, graph) {\n      return this.remove(this.match(subject, predicate, object, graph));\n    } // ### `deleteGraph` removes all triples with the given graph from the store\n\n  }, {\n    key: \"deleteGraph\",\n    value: function deleteGraph(graph) {\n      return this.removeMatches(null, null, null, graph);\n    } // ### `getQuads` returns an array of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getQuads\",\n    value: function getQuads(subject, predicate, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      predicate = predicate && toId(predicate);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var quads = [],\n          graphs = this._getGraphs(graph),\n          content,\n          ids = this._ids,\n          subjectId,\n          predicateId,\n          objectId; // Translate IRIs to internal index keys.\n\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return quads;\n\n      for (var graphId in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n          // Choose the optimal index, based on what fields are present\n          if (subjectId) {\n            if (objectId) // If subject and object are given, the object index will be the fastest\n              this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads);else // If only subject and possibly predicate are given, the subject index will be the fastest\n              this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads);\n          } else if (predicateId) // If only predicate and possibly object are given, the predicate index will be the fastest\n            this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads);else if (objectId) // If only object is given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads);else // If nothing is given, iterate subjects and predicates first\n            this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads);\n        }\n      }\n\n      return quads;\n    } // ### `match` returns a stream of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"match\",\n    value: function match(subject, predicate, object, graph) {\n      var self = this;\n      var stream = new Readable({\n        objectMode: true\n      }); // Initialize stream once it is being read\n\n      stream._read = function () {\n        stream._read = function () {};\n\n        var quads = self.getQuads(subject, predicate, object, graph);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = quads[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var quad = _step.value;\n            stream.push(quad);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        stream.push(null);\n      };\n\n      return stream;\n    } // ### `countQuads` returns the number of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"countQuads\",\n    value: function countQuads(subject, predicate, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      predicate = predicate && toId(predicate);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var count = 0,\n          graphs = this._getGraphs(graph),\n          content,\n          ids = this._ids,\n          subjectId,\n          predicateId,\n          objectId; // Translate IRIs to internal index keys.\n\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return 0;\n\n      for (var graphId in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n          // Choose the optimal index, based on what fields are present\n          if (subject) {\n            if (object) // If subject and object are given, the object index will be the fastest\n              count += this._countInIndex(content.objects, objectId, subjectId, predicateId);else // If only subject and possibly predicate are given, the subject index will be the fastest\n              count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n          } else if (predicate) {\n            // If only predicate and possibly object are given, the predicate index will be the fastest\n            count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n          } else {\n            // If only object is possibly given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n          }\n        }\n      }\n\n      return count;\n    } // ### `forEach` executes the callback on all quads.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, subject, predicate, object, graph) {\n      this.some(function (quad) {\n        callback(quad);\n        return false;\n      }, subject, predicate, object, graph);\n    } // ### `every` executes the callback on all quads,\n    // and returns `true` if it returns truthy for all them.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"every\",\n    value: function every(callback, subject, predicate, object, graph) {\n      var some = false;\n      var every = !this.some(function (quad) {\n        some = true;\n        return !callback(quad);\n      }, subject, predicate, object, graph);\n      return some && every;\n    } // ### `some` executes the callback on all quads,\n    // and returns `true` if it returns truthy for any of them.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"some\",\n    value: function some(callback, subject, predicate, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      predicate = predicate && toId(predicate);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var graphs = this._getGraphs(graph),\n          content,\n          ids = this._ids,\n          subjectId,\n          predicateId,\n          objectId; // Translate IRIs to internal index keys.\n\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return false;\n\n      for (var graphId in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n          // Choose the optimal index, based on what fields are present\n          if (subjectId) {\n            if (objectId) {\n              // If subject and object are given, the object index will be the fastest\n              if (this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, callback, null)) return true;\n            } else // If only subject and possibly predicate are given, the subject index will be the fastest\n              if (this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, callback, null)) return true;\n          } else if (predicateId) {\n            // If only predicate and possibly object are given, the predicate index will be the fastest\n            if (this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, callback, null)) {\n              return true;\n            }\n          } else if (objectId) {\n            // If only object is given, the object index will be the fastest\n            if (this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, callback, null)) {\n              return true;\n            }\n          } else // If nothing is given, iterate subjects and predicates first\n            if (this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, callback, null)) {\n              return true;\n            }\n        }\n      }\n\n      return false;\n    } // ### `getSubjects` returns all subjects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getSubjects\",\n    value: function getSubjects(predicate, object, graph) {\n      var results = [];\n      this.forSubjects(function (s) {\n        results.push(s);\n      }, predicate, object, graph);\n      return results;\n    } // ### `forSubjects` executes the callback on all subjects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forSubjects\",\n    value: function forSubjects(callback, predicate, object, graph) {\n      // Convert terms to internal string representation\n      predicate = predicate && toId(predicate);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var ids = this._ids,\n          graphs = this._getGraphs(graph),\n          content,\n          predicateId,\n          objectId;\n\n      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n      if (isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;\n\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (predicateId) {\n            if (objectId) // If predicate and object are given, the POS index is best.\n              this._loopBy2Keys(content.predicates, predicateId, objectId, callback);else // If only predicate is given, the SPO index is best.\n              this._loopByKey1(content.subjects, predicateId, callback);\n          } else if (objectId) // If only object is given, the OSP index is best.\n            this._loopByKey0(content.objects, objectId, callback);else // If no params given, iterate all the subjects\n            this._loop(content.subjects, callback);\n        }\n      }\n    } // ### `getPredicates` returns all predicates that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getPredicates\",\n    value: function getPredicates(subject, object, graph) {\n      var results = [];\n      this.forPredicates(function (p) {\n        results.push(p);\n      }, subject, object, graph);\n      return results;\n    } // ### `forPredicates` executes the callback on all predicates that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forPredicates\",\n    value: function forPredicates(callback, subject, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var ids = this._ids,\n          graphs = this._getGraphs(graph),\n          content,\n          subjectId,\n          objectId;\n\n      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(object) && !(objectId = ids[object])) return;\n\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (subjectId) {\n            if (objectId) // If subject and object are given, the OSP index is best.\n              this._loopBy2Keys(content.objects, objectId, subjectId, callback);else // If only subject is given, the SPO index is best.\n              this._loopByKey0(content.subjects, subjectId, callback);\n          } else if (objectId) // If only object is given, the POS index is best.\n            this._loopByKey1(content.predicates, objectId, callback);else // If no params given, iterate all the predicates.\n            this._loop(content.predicates, callback);\n        }\n      }\n    } // ### `getObjects` returns all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getObjects\",\n    value: function getObjects(subject, predicate, graph) {\n      var results = [];\n      this.forObjects(function (o) {\n        results.push(o);\n      }, subject, predicate, graph);\n      return results;\n    } // ### `forObjects` executes the callback on all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forObjects\",\n    value: function forObjects(callback, subject, predicate, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      predicate = predicate && toId(predicate);\n      graph = graph && toId(graph);\n\n      var ids = this._ids,\n          graphs = this._getGraphs(graph),\n          content,\n          subjectId,\n          predicateId;\n\n      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate])) return;\n\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (subjectId) {\n            if (predicateId) // If subject and predicate are given, the SPO index is best.\n              this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);else // If only subject is given, the OSP index is best.\n              this._loopByKey1(content.objects, subjectId, callback);\n          } else if (predicateId) // If only predicate is given, the POS index is best.\n            this._loopByKey0(content.predicates, predicateId, callback);else // If no params given, iterate all the objects.\n            this._loop(content.objects, callback);\n        }\n      }\n    } // ### `getGraphs` returns all graphs that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getGraphs\",\n    value: function getGraphs(subject, predicate, object) {\n      var results = [];\n      this.forGraphs(function (g) {\n        results.push(g);\n      }, subject, predicate, object);\n      return results;\n    } // ### `forGraphs` executes the callback on all graphs that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forGraphs\",\n    value: function forGraphs(callback, subject, predicate, object) {\n      for (var graph in this._graphs) {\n        this.some(function (quad) {\n          callback(quad.graph);\n          return true; // Halt iteration of some()\n        }, subject, predicate, object, graph);\n      }\n    } // ### `createBlankNode` creates a new blank node, returning its name\n\n  }, {\n    key: \"createBlankNode\",\n    value: function createBlankNode(suggestedName) {\n      var name, index; // Generate a name based on the suggested name\n\n      if (suggestedName) {\n        name = suggestedName = '_:' + suggestedName, index = 1;\n\n        while (this._ids[name]) {\n          name = suggestedName + index++;\n        }\n      } // Generate a generic blank node name\n      else {\n          do {\n            name = '_:b' + this._blankNodeIndex++;\n          } while (this._ids[name]);\n        } // Add the blank node to the entities, avoiding the generation of duplicates\n\n\n      this._ids[name] = ++this._id;\n      this._entities[this._id] = name;\n      return this._factory.blankNode(name.substr(2));\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      // Return the quad count if if was cached\n      var size = this._size;\n      if (size !== null) return size; // Calculate the number of quads by counting to the deepest level\n\n      size = 0;\n      var graphs = this._graphs,\n          subjects,\n          subject;\n\n      for (var graphKey in graphs) {\n        for (var subjectKey in subjects = graphs[graphKey].subjects) {\n          for (var predicateKey in subject = subjects[subjectKey]) {\n            size += Object.keys(subject[predicateKey]).length;\n          }\n        }\n      }\n\n      return this._size = size;\n    }\n  }]);\n\n  return N3Store;\n}(); // Determines whether the argument is a string\n\n\nexport { N3Store as default };\n\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}","map":null,"metadata":{},"sourceType":"module"}