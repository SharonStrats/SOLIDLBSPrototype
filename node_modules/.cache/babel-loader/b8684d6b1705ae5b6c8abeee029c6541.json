{"ast":null,"code":"import _assertThisInitialized from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\nimport namespaces from './IRIs';\nvar rdf = namespaces.rdf,\n    xsd = namespaces.xsd;\nvar DataFactory, DEFAULTGRAPH;\nvar _blankNodeCounter = 0; // ## Term constructor\n\nvar Term =\n/*#__PURE__*/\nfunction () {\n  function Term(id) {\n    _classCallCheck(this, Term);\n\n    this.id = id;\n  } // ### The value of this term\n\n\n  _createClass(Term, [{\n    key: \"equals\",\n    // ### Returns whether this object represents the same term as the other\n    value: function equals(other) {\n      // If both terms were created by this library,\n      // equality can be computed through ids\n      if (other instanceof Term) return this.id === other.id; // Otherwise, compare term type and value\n\n      return !!other && this.termType === other.termType && this.value === other.value;\n    } // ### Returns a plain object representation of this term\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        termType: this.termType,\n        value: this.value\n      };\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id;\n    }\n  }]);\n\n  return Term;\n}(); // ## NamedNode constructor\n\n\nvar NamedNode =\n/*#__PURE__*/\nfunction (_Term) {\n  _inherits(NamedNode, _Term);\n\n  function NamedNode() {\n    _classCallCheck(this, NamedNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NamedNode).apply(this, arguments));\n  }\n\n  _createClass(NamedNode, [{\n    key: \"termType\",\n    // ### The term type of this term\n    get: function get() {\n      return 'NamedNode';\n    }\n  }]);\n\n  return NamedNode;\n}(Term); // ## Literal constructor\n\n\nvar Literal =\n/*#__PURE__*/\nfunction (_Term2) {\n  _inherits(Literal, _Term2);\n\n  function Literal() {\n    _classCallCheck(this, Literal);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Literal).apply(this, arguments));\n  }\n\n  _createClass(Literal, [{\n    key: \"equals\",\n    // ### Returns whether this object represents the same term as the other\n    value: function equals(other) {\n      // If both literals were created by this library,\n      // equality can be computed through ids\n      if (other instanceof Literal) return this.id === other.id; // Otherwise, compare term type, value, language, and datatype\n\n      return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        termType: this.termType,\n        value: this.value,\n        language: this.language,\n        datatype: {\n          termType: 'NamedNode',\n          value: this.datatypeString\n        }\n      };\n    }\n  }, {\n    key: \"termType\",\n    // ### The term type of this term\n    get: function get() {\n      return 'Literal';\n    } // ### The text value of this literal\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substring(1, this.id.lastIndexOf('\"'));\n    } // ### The language of this literal\n\n  }, {\n    key: \"language\",\n    get: function get() {\n      // Find the last quotation mark (e.g., '\"abc\"@en-us')\n      var id = this.id,\n          atPos = id.lastIndexOf('\"') + 1; // If \"@\" it follows, return the remaining substring; empty otherwise\n\n      return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n    } // ### The datatype IRI of this literal\n\n  }, {\n    key: \"datatype\",\n    get: function get() {\n      return new NamedNode(this.datatypeString);\n    } // ### The datatype string of this literal\n\n  }, {\n    key: \"datatypeString\",\n    get: function get() {\n      // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n      var id = this.id,\n          dtPos = id.lastIndexOf('\"') + 1,\n          ch; // If \"^\" it follows, return the remaining substring\n\n      return dtPos < id.length && (ch = id[dtPos]) === '^' ? id.substr(dtPos + 2) : // If \"@\" follows, return rdf:langString; xsd:string otherwise\n      ch !== '@' ? xsd.string : rdf.langString;\n    }\n  }]);\n\n  return Literal;\n}(Term); // ## BlankNode constructor\n\n\nvar BlankNode =\n/*#__PURE__*/\nfunction (_Term3) {\n  _inherits(BlankNode, _Term3);\n\n  function BlankNode(name) {\n    _classCallCheck(this, BlankNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BlankNode).call(this, '_:' + name));\n  } // ### The term type of this term\n\n\n  _createClass(BlankNode, [{\n    key: \"termType\",\n    get: function get() {\n      return 'BlankNode';\n    } // ### The name of this blank node\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substr(2);\n    }\n  }]);\n\n  return BlankNode;\n}(Term);\n\nvar Variable =\n/*#__PURE__*/\nfunction (_Term4) {\n  _inherits(Variable, _Term4);\n\n  function Variable(name) {\n    _classCallCheck(this, Variable);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Variable).call(this, '?' + name));\n  } // ### The term type of this term\n\n\n  _createClass(Variable, [{\n    key: \"termType\",\n    get: function get() {\n      return 'Variable';\n    } // ### The name of this variable\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substr(1);\n    }\n  }]);\n\n  return Variable;\n}(Term); // ## DefaultGraph constructor\n\n\nvar DefaultGraph =\n/*#__PURE__*/\nfunction (_Term5) {\n  _inherits(DefaultGraph, _Term5);\n\n  function DefaultGraph() {\n    var _this;\n\n    _classCallCheck(this, DefaultGraph);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultGraph).call(this, ''));\n    return _possibleConstructorReturn(_this, DEFAULTGRAPH || _assertThisInitialized(_assertThisInitialized(_this)));\n  } // ### The term type of this term\n\n\n  _createClass(DefaultGraph, [{\n    key: \"equals\",\n    // ### Returns whether this object represents the same term as the other\n    value: function equals(other) {\n      // If both terms were created by this library,\n      // equality can be computed through strict equality;\n      // otherwise, compare term types.\n      return this === other || !!other && this.termType === other.termType;\n    }\n  }, {\n    key: \"termType\",\n    get: function get() {\n      return 'DefaultGraph';\n    }\n  }]);\n\n  return DefaultGraph;\n}(Term); // ## DefaultGraph singleton\n\n\nDEFAULTGRAPH = new DefaultGraph(); // ### Constructs a term from the given internal string ID\n\nfunction fromId(id, factory) {\n  factory = factory || DataFactory; // Falsy value or empty string indicate the default graph\n\n  if (!id) return factory.defaultGraph(); // Identify the term type based on the first character\n\n  switch (id[0]) {\n    case '_':\n      return factory.blankNode(id.substr(2));\n\n    case '?':\n      return factory.variable(id.substr(1));\n\n    case '\"':\n      // Shortcut for internal literals\n      if (factory === DataFactory) return new Literal(id); // Literal without datatype or language\n\n      if (id[id.length - 1] === '\"') return factory.literal(id.substr(1, id.length - 2)); // Literal with datatype or language\n\n      var endPos = id.lastIndexOf('\"', id.length - 1);\n      return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === '@' ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));\n\n    default:\n      return factory.namedNode(id);\n  }\n} // ### Constructs an internal string ID from the given term or ID string\n\n\nfunction toId(term) {\n  if (typeof term === 'string') return term;\n  if (term instanceof Term) return term.id;\n  if (!term) return DEFAULTGRAPH.id; // Term instantiated with another library\n\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value;\n\n    case 'BlankNode':\n      return '_:' + term.value;\n\n    case 'Variable':\n      return '?' + term.value;\n\n    case 'DefaultGraph':\n      return '';\n\n    case 'Literal':\n      return '\"' + term.value + '\"' + (term.language ? '@' + term.language : term.datatype && term.datatype.value !== xsd.string ? '^^' + term.datatype.value : '');\n\n    default:\n      throw new Error('Unexpected termType: ' + term.termType);\n  }\n} // ## Quad constructor\n\n\nvar Quad =\n/*#__PURE__*/\nfunction () {\n  function Quad(subject, predicate, object, graph) {\n    _classCallCheck(this, Quad);\n\n    this.subject = subject;\n    this.predicate = predicate;\n    this.object = object;\n    this.graph = graph || DEFAULTGRAPH;\n  } // ### Returns a plain object representation of this quad\n\n\n  _createClass(Quad, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        subject: this.subject.toJSON(),\n        predicate: this.predicate.toJSON(),\n        object: this.object.toJSON(),\n        graph: this.graph.toJSON()\n      };\n    } // ### Returns whether this object represents the same quad as the other\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return !!other && this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph);\n    }\n  }]);\n\n  return Quad;\n}(); // ## DataFactory singleton\n\n\nDataFactory = {\n  // ### Public factory functions\n  namedNode: namedNode,\n  blankNode: blankNode,\n  variable: variable,\n  literal: literal,\n  defaultGraph: defaultGraph,\n  quad: quad,\n  triple: quad,\n  // ### Internal datatype constructors\n  internal: {\n    Term: Term,\n    NamedNode: NamedNode,\n    BlankNode: BlankNode,\n    Variable: Variable,\n    Literal: Literal,\n    DefaultGraph: DefaultGraph,\n    Quad: Quad,\n    Triple: Quad,\n    fromId: fromId,\n    toId: toId\n  }\n};\nexport default DataFactory; // ### Creates an IRI\n\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n} // ### Creates a blank node\n\n\nfunction blankNode(name) {\n  if (!name) name = 'n3-' + _blankNodeCounter++;\n  return new BlankNode(name);\n} // ### Creates a literal\n\n\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string') return new Literal('\"' + value + '\"@' + languageOrDataType.toLowerCase()); // Create a datatyped literal\n\n  var datatype = languageOrDataType && languageOrDataType.value || '';\n\n  if (!datatype) {\n    switch (typeof value) {\n      // Convert a boolean\n      case 'boolean':\n        datatype = xsd.boolean;\n        break;\n      // Convert an integer or double\n\n      case 'number':\n        if (Number.isFinite(value)) datatype = Number.isInteger(value) ? xsd.integer : xsd.double;else {\n          datatype = xsd.double;\n          if (!Number.isNaN(value)) value = value > 0 ? 'INF' : '-INF';\n        }\n        break;\n      // No datatype, so convert a plain string\n\n      default:\n        return new Literal('\"' + value + '\"');\n    }\n  }\n\n  return new Literal('\"' + value + '\"^^' + datatype);\n} // ### Creates a variable\n\n\nfunction variable(name) {\n  return new Variable(name);\n} // ### Returns the default graph\n\n\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n} // ### Creates a quad\n\n\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}","map":null,"metadata":{},"sourceType":"module"}