{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/* \n   constructor should define the pacakage's name \n   by default this will be added to the x-powered-by header of all responses\n*/\nvar SolidLocalStorage =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function SolidLocalStorage() {\n    _classCallCheck(this, SolidLocalStorage);\n\n    this.prefix = \"ls\";\n    this.name = \"solid-rest-localStorage-1.0.0\";\n    localStorage.setItem(\"/\", \" \");\n  }\n  /*\n     getObjectType(pathname,options)\n       * trys to find pathname in storage\n       * if found, sets exists to true\n       * sets type to \"Container\" or \"Resource\" or undefined\n       * returns an array [type,exists]\n  */\n\n\n  _createClass(SolidLocalStorage, [{\n    key: \"getObjectType\",\n    value: function () {\n      var _getObjectType = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(pathname, options) {\n        var type, exists, keys, k, item;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                type = pathname.match(/\\/$/) ? \"Container\" : \"Resource\";\n                pathname = pathname.replace(/\\/$/, ''); // REMOVE TRAILING SLASH\n\n                exists = false;\n                keys = Object.keys(localStorage);\n                _context.t0 = _regeneratorRuntime.keys(keys);\n\n              case 5:\n                if ((_context.t1 = _context.t0()).done) {\n                  _context.next = 16;\n                  break;\n                }\n\n                k = _context.t1.value;\n                item = keys[k];\n\n                if (!(type === \"Container\" && item.startsWith(pathname))) {\n                  _context.next = 11;\n                  break;\n                }\n\n                exists = true;\n                return _context.abrupt(\"break\", 16);\n\n              case 11:\n                if (!(item === pathname)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                exists = true;\n                return _context.abrupt(\"break\", 16);\n\n              case 14:\n                _context.next = 5;\n                break;\n\n              case 16:\n                return _context.abrupt(\"return\", [type, exists]);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function getObjectType(_x, _x2) {\n        return _getObjectType.apply(this, arguments);\n      }\n\n      return getObjectType;\n    }()\n    /*\n      getResource(pathname,options)\n        * gets a resource\n        * on success, returns [ 200, resourceContents, optionalHeader ]\n        * on failure, returns [ 500, undefined, optionalHeader ]\n    */\n\n  }, {\n    key: \"getResource\",\n    value: function () {\n      var _getResource = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(pathname, options) {\n        var body;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                body = localStorage.getItem(pathname);\n                return _context2.abrupt(\"return\", Promise.resolve([200, body]));\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](0);\n                Promise.resolve([500]);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 5]]);\n      }));\n\n      function getResource(_x3, _x4) {\n        return _getResource.apply(this, arguments);\n      }\n\n      return getResource;\n    }()\n    /*\n      getContainer(pathname,options)\n        * returns an array of the container's contained resource names\n        * OR returns a turtle representation of the container and contents\n    */\n\n  }, {\n    key: \"getContainer\",\n    value: function () {\n      var _getContainer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(pathname, options) {\n        var files;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                files = Object.keys(localStorage).filter(function (path) {\n                  return path.startsWith(pathname) && path != pathname;\n                }) // Only children\n                .map(function (path) {\n                  return path.substr(pathname.length);\n                }).filter(function (path) {\n                  return !path.slice(0, -1).includes(\"/\");\n                }); // Only include direct children\n\n                return _context3.abrupt(\"return\", files);\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function getContainer(_x5, _x6) {\n        return _getContainer.apply(this, arguments);\n      }\n\n      return getContainer;\n    }()\n  }, {\n    key: \"dump\",\n    value: function dump(pathname, options) {\n      var keys = Object.keys(localStorage).filter(function (k) {\n        if (!k.match(/(setItem|getItem|removeItem)/)) return k;\n      }).map(function (m) {\n        console.log(m, localStorage.getItem(m));\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      var keys = Object.keys(localStorage).filter(function (k) {\n        if (!k.match(/(setItem|getItem|removeItem)/)) return k;\n      }).map(function (item) {\n        _this.deleteResource(item);\n      });\n    }\n    /*\n       putResource(pathname,options)\n         * creates a single Resource\n         * on success : status = 201\n         * on error : status = 500\n         * returns [status,undefined,optionalHeader]\n    */\n\n  }, {\n    key: \"putResource\",\n    value: function () {\n      var _putResource = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(pathname, options) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = options || {};\n                options.body = options.body || \"\";\n                _context4.prev = 2;\n                localStorage.setItem(pathname, options.body);\n                return _context4.abrupt(\"return\", Promise.resolve([201]));\n\n              case 7:\n                _context4.prev = 7;\n                _context4.t0 = _context4[\"catch\"](2);\n                console.log(_context4.t0);\n                return _context4.abrupt(\"return\", Promise.resolve([500]));\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[2, 7]]);\n      }));\n\n      function putResource(_x7, _x8) {\n        return _putResource.apply(this, arguments);\n      }\n\n      return putResource;\n    }()\n    /*\n       postContainer(pathname,options)\n          * creates a single Container\n          * on success : status = 201\n          * on error : status = 500\n          * returns [status,undefined,optionalHeader]\n    */\n\n  }, {\n    key: \"postContainer\",\n    value: function () {\n      var _postContainer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(pathname, options) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                pathname = pathname + '/'; // because wasn't on slug\n\n                return _context5.abrupt(\"return\", this.putResource(pathname, options));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function postContainer(_x9, _x10) {\n        return _postContainer.apply(this, arguments);\n      }\n\n      return postContainer;\n    }()\n    /*\n      deleteResource(pathname,options)\n        * deletes a resource\n        * on success, returns [200,undefined,optionalHeader]\n        * on failure, returns [500,undefined,optionalHeader]\n    */\n\n  }, {\n    key: \"deleteResource\",\n    value: function () {\n      var _deleteResource = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(pathname, options) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                localStorage.removeItem(pathname);\n                return _context6.abrupt(\"return\", Promise.resolve([200]));\n\n              case 5:\n                _context6.prev = 5;\n                _context6.t0 = _context6[\"catch\"](0);\n                return _context6.abrupt(\"return\", Promise.resolve([500]));\n\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[0, 5]]);\n      }));\n\n      function deleteResource(_x11, _x12) {\n        return _deleteResource.apply(this, arguments);\n      }\n\n      return deleteResource;\n    }()\n    /*\n      deleteContainer(pathname,options)\n        * if container is not empty, returns [409,undefined,optionalHeader]\n        * else deletes container\n        * on success, returns [200,undefined,optionalHeader]\n        * on failure, returns [500,undefined,optionalHeader]\n    */\n\n  }, {\n    key: \"deleteContainer\",\n    value: function () {\n      var _deleteContainer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(pathname, options) {\n        var files;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.getContainer(pathname, options);\n\n              case 2:\n                files = _context7.sent;\n\n                if (!files.length) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", Promise.resolve([409]));\n\n              case 5:\n                _context7.next = 7;\n                return this.deleteResource(pathname, options);\n\n              case 7:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function deleteContainer(_x13, _x14) {\n        return _deleteContainer.apply(this, arguments);\n      }\n\n      return deleteContainer;\n    }()\n    /*\n      makeContainers(pathname,options)\n        * if path's parent containers exist, return[200,undefined,optionalHeader]\n        * else, recursively create parent containers\n        * on success, return [201,undefined,optionalHeader]\n        * on failure, return [500,undefined,optionalHeader]\n    */\n\n  }, {\n    key: \"makeContainers\",\n    value: function () {\n      var _makeContainers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(pathname, options) {\n        var _ref, _ref2, t, exists;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.getObjectType(pathname);\n\n              case 2:\n                _ref = _context8.sent;\n                _ref2 = _slicedToArray(_ref, 2);\n                t = _ref2[0];\n                exists = _ref2[1];\n\n                if (!exists) {\n                  _context8.next = 8;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", Promise.resolve([201]));\n\n              case 8:\n                return _context8.abrupt(\"return\", Promise.resolve([201]));\n\n              case 9:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function makeContainers(_x15, _x16) {\n        return _makeContainers.apply(this, arguments);\n      }\n\n      return makeContainers;\n    }()\n  }]);\n\n  return SolidLocalStorage;\n}();\n/* \n  OPTIONAL METHODS\n\n  see solid-rest.js code for examples of the defaults\n  optionally provide your own to replace or augment the behavior\n\n   text(stream)\n     * response method to pipe text body\n     * receives response body, returns piped string\n   json(string)\n     * response method to parse json body\n     * receives response body returns a json object\n   container2turtle(pathname,options,contentsArray)\n     * iterates over container's contents, creates a turtle representation\n     * returns [200, turtleContents, optionalHeader]\n   getHeaders(pathname,options)\n     * returns header fields to replace or augment default headers\n*/\n\n/*\n  if it should work in nodejs, export the object\n*/\n\n\nif (typeof window === \"undefined\") {\n  alert = function alert(msg) {\n    return console.log(msg);\n  };\n\n  localStorage = {\n    getItem: function getItem(key) {\n      return localStorage[key];\n    },\n    removeItem: function removeItem(key) {\n      delete localStorage[key];\n    },\n    setItem: function setItem(key, val) {\n      localStorage[key] = val;\n    }\n  };\n  module.exports = SolidLocalStorage;\n}","map":null,"metadata":{},"sourceType":"script"}