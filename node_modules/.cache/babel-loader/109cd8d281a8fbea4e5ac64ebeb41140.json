{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport ClassOrder from './class-order';\nimport NamedNode from './named-node';\nimport Node from './node-internal';\nimport XSD from './xsd';\n\nvar Literal =\n/*#__PURE__*/\nfunction (_Node) {\n  _inherits(Literal, _Node);\n\n  function Literal(value, language, datatype) {\n    var _this;\n\n    _classCallCheck(this, Literal);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Literal).call(this));\n    _this.termType = Literal.termType;\n    _this.value = value;\n\n    if (language) {\n      _this.lang = language;\n      datatype = XSD.langString;\n    } // If not specified, a literal has the implied XSD.string default datatype\n\n\n    if (datatype) {\n      _this.datatype = NamedNode.fromValue(datatype);\n    }\n\n    return _this;\n  }\n\n  _createClass(Literal, [{\n    key: \"copy\",\n    value: function copy() {\n      return new Literal(this.value, this.lang, this.datatype);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!other) {\n        return false;\n      }\n\n      return this.termType === other.termType && this.value === other.value && this.language === other.language && (!this.datatype && !other.datatype || this.datatype && this.datatype.equals(other.datatype));\n    }\n  }, {\n    key: \"toNT\",\n    value: function toNT() {\n      if (typeof this.value === 'number') {\n        return this.toString();\n      } else if (typeof this.value !== 'string') {\n        throw new Error('Value of RDF literal is not string or number: ' + this.value);\n      }\n\n      var str = this.value;\n      str = str.replace(/\\\\/g, '\\\\\\\\');\n      str = str.replace(/\\\"/g, '\\\\\"');\n      str = str.replace(/\\n/g, '\\\\n');\n      str = '\"' + str + '\"';\n\n      if (this.language) {\n        str += '@' + this.language;\n      } else if (!this.datatype.equals(XSD.string)) {\n        // Only add datatype if it's not a string\n        str += '^^' + this.datatype.toCanonical();\n      }\n\n      return str;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '' + this.value;\n    }\n    /**\n     * @method fromBoolean\n     * @static\n     * @param value {Boolean}\n     * @return {Literal}\n     */\n\n  }, {\n    key: \"language\",\n    get: function get() {\n      return this.lang;\n    },\n    set: function set(language) {\n      this.lang = language || '';\n    }\n  }], [{\n    key: \"fromBoolean\",\n    value: function fromBoolean(value) {\n      var strValue = value ? '1' : '0';\n      return new Literal(strValue, null, XSD.boolean);\n    }\n    /**\n     * @method fromDate\n     * @static\n     * @param value {Date}\n     * @return {Literal}\n     */\n\n  }, {\n    key: \"fromDate\",\n    value: function fromDate(value) {\n      if (!(value instanceof Date)) {\n        throw new TypeError('Invalid argument to Literal.fromDate()');\n      }\n\n      var d2 = function d2(x) {\n        return ('' + (100 + x)).slice(1, 3);\n      };\n\n      var date = '' + value.getUTCFullYear() + '-' + d2(value.getUTCMonth() + 1) + '-' + d2(value.getUTCDate()) + 'T' + d2(value.getUTCHours()) + ':' + d2(value.getUTCMinutes()) + ':' + d2(value.getUTCSeconds()) + 'Z';\n      return new Literal(date, null, XSD.dateTime);\n    }\n    /**\n     * @method fromNumber\n     * @static\n     * @param value {Number}\n     * @return {Literal}\n     */\n\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(value) {\n      if (typeof value !== 'number') {\n        throw new TypeError('Invalid argument to Literal.fromNumber()');\n      }\n\n      var datatype;\n      var strValue = value.toString();\n\n      if (strValue.indexOf('e') < 0 && Math.abs(value) <= Number.MAX_SAFE_INTEGER) {\n        datatype = Number.isInteger(value) ? XSD.integer : XSD.decimal;\n      } else {\n        datatype = XSD.double;\n      }\n\n      return new Literal(strValue, null, datatype);\n    }\n    /**\n     * @method fromValue\n     * @param value\n     * @return {Literal}\n     */\n\n  }, {\n    key: \"fromValue\",\n    value: function fromValue(value) {\n      if (typeof value === 'undefined' || value === null) {\n        return value;\n      }\n\n      if (typeof value === 'object' && value.termType) {\n        // this is a Node instance\n        return value;\n      }\n\n      switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return Literal.fromDate(value);\n          }\n\n        case 'boolean':\n          return Literal.fromBoolean(value);\n\n        case 'number':\n          return Literal.fromNumber(value);\n\n        case 'string':\n          return new Literal(value);\n      }\n\n      throw new Error(\"Can't make literal from \" + value + ' of type ' + typeof value);\n    }\n  }]);\n\n  return Literal;\n}(Node);\n\nexport { Literal as default };\nLiteral.termType = 'Literal';\nLiteral.prototype.classOrder = ClassOrder['Literal'];\nLiteral.prototype.datatype = XSD.string;\nLiteral.prototype.lang = '';\nLiteral.prototype.isVar = 0;","map":null,"metadata":{},"sourceType":"module"}