{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar fetch = require('node-fetch');\n\nvar onHttpError = require('./onHttpError');\n\nvar PoPToken = require('./PoPToken');\n\nvar Session =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param options {Object}\n   *\n   * @param options.credentialType {string} 'access_token' or 'pop_token'\n   *\n   * @param options.issuer {string} Identity provider (issuer of ID/Access Token)\n   *\n   * @param options.authorization {object}\n   * @param options.authorization.client_id {string} OIDC/OAuth2 client id\n   * @param [options.authorization.id_token] {string} Compact-serialized id_token param\n   * @param [options.authorization.access_token] {string} Compact-serialized access_token param\n   * @param [options.authorization.refresh_token] {string} Compact-serialized refresh_token\n   *\n   * @param [options.sessionKey] {string} Serialized client session key generated\n   *   during the Authentication Request, used to issue PoPTokens\n   *\n   * @param [options.idClaims] {object} Decoded/verified ID Token JWT payload\n   *\n   * @param [options.accessClaims] {object} Decoded/verified Access Token JWT payload\n   */\n  function Session(options) {\n    _classCallCheck(this, Session);\n\n    this.credentialType = options.credentialType || 'access_token';\n    this.issuer = options.issuer;\n    this.authorization = options.authorization || {};\n    this.sessionKey = options.sessionKey;\n    this.idClaims = options.idClaims;\n    this.accessClaims = options.accessClaims;\n  }\n\n  _createClass(Session, [{\n    key: \"bearerTokenFor\",\n\n    /**\n     * bearerTokenFor\n     *\n     * @param url {string}\n     *\n     * @returns {Promise<string>}\n     */\n    value: function bearerTokenFor(url) {\n      switch (this.credentialType) {\n        case 'pop_token':\n          return PoPToken.issueFor(url, this);\n\n        default:\n          // 'access_token' etc\n          return Promise.resolve(this.authorization[this.credentialType]);\n      }\n    }\n    /**\n     * hasCredentials\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasCredentials\",\n    value: function hasCredentials() {\n      switch (this.credentialType) {\n        case 'pop_token':\n          return !!this.authorization['id_token'];\n\n        default:\n          // 'access_token' etc\n          return !!this.authorization[this.credentialType];\n      }\n    }\n    /**\n     * fetchWithCredentials\n     *\n     * @param url {RequestInfo|string}\n     * @param options {object}\n     *\n     * @returns {Promise<Response>}\n     */\n\n  }, {\n    key: \"fetchWithCredentials\",\n    value: function fetchWithCredentials(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options.headers = options.headers || {};\n      return this.bearerTokenFor(url).then(function (token) {\n        options.headers.authorization = \"Bearer \".concat(token);\n        return fetch(url, options);\n      });\n    }\n  }, {\n    key: \"fetch\",\n\n    /**\n     * Authenticated fetch() getter\n     *\n     * @returns {function}\n     */\n    get: function get() {\n      var _this = this;\n\n      /**\n       * fetch() function signature\n       *\n       * @param url {RequestInfo|string}\n       * @param options {object}\n       *\n       * @returns {Function<Promise<Response>>}\n       */\n      return function (url, options) {\n        return Promise.resolve().then(function () {\n          if (_this.hasCredentials()) {\n            return _this.fetchWithCredentials(url, options);\n          } else {\n            return fetch(url, options);\n          }\n        }).then(onHttpError('Error while fetching resource'));\n      };\n    }\n  }], [{\n    key: \"from\",\n    value: function from(options) {\n      return new Session(options);\n    }\n    /**\n     * @param response {AuthenticationResponse}\n     *\n     * @returns {Session} RelyingParty Session object\n     */\n\n  }, {\n    key: \"fromAuthResponse\",\n    value: function fromAuthResponse(response) {\n      var RelyingParty = require('./RelyingParty'); // import here due to circular dep\n\n\n      var idClaims = response.decoded && response.decoded.payload || {};\n      var rp = response.rp;\n      var registration = rp.registration;\n      var rpAuthOptions = rp.defaults.authenticate || {};\n      var credentialType = rpAuthOptions['credential_type'] || rp.defaults.popToken ? 'pop_token' : 'access_token';\n      var sessionKey = response.session[RelyingParty.SESSION_PRIVATE_KEY];\n      var options = {\n        credentialType: credentialType,\n        sessionKey: sessionKey,\n        issuer: idClaims.iss,\n        idClaims: idClaims,\n        authorization: {\n          client_id: registration['client_id'],\n          access_token: response.params['access_token'],\n          id_token: response.params['id_token'],\n          refresh_token: response.params['refresh_token']\n        }\n      };\n      return Session.from(options);\n    }\n  }]);\n\n  return Session;\n}();\n\nmodule.exports = Session;","map":null,"metadata":{},"sourceType":"script"}