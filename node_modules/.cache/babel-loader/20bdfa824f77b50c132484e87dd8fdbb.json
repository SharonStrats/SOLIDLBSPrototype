{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport Node from './node';\n\nvar Statement =\n/*#__PURE__*/\nfunction () {\n  /* Construct a new statment\n  **\n  ** @param {Term} subject - The subject of the triple.  What the efact is about\n  ** @ param {Term} predciate - The relationship which is assrted between the subject and object\n  ** @param {Term} object - The thing or data value which is asserted to be related to the subject\n  ** @param {NamedNode} why - The document where thr triple is or was or will be stored on the web.\n  **\n  ** The why param is a named node of the document in which the triple when\n  ** it is stored on the web.\n  ** It is called “why” because when you have read data from varou slaces the\n  **  “why” tells you why you have the triple. (At the moment, it is just the\n  ** document, in future it could be an inference step). When you do\n  ** UpdateManager.update() then the why’s of all the statmemts must be the same,\n  ** and give the document you are patching. In future, we may have a more\n  ** powerful update() which can update more than one docment.\n  */\n  function Statement(subject, predicate, object, graph) {\n    _classCallCheck(this, Statement);\n\n    this.subject = Node.fromValue(subject);\n    this.predicate = Node.fromValue(predicate);\n    this.object = Node.fromValue(object);\n    this.why = graph; // property currently used by rdflib\n  }\n\n  _createClass(Statement, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return other.subject.equals(this.subject) && other.predicate.equals(this.predicate) && other.object.equals(this.object) && other.graph.equals(this.graph);\n    }\n  }, {\n    key: \"substitute\",\n    value: function substitute(bindings) {\n      var y = new Statement(this.subject.substitute(bindings), this.predicate.substitute(bindings), this.object.substitute(bindings), this.why.substitute(bindings)); // 2016\n\n      console.log('@@@ statement substitute:' + y);\n      return y;\n    }\n  }, {\n    key: \"toCanonical\",\n    value: function toCanonical() {\n      var terms = [this.subject.toCanonical(), this.predicate.toCanonical(), this.object.toCanonical()];\n\n      if (this.graph && this.graph.termType !== 'DefaultGraph') {\n        terms.push(this.graph.toCanonical());\n      }\n\n      return terms.join(' ') + ' .';\n    }\n  }, {\n    key: \"toNT\",\n    value: function toNT() {\n      return [this.subject.toNT(), this.predicate.toNT(), this.object.toNT()].join(' ') + ' .';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toNT();\n    }\n  }, {\n    key: \"graph\",\n    get: function get() {\n      return this.why;\n    },\n    set: function set(g) {\n      this.why = g;\n    }\n  }]);\n\n  return Statement;\n}();\n\nexport { Statement as default };","map":null,"metadata":{},"sourceType":"module"}