{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/**\n * CryptoKey interface\n */\nvar CryptoKey =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * Constructor\n   */\n  function CryptoKey(_ref) {\n    var type = _ref.type,\n        extractable = _ref.extractable,\n        algorithm = _ref.algorithm,\n        usages = _ref.usages,\n        handle = _ref.handle;\n\n    _classCallCheck(this, CryptoKey);\n\n    this.type = type;\n    this.extractable = extractable;\n    this.algorithm = algorithm;\n    this.usages = usages; // ensure values are not writeable\n\n    Object.defineProperties(this, {\n      // TODO\n      // These properties can't be fixed immediately on creation of the\n      // object because the implementation may build it up in stages.\n      // At some point in the operations before returning a key we should\n      // freeze the object to prevent further manipulation.\n      //type: {\n      //  enumerable: true,\n      //  writeable: false,\n      //  value: type\n      //},\n      //extractable: {\n      //  enumerable: true,\n      //  writeable: true,\n      //  value: extractable\n      //},\n      //algorithm: {\n      //  enumerable: true,\n      //  writeable: false,\n      //  value: algorithm\n      //},\n      //usages: {\n      //  enumerable: true,\n      //  writeable: true,\n      //  value: usages\n      //},\n      // this is the \"key material\" used internally\n      // it is not enumerable, but we need it to be\n      // accessible by algorithm implementations\n      handle: {\n        enumerable: false,\n        writeable: false,\n        value: handle\n      }\n    }); //if (!Array.isArray(type) || KeyType.indexOf(type) === -1) { throw new Error('Invalid CryptoKey type') }\n    // verify type of algorithm\n    // verify type/enum of usages\n  }\n  /**\n   * Structured clone algorithm\n   * https://www.w3.org/TR/WebCryptoAPI/#cryptokey-interface-clone\n   *\n   * TODO\n   * This requires review and consideration with respect to the\n   * internal structured cloning algorithm.\n   * https://www.w3.org/TR/WebCryptoAPI/#dfn-structured-clone\n   *\n   * @param {Object} input\n   * @param {Object} memory\n   *\n   * @returns {CryptoKey}\n   */\n\n\n  _createClass(CryptoKey, [{\n    key: \"clone\",\n    value: function clone(_ref2, memory) {\n      var type = _ref2.type,\n          extractable = _ref2.extractable,\n          algorithm = _ref2.algorithm,\n          usages = _ref2.usages,\n          handle = _ref2.handle;\n      return new CryptoKey({\n        type: type,\n        extractable: extractable,\n        algorithm: algorithm,\n        usages: usages,\n        handle: handle\n      });\n    }\n  }]);\n\n  return CryptoKey;\n}();\n/**\n * Export\n */\n\n\nmodule.exports = CryptoKey;","map":null,"metadata":{},"sourceType":"script"}