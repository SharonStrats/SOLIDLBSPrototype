{"ast":null,"code":"/**\n*\n*  UTF-8 data encode / decode\n*  http://www.webtoolkit.info/\n*\n**/\nimport * as Uri from './uri';\nimport { ArrayIndexOf } from './util';\nexport default (function () {\n  function hexify(str) {\n    // also used in parser\n    return encodeURI(str);\n  }\n\n  var Utf8 = {\n    // public method for url encoding\n    encode: function encode(string) {\n      string = string.replace(/\\r\\n/g, \"\\n\");\n      var utftext = \"\";\n\n      for (var n = 0; n < string.length; n++) {\n        var c = string.charCodeAt(n);\n\n        if (c < 128) {\n          utftext += String.fromCharCode(c);\n        } else if (c > 127 && c < 2048) {\n          utftext += String.fromCharCode(c >> 6 | 192);\n          utftext += String.fromCharCode(c & 63 | 128);\n        } else {\n          utftext += String.fromCharCode(c >> 12 | 224);\n          utftext += String.fromCharCode(c >> 6 & 63 | 128);\n          utftext += String.fromCharCode(c & 63 | 128);\n        }\n      }\n\n      return utftext;\n    },\n    // public method for url decoding\n    decode: function decode(utftext) {\n      var string = \"\";\n      var i = 0;\n\n      while (i < utftext.length) {\n        var c = utftext.charCodeAt(i);\n\n        if (c < 128) {\n          string += String.fromCharCode(c);\n          i++;\n        } else if (c > 191 && c < 224) {\n          string += String.fromCharCode((c & 31) << 6 | utftext.charCodeAt(i + 1) & 63);\n          i += 2;\n        } else {\n          string += String.fromCharCode((c & 15) << 12 | (utftext.charCodeAt(i + 1) & 63) << 6 | utftext.charCodeAt(i + 2) & 63);\n          i += 3;\n        }\n      }\n\n      return string;\n    } // Things we need to define to make converted pythn code work in js\n    // environment of $rdf\n\n  };\n  var RDFSink_forSomeSym = \"http://www.w3.org/2000/10/swap/log#forSome\";\n  var RDFSink_forAllSym = \"http://www.w3.org/2000/10/swap/log#forAll\";\n  var Logic_NS = \"http://www.w3.org/2000/10/swap/log#\"; //  pyjs seems to reference runtime library which I didn't find\n\n  var pyjslib_Tuple = function pyjslib_Tuple(theList) {\n    return theList;\n  };\n\n  var pyjslib_List = function pyjslib_List(theList) {\n    return theList;\n  };\n\n  var pyjslib_Dict = function pyjslib_Dict(listOfPairs) {\n    if (listOfPairs.length > 0) throw \"missing.js: oops nnonempty dict not imp\";\n    return [];\n  };\n\n  var pyjslib_len = function pyjslib_len(s) {\n    return s.length;\n  };\n\n  var pyjslib_slice = function pyjslib_slice(str, i, j) {\n    if (typeof str.slice == 'undefined') throw '@@ mising.js: No .slice function for ' + str + ' of type ' + typeof str;\n    if (typeof j == 'undefined' || j == null) return str.slice(i);\n    return str.slice(i, j); // @ exactly the same spec?\n  };\n\n  var StopIteration = Error('dummy error stop iteration');\n\n  var pyjslib_Iterator = function pyjslib_Iterator(theList) {\n    this.last = 0;\n    this.li = theList;\n\n    this.next = function () {\n      if (this.last == this.li.length) throw StopIteration;\n      return this.li[this.last++];\n    };\n\n    return this;\n  };\n\n  var ord = function ord(str) {\n    return str.charCodeAt(0);\n  };\n\n  var string_find = function string_find(str, s) {\n    return str.indexOf(s);\n  };\n\n  var assertFudge = function assertFudge(condition, desc) {\n    if (condition) return;\n    if (desc) throw \"python Assertion failed: \" + desc;\n    throw \"(python) Assertion failed.\";\n  };\n\n  var stringFromCharCode = function stringFromCharCode(uesc) {\n    return String.fromCharCode(uesc);\n  };\n\n  String.prototype.encode = function (encoding) {\n    if (encoding != 'utf-8') throw \"UTF8_converter: can only do utf-8\";\n    return Utf8.encode(this);\n  };\n\n  String.prototype.decode = function (encoding) {\n    if (encoding != 'utf-8') throw \"UTF8_converter: can only do utf-8\"; //return Utf8.decode(this);\n\n    return this;\n  };\n\n  var uripath_join = function uripath_join(base, given) {\n    return Uri.join(given, base); // sad but true\n  };\n\n  var becauseSubexpression = null; // No reason needed\n\n  var diag_tracking = 0;\n  var diag_chatty_flag = 0;\n\n  var diag_progress = function diag_progress(str) {}\n  /*$rdf.log.debug(str);*/\n  // why_BecauseOfData = function(doc, reason) { return doc };\n  ;\n\n  var RDF_type_URI = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\";\n  var DAML_sameAs_URI = \"http://www.w3.org/2002/07/owl#sameAs\";\n  /*\n  function SyntaxError(details) {\n      return new __SyntaxError(details);\n  }\n  */\n\n  function __SyntaxError(details) {\n    this.details = details;\n  }\n  /*\n  \n  $Id: n3parser.js 14561 2008-02-23 06:37:26Z kennyluck $\n  \n  HAND EDITED FOR CONVERSION TO JAVASCRIPT\n  \n  This module implements a Nptation3 parser, and the final\n  part of a notation3 serializer.\n  \n  See also:\n  \n  Notation 3\n  http://www.w3.org/DesignIssues/Notation3\n  \n  Closed World Machine - and RDF Processor\n  http://www.w3.org/2000/10/swap/cwm\n  \n  To DO: See also \"@@\" in comments\n  \n  - Clean up interfaces\n  ______________________________________________\n  \n  Module originally by Dan Connolly, includeing notation3\n  parser and RDF generator. TimBL added RDF stream model\n  and N3 generation, replaced stream model with use\n  of common store/formula API.  Yosi Scharf developped\n  the module, including tests and test harness.\n  \n  */\n\n\n  var ADDED_HASH = \"#\";\n  var LOG_implies_URI = \"http://www.w3.org/2000/10/swap/log#implies\";\n  var INTEGER_DATATYPE = \"http://www.w3.org/2001/XMLSchema#integer\";\n  var FLOAT_DATATYPE = \"http://www.w3.org/2001/XMLSchema#double\";\n  var DECIMAL_DATATYPE = \"http://www.w3.org/2001/XMLSchema#decimal\";\n  var DATE_DATATYPE = \"http://www.w3.org/2001/XMLSchema#date\";\n  var DATETIME_DATATYPE = \"http://www.w3.org/2001/XMLSchema#dateTime\";\n  var BOOLEAN_DATATYPE = \"http://www.w3.org/2001/XMLSchema#boolean\";\n  var option_noregen = 0;\n  var _notQNameChars = \"\\t\\r\\n !\\\"#$%&'()*.,+/;<=>?@[\\\\]^`{|}~\";\n\n  var _notNameChars = _notQNameChars + \":\";\n\n  var _rdfns = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n  var N3CommentCharacter = \"#\";\n  var eol = new RegExp(\"^[ \\\\t]*(#[^\\\\n]*)?\\\\r?\\\\n\", 'g');\n  var eof = new RegExp(\"^[ \\\\t]*(#[^\\\\n]*)?$\", 'g');\n  var ws = new RegExp(\"^[ \\\\t]*\", 'g');\n  var signed_integer = new RegExp(\"^[-+]?[0-9]+\", 'g');\n  var number_syntax = new RegExp(\"^([-+]?[0-9]+)(\\\\.[0-9]+)?(e[-+]?[0-9]+)?\", 'g');\n  var datetime_syntax = new RegExp('^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9](T[0-9][0-9]:[0-9][0-9](:[0-9][0-9](\\\\.[0-9]*)?)?)?Z?');\n  var digitstring = new RegExp(\"^[0-9]+\", 'g');\n  var interesting = new RegExp(\"[\\\\\\\\\\\\r\\\\n\\\\\\\"]\", 'g');\n  var langcode = new RegExp(\"^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\", 'g');\n\n  function SinkParser(store, openFormula, thisDoc, baseURI, genPrefix, metaURI, flags, why) {\n    return new __SinkParser(store, openFormula, thisDoc, baseURI, genPrefix, metaURI, flags, why);\n  }\n\n  function __SinkParser(store, openFormula, thisDoc, baseURI, genPrefix, metaURI, flags, why) {\n    if (typeof openFormula == 'undefined') openFormula = null;\n    if (typeof thisDoc == 'undefined') thisDoc = \"\";\n    if (typeof baseURI == 'undefined') baseURI = null;\n    if (typeof genPrefix == 'undefined') genPrefix = \"\";\n    if (typeof metaURI == 'undefined') metaURI = null;\n    if (typeof flags == 'undefined') flags = \"\";\n    if (typeof why == 'undefined') why = null;\n    /*\n    note: namespace names should *not* end in #;\n    the # will get added during qname processing */\n\n    this._bindings = new pyjslib_Dict([]);\n    this._flags = flags;\n\n    if (thisDoc != \"\") {\n      assertFudge(thisDoc.indexOf(\":\") >= 0, \"Document URI not absolute: \" + thisDoc);\n      this._bindings[\"\"] = thisDoc + \"#\";\n    }\n\n    this._store = store;\n\n    if (genPrefix) {\n      store.setGenPrefix(genPrefix);\n    }\n\n    this._thisDoc = thisDoc;\n    this.source = store.sym(thisDoc);\n    this.lines = 0;\n    this.statementCount = 0;\n    this.startOfLine = 0;\n    this.previousLine = 0;\n    this._genPrefix = genPrefix;\n    this.keywords = new pyjslib_List([\"a\", \"this\", \"bind\", \"has\", \"is\", \"of\", \"true\", \"false\"]);\n    this.keywordsSet = 0;\n    this._anonymousNodes = new pyjslib_Dict([]);\n    this._variables = new pyjslib_Dict([]);\n    this._parentVariables = new pyjslib_Dict([]);\n    this._reason = why;\n    this._reason2 = null;\n\n    if (diag_tracking) {\n      this._reason2 = why_BecauseOfData(store.sym(thisDoc), this._reason);\n    }\n\n    if (baseURI) {\n      this._baseURI = baseURI;\n    } else {\n      if (thisDoc) {\n        this._baseURI = thisDoc;\n      } else {\n        this._baseURI = null;\n      }\n    }\n\n    assertFudge(!this._baseURI || this._baseURI.indexOf(\":\") >= 0);\n\n    if (!this._genPrefix) {\n      if (this._thisDoc) {\n        this._genPrefix = this._thisDoc + \"#_g\";\n      } else {\n        this._genPrefix = RDFSink_uniqueURI();\n      }\n    }\n\n    if (openFormula == null) {\n      if (this._thisDoc) {\n        this._formula = store.formula(thisDoc + \"#_formula\");\n      } else {\n        this._formula = store.formula();\n      }\n    } else {\n      this._formula = openFormula;\n    }\n\n    this._context = this._formula;\n    this._parentContext = null;\n  }\n\n  __SinkParser.prototype.here = function (i) {\n    return this._genPrefix + \"_L\" + this.lines + \"C\" + (i - this.startOfLine + 1);\n  };\n\n  __SinkParser.prototype.formula = function () {\n    return this._formula;\n  };\n\n  __SinkParser.prototype.loadStream = function (stream) {\n    return this.loadBuf(stream.read());\n  };\n\n  __SinkParser.prototype.loadBuf = function (buf) {\n    /*\n    Parses a buffer and returns its top level formula*/\n    this.startDoc();\n    this.feed(buf);\n    return this.endDoc();\n  };\n\n  __SinkParser.prototype.feed = function (octets) {\n    /*\n    Feed an octet stream tothe parser\n     if BadSyntax is raised, the string\n    passed in the exception object is the\n    remainder after any statements have been parsed.\n    So if there is more data to feed to the\n    parser, it should be straightforward to recover.*/\n    var str = octets.decode(\"utf-8\");\n    var i = 0;\n\n    while (i >= 0) {\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        return;\n      }\n\n      var i = this.directiveOrStatement(str, j);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"expected directive or statement\");\n      }\n    }\n  };\n\n  __SinkParser.prototype.directiveOrStatement = function (str, h) {\n    var i = this.skipSpace(str, h);\n\n    if (i < 0) {\n      return i;\n    }\n\n    var j = this.directive(str, i);\n\n    if (j >= 0) {\n      return this.checkDot(str, j);\n    }\n\n    var j = this.statement(str, i);\n\n    if (j >= 0) {\n      return this.checkDot(str, j);\n    }\n\n    return j;\n  };\n\n  __SinkParser.prototype.tok = function (tok, str, i) {\n    /*\n    Check for keyword.  Space must have been stripped on entry and\n    we must not be at end of file.*/\n    var whitespace = \"\\t\\n\\v\\f\\r \";\n\n    if (str.slice(i, i + 1) == \"@\") {\n      var i = i + 1;\n    } else {\n      if (ArrayIndexOf(this.keywords, tok) < 0) {\n        return -1;\n      }\n    }\n\n    var k = i + pyjslib_len(tok);\n\n    if (str.slice(i, k) == tok && _notQNameChars.indexOf(str.charAt(k)) >= 0) {\n      return k;\n    } else {\n      return -1;\n    }\n  };\n\n  __SinkParser.prototype.directive = function (str, i) {\n    var j = this.skipSpace(str, i);\n\n    if (j < 0) {\n      return j;\n    }\n\n    var res = new pyjslib_List([]);\n    var j = this.tok(\"bind\", str, i);\n\n    if (j > 0) {\n      throw BadSyntax(this._thisDoc, this.lines, str, i, \"keyword bind is obsolete: use @prefix\");\n    }\n\n    var j = this.tok(\"keywords\", str, i);\n\n    if (j > 0) {\n      var i = this.commaSeparatedList(str, j, res, false);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"'@keywords' needs comma separated list of words\");\n      }\n\n      this.setKeywords(pyjslib_slice(res, null, null));\n\n      if (diag_chatty_flag > 80) {\n        diag_progress(\"Keywords \", this.keywords);\n      }\n\n      return i;\n    }\n\n    var j = this.tok(\"forAll\", str, i);\n\n    if (j > 0) {\n      var i = this.commaSeparatedList(str, j, res, true);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"Bad variable list after @forAll\");\n      }\n\n      var __x = new pyjslib_Iterator(res);\n\n      try {\n        while (true) {\n          var x = __x.next();\n\n          if (ArrayIndexOf(this._variables, x) < 0 || ArrayIndexOf(this._parentVariables, x) >= 0) {\n            this._variables[x] = this._context.newUniversal(x);\n          }\n        }\n      } catch (e) {\n        if (e != StopIteration) {\n          throw e;\n        }\n      }\n\n      return i;\n    }\n\n    var j = this.tok(\"forSome\", str, i);\n\n    if (j > 0) {\n      var i = this.commaSeparatedList(str, j, res, this.uri_ref2);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"Bad variable list after @forSome\");\n      }\n\n      var __x = new pyjslib_Iterator(res);\n\n      try {\n        while (true) {\n          var x = __x.next();\n\n          this._context.declareExistential(x);\n        }\n      } catch (e) {\n        if (e != StopIteration) {\n          throw e;\n        }\n      }\n\n      return i;\n    }\n\n    var j = this.tok(\"prefix\", str, i);\n\n    if (j >= 0) {\n      var t = new pyjslib_List([]);\n      var i = this.qname(str, j, t);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"expected qname after @prefix\");\n      }\n\n      var j = this.uri_ref2(str, i, t);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"expected <uriref> after @prefix _qname_\");\n      }\n\n      var ns = t[1].uri;\n\n      if (this._baseURI) {\n        var ns = uripath_join(this._baseURI, ns);\n      } else {\n        assertFudge(ns.indexOf(\":\") >= 0, \"With no base URI, cannot handle relative URI for NS\");\n      }\n\n      assertFudge(ns.indexOf(\":\") >= 0);\n      this._bindings[t[0][0]] = ns;\n      this.bind(t[0][0], hexify(ns));\n      return j;\n    }\n\n    var j = this.tok(\"base\", str, i);\n\n    if (j >= 0) {\n      var t = new pyjslib_List([]);\n      var i = this.uri_ref2(str, j, t);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"expected <uri> after @base \");\n      }\n\n      var ns = t[0].uri;\n\n      if (this._baseURI) {\n        var ns = uripath_join(this._baseURI, ns);\n      } else {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"With no previous base URI, cannot use relative URI in @base  <\" + ns + \">\");\n      }\n\n      assertFudge(ns.indexOf(\":\") >= 0);\n      this._baseURI = ns;\n      return i;\n    }\n\n    return -1;\n  };\n\n  __SinkParser.prototype.bind = function (qn, uri) {\n    if (qn == \"\") {} else {\n      this._store.setPrefixForURI(qn, uri);\n    }\n  };\n\n  __SinkParser.prototype.setKeywords = function (k) {\n    /*\n    Takes a list of strings*/\n    if (k == null) {\n      this.keywordsSet = 0;\n    } else {\n      this.keywords = k;\n      this.keywordsSet = 1;\n    }\n  };\n\n  __SinkParser.prototype.startDoc = function () {};\n\n  __SinkParser.prototype.endDoc = function () {\n    /*\n    Signal end of document and stop parsing. returns formula*/\n    return this._formula;\n  };\n\n  __SinkParser.prototype.makeStatement = function (quad) {\n    quad[0].add(quad[2], quad[1], quad[3], this.source);\n    this.statementCount += 1;\n  };\n\n  __SinkParser.prototype.statement = function (str, i) {\n    var r = new pyjslib_List([]);\n    var i = this.object(str, i, r);\n\n    if (i < 0) {\n      return i;\n    }\n\n    var j = this.property_list(str, i, r[0]);\n\n    if (j < 0) {\n      throw BadSyntax(this._thisDoc, this.lines, str, i, \"expected propertylist\");\n    }\n\n    return j;\n  };\n\n  __SinkParser.prototype.subject = function (str, i, res) {\n    return this.item(str, i, res);\n  };\n\n  __SinkParser.prototype.verb = function (str, i, res) {\n    /*\n    has _prop_\n    is _prop_ of\n    a\n    =\n    _prop_\n    >- prop ->\n    <- prop -<\n    _operator_*/\n    var j = this.skipSpace(str, i);\n\n    if (j < 0) {\n      return j;\n    }\n\n    var r = new pyjslib_List([]);\n    var j = this.tok(\"has\", str, i);\n\n    if (j >= 0) {\n      var i = this.prop(str, j, r);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"expected property after 'has'\");\n      }\n\n      res.push(new pyjslib_Tuple([\"->\", r[0]]));\n      return i;\n    }\n\n    var j = this.tok(\"is\", str, i);\n\n    if (j >= 0) {\n      var i = this.prop(str, j, r);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"expected <property> after 'is'\");\n      }\n\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"End of file found, expected property after 'is'\");\n        return j;\n      }\n\n      var i = j;\n      var j = this.tok(\"of\", str, i);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"expected 'of' after 'is' <prop>\");\n      }\n\n      res.push(new pyjslib_Tuple([\"<-\", r[0]]));\n      return j;\n    }\n\n    var j = this.tok(\"a\", str, i);\n\n    if (j >= 0) {\n      res.push(new pyjslib_Tuple([\"->\", this._store.sym(RDF_type_URI)]));\n      return j;\n    }\n\n    if (str.slice(i, i + 2) == \"<=\") {\n      res.push(new pyjslib_Tuple([\"<-\", this._store.sym(Logic_NS + \"implies\")]));\n      return i + 2;\n    }\n\n    if (str.slice(i, i + 1) == \"=\") {\n      if (str.slice(i + 1, i + 2) == \">\") {\n        res.push(new pyjslib_Tuple([\"->\", this._store.sym(Logic_NS + \"implies\")]));\n        return i + 2;\n      }\n\n      res.push(new pyjslib_Tuple([\"->\", this._store.sym(DAML_sameAs_URI)]));\n      return i + 1;\n    }\n\n    if (str.slice(i, i + 2) == \":=\") {\n      res.push(new pyjslib_Tuple([\"->\", Logic_NS + \"becomes\"]));\n      return i + 2;\n    }\n\n    var j = this.prop(str, i, r);\n\n    if (j >= 0) {\n      res.push(new pyjslib_Tuple([\"->\", r[0]]));\n      return j;\n    }\n\n    if (str.slice(i, i + 2) == \">-\" || str.slice(i, i + 2) == \"<-\") {\n      throw BadSyntax(this._thisDoc, this.lines, str, j, \">- ... -> syntax is obsolete.\");\n    }\n\n    return -1;\n  };\n\n  __SinkParser.prototype.prop = function (str, i, res) {\n    return this.item(str, i, res);\n  };\n\n  __SinkParser.prototype.item = function (str, i, res) {\n    return this.path(str, i, res);\n  };\n\n  __SinkParser.prototype.blankNode = function (uri) {\n    return this._context.bnode(uri, this._reason2);\n  };\n\n  __SinkParser.prototype.path = function (str, i, res) {\n    /*\n    Parse the path production.\n    */\n    var j = this.nodeOrLiteral(str, i, res);\n\n    if (j < 0) {\n      return j;\n    }\n\n    while (\"!^.\".indexOf(str.slice(j, j + 1)) >= 0) {\n      var ch = str.slice(j, j + 1);\n\n      if (ch == \".\") {\n        var ahead = str.slice(j + 1, j + 2);\n\n        if (!ahead || _notNameChars.indexOf(ahead) >= 0 && \":?<[{(\".indexOf(ahead) < 0) {\n          break;\n        }\n      }\n\n      var subj = res.pop();\n      var obj = this.blankNode(this.here(j));\n      var j = this.node(str, j + 1, res);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"EOF found in middle of path syntax\");\n      }\n\n      var pred = res.pop();\n\n      if (ch == \"^\") {\n        this.makeStatement(new pyjslib_Tuple([this._context, pred, obj, subj]));\n      } else {\n        this.makeStatement(new pyjslib_Tuple([this._context, pred, subj, obj]));\n      }\n\n      res.push(obj);\n    }\n\n    return j;\n  };\n\n  __SinkParser.prototype.anonymousNode = function (ln) {\n    /*\n    Remember or generate a term for one of these _: anonymous nodes*/\n    var term = this._anonymousNodes[ln];\n\n    if (term) {\n      return term;\n    }\n\n    var term = this._store.bnode(ln); // var term = this._store.bnode(this._context, this._reason2); eh?\n\n\n    this._anonymousNodes[ln] = term;\n    return term;\n  };\n\n  __SinkParser.prototype.node = function (str, i, res, subjectAlready) {\n    if (typeof subjectAlready == 'undefined') subjectAlready = null;\n    /*\n    Parse the <node> production.\n    Space is now skipped once at the beginning\n    instead of in multipe calls to self.skipSpace().\n    */\n\n    var subj = subjectAlready;\n    var j = this.skipSpace(str, i);\n\n    if (j < 0) {\n      return j;\n    }\n\n    var i = j;\n    var ch = str.slice(i, i + 1);\n\n    if (ch == \"[\") {\n      var bnodeID = this.here(i);\n      var j = this.skipSpace(str, i + 1);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"EOF after '['\");\n      }\n\n      if (str.slice(j, j + 1) == \"=\") {\n        var i = j + 1;\n        var objs = new pyjslib_List([]);\n        var j = this.objectList(str, i, objs);\n\n        if (j >= 0) {\n          var subj = objs[0];\n\n          if (pyjslib_len(objs) > 1) {\n            var __obj = new pyjslib_Iterator(objs);\n\n            try {\n              while (true) {\n                var obj = __obj.next();\n\n                this.makeStatement(new pyjslib_Tuple([this._context, this._store.sym(DAML_sameAs_URI), subj, obj]));\n              }\n            } catch (e) {\n              if (e != StopIteration) {\n                throw e;\n              }\n            }\n          }\n\n          var j = this.skipSpace(str, j);\n\n          if (j < 0) {\n            throw BadSyntax(this._thisDoc, this.lines, str, i, \"EOF when objectList expected after [ = \");\n          }\n\n          if (str.slice(j, j + 1) == \";\") {\n            var j = j + 1;\n          }\n        } else {\n          throw BadSyntax(this._thisDoc, this.lines, str, i, \"objectList expected after [= \");\n        }\n      }\n\n      if (subj == null) {\n        var subj = this.blankNode(bnodeID);\n      }\n\n      var i = this.property_list(str, j, subj);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"property_list expected\");\n      }\n\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"EOF when ']' expected after [ <propertyList>\");\n      }\n\n      if (str.slice(j, j + 1) != \"]\") {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"']' expected\");\n      }\n\n      res.push(subj);\n      return j + 1;\n    }\n\n    if (ch == \"{\") {\n      var ch2 = str.slice(i + 1, i + 2);\n\n      if (ch2 == \"$\") {\n        i += 1;\n        var j = i + 1;\n        var mylist = new pyjslib_List([]);\n        var first_run = true;\n\n        while (1) {\n          var i = this.skipSpace(str, j);\n\n          if (i < 0) {\n            throw BadSyntax(this._thisDoc, this.lines, str, i, \"needed '$}', found end.\");\n          }\n\n          if (str.slice(i, i + 2) == \"$}\") {\n            var j = i + 2;\n            break;\n          }\n\n          if (!first_run) {\n            if (str.slice(i, i + 1) == \",\") {\n              i += 1;\n            } else {\n              throw BadSyntax(this._thisDoc, this.lines, str, i, \"expected: ','\");\n            }\n          } else {\n            var first_run = false;\n          }\n\n          var item = new pyjslib_List([]);\n          var j = this.item(str, i, item);\n\n          if (j < 0) {\n            throw BadSyntax(this._thisDoc, this.lines, str, i, \"expected item in set or '$}'\");\n          }\n\n          mylist.push(item[0]);\n        }\n\n        res.push(this._store.newSet(mylist, this._context));\n        return j;\n      } else {\n        var j = i + 1;\n        var oldParentContext = this._parentContext;\n        this._parentContext = this._context;\n        var parentAnonymousNodes = this._anonymousNodes;\n        var grandParentVariables = this._parentVariables;\n        this._parentVariables = this._variables;\n        this._anonymousNodes = new pyjslib_Dict([]);\n        this._variables = this._variables.slice();\n        var reason2 = this._reason2;\n        this._reason2 = becauseSubexpression;\n\n        if (subj == null) {\n          var subj = this._store.formula();\n        }\n\n        this._context = subj;\n\n        while (1) {\n          var i = this.skipSpace(str, j);\n\n          if (i < 0) {\n            throw BadSyntax(this._thisDoc, this.lines, str, i, \"needed '}', found end.\");\n          }\n\n          if (str.slice(i, i + 1) == \"}\") {\n            var j = i + 1;\n            break;\n          }\n\n          var j = this.directiveOrStatement(str, i);\n\n          if (j < 0) {\n            throw BadSyntax(this._thisDoc, this.lines, str, i, \"expected statement or '}'\");\n          }\n        }\n\n        this._anonymousNodes = parentAnonymousNodes;\n        this._variables = this._parentVariables;\n        this._parentVariables = grandParentVariables;\n        this._context = this._parentContext;\n        this._reason2 = reason2;\n        this._parentContext = oldParentContext;\n        res.push(subj.close());\n        return j;\n      }\n    }\n\n    if (ch == \"(\") {\n      var thing_type = this._store.list;\n      var ch2 = str.slice(i + 1, i + 2);\n\n      if (ch2 == \"$\") {\n        var thing_type = this._store.newSet;\n        i += 1;\n      }\n\n      var j = i + 1;\n      var mylist = new pyjslib_List([]);\n\n      while (1) {\n        var i = this.skipSpace(str, j);\n\n        if (i < 0) {\n          throw BadSyntax(this._thisDoc, this.lines, str, i, \"needed ')', found end.\");\n        }\n\n        if (str.slice(i, i + 1) == \")\") {\n          var j = i + 1;\n          break;\n        }\n\n        var item = new pyjslib_List([]);\n        var j = this.item(str, i, item);\n\n        if (j < 0) {\n          throw BadSyntax(this._thisDoc, this.lines, str, i, \"expected item in list or ')'\");\n        }\n\n        mylist.push(item[0]);\n      }\n\n      res.push(thing_type(mylist, this._context));\n      return j;\n    }\n\n    var j = this.tok(\"this\", str, i);\n\n    if (j >= 0) {\n      throw BadSyntax(this._thisDoc, this.lines, str, i, \"Keyword 'this' was ancient N3. Now use @forSome and @forAll keywords.\");\n      res.push(this._context);\n      return j;\n    }\n\n    var j = this.tok(\"true\", str, i);\n\n    if (j >= 0) {\n      res.push(true);\n      return j;\n    }\n\n    var j = this.tok(\"false\", str, i);\n\n    if (j >= 0) {\n      res.push(false);\n      return j;\n    }\n\n    if (subj == null) {\n      var j = this.uri_ref2(str, i, res);\n\n      if (j >= 0) {\n        return j;\n      }\n    }\n\n    return -1;\n  };\n\n  __SinkParser.prototype.property_list = function (str, i, subj) {\n    /*\n    Parse property list\n    Leaves the terminating punctuation in the buffer\n    */\n    while (1) {\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"EOF found when expected verb in property list\");\n        return j;\n      }\n\n      if (str.slice(j, j + 2) == \":-\") {\n        var i = j + 2;\n        var res = new pyjslib_List([]);\n        var j = this.node(str, i, res, subj);\n\n        if (j < 0) {\n          throw BadSyntax(this._thisDoc, this.lines, str, i, \"bad {} or () or [] node after :- \");\n        }\n\n        var i = j;\n        continue;\n      }\n\n      var i = j;\n      var v = new pyjslib_List([]);\n      var j = this.verb(str, i, v);\n\n      if (j <= 0) {\n        return i;\n      }\n\n      var objs = new pyjslib_List([]);\n      var i = this.objectList(str, j, objs);\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"objectList expected\");\n      }\n\n      var __obj = new pyjslib_Iterator(objs);\n\n      try {\n        while (true) {\n          var obj = __obj.next();\n\n          var pairFudge = v[0];\n          var dir = pairFudge[0];\n          var sym = pairFudge[1];\n\n          if (dir == \"->\") {\n            this.makeStatement(new pyjslib_Tuple([this._context, sym, subj, obj]));\n          } else {\n            this.makeStatement(new pyjslib_Tuple([this._context, sym, obj, subj]));\n          }\n        }\n      } catch (e) {\n        if (e != StopIteration) {\n          throw e;\n        }\n      }\n\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"EOF found in list of objects\");\n        return j;\n      }\n\n      if (str.slice(i, i + 1) != \";\") {\n        return i;\n      }\n\n      var i = i + 1;\n    }\n  };\n\n  __SinkParser.prototype.commaSeparatedList = function (str, j, res, ofUris) {\n    /*\n    return value: -1 bad syntax; >1 new position in str\n    res has things found appended\n     Used to use a final value of the function to be called, e.g. this.bareWord\n    but passing the function didn't work fo js converion pyjs\n    */\n    var i = this.skipSpace(str, j);\n\n    if (i < 0) {\n      throw BadSyntax(this._thisDoc, this.lines, str, i, \"EOF found expecting comma sep list\");\n      return i;\n    }\n\n    if (str.charAt(i) == \".\") {\n      return j;\n    }\n\n    if (ofUris) {\n      var i = this.uri_ref2(str, i, res);\n    } else {\n      var i = this.bareWord(str, i, res);\n    }\n\n    if (i < 0) {\n      return -1;\n    }\n\n    while (1) {\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        return j;\n      }\n\n      var ch = str.slice(j, j + 1);\n\n      if (ch != \",\") {\n        if (ch != \".\") {\n          return -1;\n        }\n\n        return j;\n      }\n\n      if (ofUris) {\n        var i = this.uri_ref2(str, j + 1, res);\n      } else {\n        var i = this.bareWord(str, j + 1, res);\n      }\n\n      if (i < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"bad list content\");\n        return i;\n      }\n    }\n  };\n\n  __SinkParser.prototype.objectList = function (str, i, res) {\n    var i = this.object(str, i, res);\n\n    if (i < 0) {\n      return -1;\n    }\n\n    while (1) {\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, j, \"EOF found after object\");\n        return j;\n      }\n\n      if (str.slice(j, j + 1) != \",\") {\n        return j;\n      }\n\n      var i = this.object(str, j + 1, res);\n\n      if (i < 0) {\n        return i;\n      }\n    }\n  };\n\n  __SinkParser.prototype.checkDot = function (str, i) {\n    var j = this.skipSpace(str, i);\n\n    if (j < 0) {\n      return j;\n    }\n\n    if (str.slice(j, j + 1) == \".\") {\n      return j + 1;\n    }\n\n    if (str.slice(j, j + 1) == \"}\") {\n      return j;\n    }\n\n    if (str.slice(j, j + 1) == \"]\") {\n      return j;\n    }\n\n    throw BadSyntax(this._thisDoc, this.lines, str, j, \"expected '.' or '}' or ']' at end of statement\");\n    return i;\n  };\n\n  __SinkParser.prototype.uri_ref2 = function (str, i, res) {\n    /*\n    Generate uri from n3 representation.\n     Note that the RDF convention of directly concatenating\n    NS and local name is now used though I prefer inserting a '#'\n    to make the namesapces look more like what XML folks expect.\n    */\n    var qn = new pyjslib_List([]);\n    var j = this.qname(str, i, qn);\n\n    if (j >= 0) {\n      var pairFudge = qn[0];\n      var pfx = pairFudge[0];\n      var ln = pairFudge[1];\n\n      if (pfx == null) {\n        assertFudge(0, \"not used?\");\n        var ns = this._baseURI + ADDED_HASH;\n      } else {\n        var ns = this._bindings[pfx];\n\n        if (!ns) {\n          if (pfx == \"_\") {\n            res.push(this.anonymousNode(ln));\n            return j;\n          }\n\n          throw BadSyntax(this._thisDoc, this.lines, str, i, \"Prefix \" + pfx + \" not bound.\");\n        }\n      }\n\n      var symb = this._store.sym(ns + ln);\n\n      if (ArrayIndexOf(this._variables, symb) >= 0) {\n        res.push(this._variables[symb]);\n      } else {\n        res.push(symb);\n      }\n\n      return j;\n    }\n\n    var i = this.skipSpace(str, i);\n\n    if (i < 0) {\n      return -1;\n    }\n\n    if (str.charAt(i) == \"?\") {\n      var v = new pyjslib_List([]);\n      var j = this.variable(str, i, v);\n\n      if (j > 0) {\n        res.push(v[0]);\n        return j;\n      }\n\n      return -1;\n    } else if (str.charAt(i) == \"<\") {\n      var i = i + 1;\n      var st = i;\n\n      while (i < pyjslib_len(str)) {\n        if (str.charAt(i) == \">\") {\n          var uref = str.slice(st, i);\n\n          if (this._baseURI) {\n            var uref = uripath_join(this._baseURI, uref);\n          } else {\n            assertFudge(uref.indexOf(\":\") >= 0, \"With no base URI, cannot deal with relative URIs\");\n          }\n\n          if (str.slice(i - 1, i) == \"#\" && !(pyjslib_slice(uref, -1, null) == \"#\")) {\n            var uref = uref + \"#\";\n          }\n\n          var symb = this._store.sym(uref);\n\n          if (ArrayIndexOf(this._variables, symb) >= 0) {\n            res.push(this._variables[symb]);\n          } else {\n            res.push(symb);\n          }\n\n          return i + 1;\n        }\n\n        var i = i + 1;\n      }\n\n      throw BadSyntax(this._thisDoc, this.lines, str, j, \"unterminated URI reference\");\n    } else if (this.keywordsSet) {\n      var v = new pyjslib_List([]);\n      var j = this.bareWord(str, i, v);\n\n      if (j < 0) {\n        return -1;\n      }\n\n      if (ArrayIndexOf(this.keywords, v[0]) >= 0) {\n        throw BadSyntax(this._thisDoc, this.lines, str, i, \"Keyword \\\"\" + v[0] + \"\\\" not allowed here.\");\n      }\n\n      res.push(this._store.sym(this._bindings[\"\"] + v[0]));\n      return j;\n    } else {\n      return -1;\n    }\n  };\n\n  __SinkParser.prototype.skipSpace = function (str, i) {\n    /*\n    Skip white space, newlines and comments.\n    return -1 if EOF, else position of first non-ws character*/\n    var whitespace = \" \\n\\r\\t\\f\\x0B\\xA0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u200B\\u2028\\u2029\\u3000\";\n\n    for (var j = i ? i : 0; j < str.length; j++) {\n      var ch = str.charAt(j); // console.log(\"    skipspace j= \"+j + \" i= \" + i + \" n= \" + str.length);\n      // console.log(\" skipspace ch <\" + ch + \">\");\n\n      if (whitespace.indexOf(ch) < 0) {\n        //not ws\n        // console.log(\" skipspace 2 ch <\" + ch + \">\");\n        if (str.charAt(j) === '#') {\n          for (;; j++) {\n            // console.log(\"    skipspace2 j= \"+j + \" i= \" + i + \" n= \" + str.length);\n            if (j === str.length) {\n              return -1; // EOF\n            }\n\n            if (str.charAt(j) === '\\n') {\n              this.lines = this.lines + 1;\n              break;\n            }\n          }\n\n          ;\n        } else {\n          // Not hash - something interesting\n          // console.log(\" skipspace 3 ch <\" + ch + \">\");\n          return j;\n        }\n      } else {\n        // Whitespace\n        // console.log(\" skipspace 5 ch <\" + ch + \">\");\n        if (str.charAt(j) === '\\n') {\n          this.lines = this.lines + 1;\n        }\n      }\n    } // next j\n\n\n    return -1; // EOF\n  };\n\n  __SinkParser.prototype.variable = function (str, i, res) {\n    /*\n    ?abc -> variable(:abc)\n    */\n    var j = this.skipSpace(str, i);\n\n    if (j < 0) {\n      return -1;\n    }\n\n    if (str.slice(j, j + 1) != \"?\") {\n      return -1;\n    }\n\n    var j = j + 1;\n    var i = j;\n\n    if (\"0123456789-\".indexOf(str.charAt(j)) >= 0) {\n      throw BadSyntax(this._thisDoc, this.lines, str, j, \"Varible name can't start with '\" + str.charAt(j) + \"s'\");\n      return -1;\n    }\n\n    while (i < pyjslib_len(str) && _notNameChars.indexOf(str.charAt(i)) < 0) {\n      var i = i + 1;\n    }\n\n    if (this._parentContext == null) {\n      throw BadSyntax(this._thisDoc, this.lines, str, j, \"Can't use ?xxx syntax for variable in outermost level: \" + str.slice(j - 1, i));\n    }\n\n    res.push(this._store.variable(str.slice(j, i)));\n    return i;\n  };\n\n  __SinkParser.prototype.bareWord = function (str, i, res) {\n    /*\n    abc -> :abc\n    */\n    var j = this.skipSpace(str, i);\n\n    if (j < 0) {\n      return -1;\n    }\n\n    var ch = str.charAt(j);\n\n    if (\"0123456789-\".indexOf(ch) >= 0) {\n      return -1;\n    }\n\n    if (_notNameChars.indexOf(ch) >= 0) {\n      return -1;\n    }\n\n    var i = j;\n\n    while (i < pyjslib_len(str) && _notNameChars.indexOf(str.charAt(i)) < 0) {\n      var i = i + 1;\n    }\n\n    res.push(str.slice(j, i));\n    return i;\n  };\n\n  __SinkParser.prototype.qname = function (str, i, res) {\n    /*\n     xyz:def -> ('xyz', 'def')\n    If not in keywords and keywordsSet: def -> ('', 'def')\n    :def -> ('', 'def')\n    */\n    var i = this.skipSpace(str, i);\n\n    if (i < 0) {\n      return -1;\n    }\n\n    var c = str.charAt(i);\n\n    if (\"0123456789-+\".indexOf(c) >= 0) {\n      return -1;\n    }\n\n    if (_notNameChars.indexOf(c) < 0) {\n      var ln = c;\n      var i = i + 1;\n\n      while (i < pyjslib_len(str)) {\n        var c = str.charAt(i);\n\n        if (_notNameChars.indexOf(c) < 0) {\n          var ln = ln + c;\n          var i = i + 1;\n        } else {\n          break;\n        }\n      }\n    } else {\n      var ln = \"\";\n    }\n\n    if (i < pyjslib_len(str) && str.charAt(i) == \":\") {\n      var pfx = ln;\n      var i = i + 1;\n      var ln = \"\";\n\n      while (i < pyjslib_len(str)) {\n        var c = str.charAt(i);\n\n        if (_notNameChars.indexOf(c) < 0) {\n          var ln = ln + c;\n          var i = i + 1;\n        } else {\n          break;\n        }\n      }\n\n      res.push(new pyjslib_Tuple([pfx, ln]));\n      return i;\n    } else {\n      if (ln && this.keywordsSet && ArrayIndexOf(this.keywords, ln) < 0) {\n        res.push(new pyjslib_Tuple([\"\", ln]));\n        return i;\n      }\n\n      return -1;\n    }\n  };\n\n  __SinkParser.prototype.object = function (str, i, res) {\n    var j = this.subject(str, i, res);\n\n    if (j >= 0) {\n      return j;\n    } else {\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        return -1;\n      } else {\n        var i = j;\n      }\n\n      var delim = null;\n      var ch = str.charAt(i);\n\n      if (ch == \"\\\"\" || ch == \"'\") {\n        if (str.slice(i, i + 3 == ch + ch)) {\n          delim = ch + ch + ch;\n        } else {\n          delim = ch;\n        }\n\n        var i = i + pyjslib_len(delim);\n        var pairFudge = this.strconst(str, i, delim);\n        var j = pairFudge[0];\n        var s = pairFudge[1];\n        res.push(this._store.literal(s));\n        diag_progress(\"New string const \", s, j);\n        return j;\n      } else {\n        return -1;\n      }\n    }\n  };\n\n  __SinkParser.prototype.nodeOrLiteral = function (str, i, res) {\n    var j = this.node(str, i, res);\n\n    if (j >= 0) {\n      return j;\n    } else {\n      var j = this.skipSpace(str, i);\n\n      if (j < 0) {\n        return -1;\n      } else {\n        var i = j;\n      }\n\n      var ch = str.charAt(i);\n\n      if (\"-+0987654321\".indexOf(ch) >= 0) {\n        datetime_syntax.lastIndex = 0;\n        var m = datetime_syntax.exec(str.slice(i));\n\n        if (m != null) {\n          // j =  ( i + datetime_syntax.lastIndex ) ;\n          var val = m[0];\n          j = i + val.length;\n\n          if (val.indexOf(\"T\") >= 0) {\n            res.push(this._store.literal(val, undefined, this._store.sym(DATETIME_DATATYPE)));\n          } else {\n            res.push(this._store.literal(val, undefined, this._store.sym(DATE_DATATYPE)));\n          }\n        } else {\n          number_syntax.lastIndex = 0;\n          var m = number_syntax.exec(str.slice(i));\n\n          if (m == null) {\n            throw BadSyntax(this._thisDoc, this.lines, str, i, \"Bad number or date syntax\");\n          }\n\n          j = i + number_syntax.lastIndex;\n          var val = str.slice(i, j);\n\n          if (val.indexOf(\"e\") >= 0) {\n            res.push(this._store.literal(parseFloat(val), undefined, this._store.sym(FLOAT_DATATYPE)));\n          } else if (str.slice(i, j).indexOf(\".\") >= 0) {\n            res.push(this._store.literal(parseFloat(val), undefined, this._store.sym(DECIMAL_DATATYPE)));\n          } else {\n            res.push(this._store.literal(parseInt(val), undefined, this._store.sym(INTEGER_DATATYPE)));\n          }\n        }\n\n        ;\n        return j; // Where we have got up to\n      }\n\n      if (str.charAt(i) == \"\\\"\") {\n        if (str.slice(i, i + 3) == \"\\\"\\\"\\\"\") {\n          var delim = \"\\\"\\\"\\\"\";\n        } else {\n          var delim = \"\\\"\";\n        }\n\n        var i = i + pyjslib_len(delim);\n        var dt = null;\n        var pairFudge = this.strconst(str, i, delim);\n        var j = pairFudge[0];\n        var s = pairFudge[1];\n        var lang = null;\n\n        if (str.slice(j, j + 1) == \"@\") {\n          langcode.lastIndex = 0;\n          var m = langcode.exec(str.slice(j + 1));\n\n          if (m == null) {\n            throw BadSyntax(this._thisDoc, startline, str, i, \"Bad language code syntax on string literal, after @\");\n          }\n\n          var i = langcode.lastIndex + j + 1;\n          var lang = str.slice(j + 1, i);\n          var j = i;\n        }\n\n        if (str.slice(j, j + 2) == \"^^\") {\n          var res2 = new pyjslib_List([]);\n          var j = this.uri_ref2(str, j + 2, res2);\n          var dt = res2[0];\n        }\n\n        res.push(this._store.literal(s, lang, dt));\n        return j;\n      } else {\n        return -1;\n      }\n    }\n  };\n\n  __SinkParser.prototype.strconst = function (str, i, delim) {\n    /*\n    parse an N3 string constant delimited by delim.\n    return index, val\n    */\n    var j = i;\n    var ustr = \"\";\n    var startline = this.lines;\n\n    while (j < pyjslib_len(str)) {\n      var i = j + pyjslib_len(delim);\n\n      if (str.slice(j, i) == delim) {\n        return new pyjslib_Tuple([i, ustr]);\n      }\n\n      if (str.charAt(j) == \"\\\"\") {\n        var ustr = ustr + \"\\\"\";\n        var j = j + 1;\n        continue;\n      }\n\n      interesting.lastIndex = 0;\n      var m = interesting.exec(str.slice(j));\n\n      if (!m) {\n        throw BadSyntax(this._thisDoc, startline, str, j, \"Closing quote missing in string at ^ in \" + str.slice(j - 20, j) + \"^\" + str.slice(j, j + 20));\n      }\n\n      var i = j + interesting.lastIndex - 1;\n      var ustr = ustr + str.slice(j, i);\n      var ch = str.charAt(i);\n\n      if (ch == \"\\\"\") {\n        var j = i;\n        continue;\n      } else if (ch == \"\\r\") {\n        var j = i + 1;\n        continue;\n      } else if (ch == \"\\n\") {\n        if (delim == \"\\\"\") {\n          throw BadSyntax(this._thisDoc, startline, str, i, \"newline found in string literal\");\n        }\n\n        this.lines = this.lines + 1;\n        var ustr = ustr + ch;\n        var j = i + 1;\n        this.previousLine = this.startOfLine;\n        this.startOfLine = j;\n      } else if (ch == \"\\\\\") {\n        var j = i + 1;\n        var ch = str.slice(j, j + 1);\n\n        if (!ch) {\n          throw BadSyntax(this._thisDoc, startline, str, i, \"unterminated string literal (2)\");\n        }\n\n        var k = string_find(\"abfrtvn\\\\\\\"\", ch);\n\n        if (k >= 0) {\n          var uch = \"\\a\\b\\f\\r\\t\\v\\n\\\\\\\"\".charAt(k);\n          var ustr = ustr + uch;\n          var j = j + 1;\n        } else if (ch == \"u\") {\n          var pairFudge = this.uEscape(str, j + 1, startline);\n          var j = pairFudge[0];\n          var ch = pairFudge[1];\n          var ustr = ustr + ch;\n        } else if (ch == \"U\") {\n          var pairFudge = this.UEscape(str, j + 1, startline);\n          var j = pairFudge[0];\n          var ch = pairFudge[1];\n          var ustr = ustr + ch;\n        } else {\n          throw BadSyntax(this._thisDoc, this.lines, str, i, \"bad escape\");\n        }\n      }\n    }\n\n    throw BadSyntax(this._thisDoc, this.lines, str, i, \"unterminated string literal\");\n  };\n\n  __SinkParser.prototype.uEscape = function (str, i, startline) {\n    var j = i;\n    var count = 0;\n    var value = 0;\n\n    while (count < 4) {\n      var chFudge = str.slice(j, j + 1);\n      var ch = chFudge.toLowerCase();\n      var j = j + 1;\n\n      if (ch == \"\") {\n        throw BadSyntax(this._thisDoc, startline, str, i, \"unterminated string literal(3)\");\n      }\n\n      var k = string_find(\"0123456789abcdef\", ch);\n\n      if (k < 0) {\n        throw BadSyntax(this._thisDoc, startline, str, i, \"bad string literal hex escape\");\n      }\n\n      var value = value * 16 + k;\n      var count = count + 1;\n    }\n\n    var uch = String.fromCharCode(value);\n    return new pyjslib_Tuple([j, uch]);\n  };\n\n  __SinkParser.prototype.UEscape = function (str, i, startline) {\n    var j = i;\n    var count = 0;\n    var value = \"\\\\U\";\n\n    while (count < 8) {\n      var chFudge = str.slice(j, j + 1);\n      var ch = chFudge.toLowerCase();\n      var j = j + 1;\n\n      if (ch == \"\") {\n        throw BadSyntax(this._thisDoc, startline, str, i, \"unterminated string literal(3)\");\n      }\n\n      var k = string_find(\"0123456789abcdef\", ch);\n\n      if (k < 0) {\n        throw BadSyntax(this._thisDoc, startline, str, i, \"bad string literal hex escape\");\n      }\n\n      var value = value + ch;\n      var count = count + 1;\n    }\n\n    var uch = stringFromCharCode(\"0x\" + pyjslib_slice(value, 2, 10) - 0);\n    return new pyjslib_Tuple([j, uch]);\n  };\n\n  function OLD_BadSyntax(uri, lines, str, i, why) {\n    return new __OLD_BadSyntax(uri, lines, str, i, why);\n  }\n\n  function __OLD_BadSyntax(uri, lines, str, i, why) {\n    this._str = str.encode(\"utf-8\");\n    this._str = str;\n    this._i = i;\n    this._why = why;\n    this.lines = lines;\n    this._uri = uri;\n  }\n\n  __OLD_BadSyntax.prototype.toString = function () {\n    var str = this._str;\n    var i = this._i;\n    var st = 0;\n\n    if (i > 60) {\n      var pre = \"...\";\n      var st = i - 60;\n    } else {\n      var pre = \"\";\n    }\n\n    if (pyjslib_len(str) - i > 60) {\n      var post = \"...\";\n    } else {\n      var post = \"\";\n    }\n\n    return \"Line %i of <%s>: Bad syntax (%s) at ^ in:\\n\\\"%s%s^%s%s\\\"\" % new pyjslib_Tuple([this.lines + 1, this._uri, this._why, pre, str.slice(st, i), str.slice(i, i + 60), post]);\n  };\n\n  function BadSyntax(uri, lines, str, i, why) {\n    var lineNo = lines + 1;\n    var msg = \"Line \" + lineNo + \" of <\" + uri + \">: Bad syntax: \" + why + \"\\nat: \\\"\" + str.slice(i, i + 30) + \"\\\"\";\n    var e = new SyntaxError(msg, uri, lineNo);\n    e.lineNo = lineNo;\n    e.characterInFile = i;\n    e.syntaxProblem = why;\n    return e;\n  }\n\n  function stripCR(str) {\n    var res = \"\";\n\n    var __ch = new pyjslib_Iterator(str);\n\n    try {\n      while (true) {\n        var ch = __ch.next();\n\n        if (ch != \"\\r\") {\n          var res = res + ch;\n        }\n      }\n    } catch (e) {\n      if (e != StopIteration) {\n        throw e;\n      }\n    }\n\n    return res;\n  }\n\n  function dummyWrite(x) {}\n\n  return SinkParser;\n})();","map":null,"metadata":{},"sourceType":"module"}