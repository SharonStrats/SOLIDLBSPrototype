{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _require = require('./nodeMap'),\n    createNodeMap = _require.createNodeMap;\n\nvar _require2 = require('./context'),\n    isKeyword = _require2.isKeyword;\n\nvar graphTypes = require('./graphTypes');\n\nvar types = require('./types');\n\nvar util = require('./util');\n\nvar _require3 = require('./constants'),\n    RDF_FIRST = _require3.RDF_FIRST,\n    RDF_REST = _require3.RDF_REST,\n    RDF_NIL = _require3.RDF_NIL,\n    RDF_TYPE = _require3.RDF_TYPE,\n    RDF_LANGSTRING = _require3.RDF_LANGSTRING,\n    XSD_BOOLEAN = _require3.XSD_BOOLEAN,\n    XSD_DOUBLE = _require3.XSD_DOUBLE,\n    XSD_INTEGER = _require3.XSD_INTEGER,\n    XSD_STRING = _require3.XSD_STRING;\n\nvar _require4 = require('./url'),\n    _isAbsoluteIri = _require4.isAbsolute;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\n\napi.toRDF = function (input, options) {\n  // create node map for default graph (and any named graphs)\n  var issuer = new util.IdentifierIssuer('_:b');\n  var nodeMap = {\n    '@default': {}\n  };\n  createNodeMap(input, nodeMap, '@default', issuer);\n  var dataset = [];\n  var graphNames = Object.keys(nodeMap).sort();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = graphNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var graphName = _step.value;\n      var graphTerm = void 0;\n\n      if (graphName === '@default') {\n        graphTerm = {\n          termType: 'DefaultGraph',\n          value: ''\n        };\n      } else if (_isAbsoluteIri(graphName)) {\n        if (graphName.startsWith('_:')) {\n          graphTerm = {\n            termType: 'BlankNode'\n          };\n        } else {\n          graphTerm = {\n            termType: 'NamedNode'\n          };\n        }\n\n        graphTerm.value = graphName;\n      } else {\n        // skip relative IRIs (not valid RDF)\n        continue;\n      }\n\n      _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return dataset;\n};\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\n\n\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  var ids = Object.keys(graph).sort();\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = ids[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var id = _step2.value;\n      var node = graph[id];\n      var properties = Object.keys(node).sort();\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var property = _step3.value;\n          var items = node[property];\n\n          if (property === '@type') {\n            property = RDF_TYPE;\n          } else if (isKeyword(property)) {\n            continue;\n          }\n\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = items[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var item = _step4.value;\n              // RDF subject\n              var subject = {\n                termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n                value: id\n              }; // skip relative IRI subjects (not valid RDF)\n\n              if (!_isAbsoluteIri(id)) {\n                continue;\n              } // RDF predicate\n\n\n              var predicate = {\n                termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n                value: property\n              }; // skip relative IRI predicates (not valid RDF)\n\n              if (!_isAbsoluteIri(property)) {\n                continue;\n              } // skip blank node predicates unless producing generalized RDF\n\n\n              if (predicate.termType === 'BlankNode' && !options.produceGeneralizedRdf) {\n                continue;\n              } // convert list, value or node object to triple\n\n\n              var object = _objectToRDF(item, issuer, dataset, graphTerm); // skip null objects (they are relative IRIs)\n\n\n              if (object) {\n                dataset.push({\n                  subject: subject,\n                  predicate: predicate,\n                  object: object,\n                  graph: graphTerm\n                });\n              }\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\n\n\nfunction _listToRDF(list, issuer, dataset, graphTerm) {\n  var first = {\n    termType: 'NamedNode',\n    value: RDF_FIRST\n  };\n  var rest = {\n    termType: 'NamedNode',\n    value: RDF_REST\n  };\n  var nil = {\n    termType: 'NamedNode',\n    value: RDF_NIL\n  };\n  var last = list.pop(); // Result is the head of the list\n\n  var result = last ? {\n    termType: 'BlankNode',\n    value: issuer.getId()\n  } : nil;\n  var subject = result;\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = list[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var item = _step5.value;\n\n      var _object = _objectToRDF(item, issuer, dataset, graphTerm);\n\n      var next = {\n        termType: 'BlankNode',\n        value: issuer.getId()\n      };\n      dataset.push({\n        subject: subject,\n        predicate: first,\n        object: _object,\n        graph: graphTerm\n      });\n      dataset.push({\n        subject: subject,\n        predicate: rest,\n        object: next,\n        graph: graphTerm\n      });\n      subject = next;\n    } // Tail of list\n\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  if (last) {\n    var object = _objectToRDF(last, issuer, dataset, graphTerm);\n\n    dataset.push({\n      subject: subject,\n      predicate: first,\n      object: object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject: subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\n\n\nfunction _objectToRDF(item, issuer, dataset, graphTerm) {\n  var object = {}; // convert value object to RDF\n\n  if (graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    var value = item['@value'];\n    var datatype = item['@type'] || null; // convert to XSD datatypes as appropriate\n\n    if (types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if (!types.isDouble(value)) {\n        value = parseFloat(value);\n      } // canonical double representation\n\n\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if (types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if ('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if (graphTypes.isList(item)) {\n    var _list = _listToRDF(item['@list'], issuer, dataset, graphTerm);\n\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    var id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  } // skip relative IRIs, not valid RDF\n\n\n  if (object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n\n  return object;\n}","map":null,"metadata":{},"sourceType":"script"}