{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\SoDiAl\\\\Documents\\\\WebDev2019\\\\SolidReactTest\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/**\n * Local dependencies\n */\nvar CryptoKey = require('./keys/CryptoKey');\n\nvar CryptoKeyPair = require('./keys/CryptoKeyPair');\n\nvar JsonWebKey = require('./keys/JsonWebKey');\n\nvar recognizedKeyUsages = require('./keys/recognizedKeyUsages');\n\nvar supportedAlgorithms = require('./algorithms');\n\nvar _require = require('./errors'),\n    InvalidAccessError = _require.InvalidAccessError,\n    NotSupportedError = _require.NotSupportedError;\n\nvar _require2 = require('text-encoding'),\n    TextEncoder = _require2.TextEncoder,\n    TextDecoder = _require2.TextDecoder;\n/**\n * SubtleCrypto\n */\n\n\nvar SubtleCrypto =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function SubtleCrypto() {\n    _classCallCheck(this, SubtleCrypto);\n  }\n\n  _createClass(SubtleCrypto, [{\n    key: \"encrypt\",\n\n    /**\n     * encrypt\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} key\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n    value: function encrypt(algorithm, key, data) {\n      data = data.slice();\n      var normalizedAlgorithm = supportedAlgorithms.normalize('encrypt', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        if (normalizedAlgorithm.name !== key.algorithm.name) {\n          throw new InvalidAccessError('Algorithm does not match key');\n        }\n\n        if (!key.usages.includes('encrypt')) {\n          throw new InvalidAccessError('Key usages must include \"encrypt\"');\n        }\n\n        var ciphertext = normalizedAlgorithm.encrypt(algorithm, key, data);\n        resolve(ciphertext);\n      });\n    }\n    /**\n     * decrypt\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} key\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(algorithm, key, data) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('decrypt', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      data = data.slice();\n      return new Promise(function (resolve, reject) {\n        if (normalizedAlgorithm.name !== key.algorithm.name) {\n          throw new InvalidAccessError('Algorithm does not match key');\n        }\n\n        if (!key.usages.includes('decrypt')) {\n          throw new InvalidAccessError('Key usages must include \"decrypt\"');\n        }\n\n        var plaintext = normalizedAlgorithm.decrypt(algorithm, key, data);\n        resolve(plaintext);\n      });\n    }\n    /**\n     * sign\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} key\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(algorithm, key, data) {\n      data = data.slice();\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        if (normalizedAlgorithm.name !== key.algorithm.name) {\n          throw new InvalidAccessError('Algorithm does not match key');\n        }\n\n        if (!key.usages.includes('sign')) {\n          throw new InvalidAccessError('Key usages must include \"sign\"');\n        }\n\n        var result = normalizedAlgorithm.sign(key, data);\n        resolve(result);\n      });\n    }\n    /**\n     * verify\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(alg, key, signature, data) {\n      signature = signature.slice();\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      data = data.slice();\n      return new Promise(function (resolve, reject) {\n        if (normalizedAlgorithm.name !== key.algorithm.name) {\n          throw new InvalidAccessError('Algorithm does not match key');\n        }\n\n        if (!key.usages.includes('verify')) {\n          throw new InvalidAccessError('Key usages must include \"verify\"');\n        }\n\n        var result = normalizedAlgorithm.verify(key, signature, data);\n        resolve(result);\n      });\n    }\n    /**\n     * digest\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {BufferSource} data\n     *\n     * @returns {Promise.<ArrayBuffer>}\n     */\n\n  }, {\n    key: \"digest\",\n    value: function digest(algorithm, data) {\n      data = data.slice();\n      var normalizedAlgorithm = supportedAlgorithms.normalize('digest', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        try {\n          var result = normalizedAlgorithm.digest(algorithm, data);\n          return resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * generateKey\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {Boolean} extractable\n     * @param {Array} keyUsages\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"generateKey\",\n    value: function generateKey(algorithm, extractable, keyUsages) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('generateKey', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        try {\n          var result = normalizedAlgorithm.generateKey(algorithm, extractable, keyUsages);\n\n          if (result instanceof CryptoKey) {\n            var type = result.type,\n                usages = result.usages;\n            var restricted = type === 'secret' || type === 'private';\n            var emptyUsages = !usages || usages.length === 0;\n\n            if (restricted && emptyUsages) {\n              throw new SyntaxError();\n            }\n          }\n\n          if (result instanceof CryptoKeyPair) {\n            var _usages = result.privateKey.usages;\n\n            if (!_usages || _usages.length === 0) {\n              throw new SyntaxError();\n            }\n          }\n\n          resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * deriveKey\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} baseKey\n     * @param {AlgorithmIdentifier} derivedKeyType\n     * @param {Boolean} extractable\n     * @param {Array} keyUsages\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"deriveKey\",\n    value: function deriveKey(algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\n      return new Promise();\n    }\n    /**\n     * deriveBits\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} baseKey\n     * @param {number} length\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"deriveBits\",\n    value: function deriveBits(algorithm, baseKey, length) {\n      return new Promise();\n    }\n    /**\n     * importKey\n     *\n     * @description\n     *\n     * @param {KeyFormat} format\n     * @param {BufferSource|JWK} keyData\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {Boolean} extractable\n     * @param {Array} keyUsages\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"importKey\",\n    value: function importKey(format, keyData, algorithm, extractable, keyUsages) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        if (format === 'raw' || format === 'pkcs8' || format === 'spki') {\n          if (keyData instanceof JsonWebKey) {\n            throw new TypeError();\n          }\n\n          keyData = keyData.slice();\n        }\n\n        if (format === 'jwk') {\n          keyData = new JsonWebKey(keyData);\n\n          if (!(keyData instanceof JsonWebKey)) {\n            throw new TypeError('key is not a JSON Web Key');\n          }\n        }\n\n        try {\n          var result = normalizedAlgorithm.importKey(format, keyData, algorithm, extractable, keyUsages);\n\n          if (result.type === 'secret' || result.type === 'private') {\n            if (!result.usages || result.usages.length === 0) {\n              throw new SyntaxError();\n            }\n          }\n\n          result.extractable = extractable;\n          result.usages = recognizedKeyUsages.normalize(keyUsages);\n          resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * exportKey\n     *\n     * @description\n     *\n     * @param {KeyFormat} format\n     * @param {CryptoKey} key\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"exportKey\",\n    value: function exportKey(format, key) {\n      return new Promise(function (resolve, reject) {\n        try {\n          var registeredAlgorithms = supportedAlgorithms['exportKey'];\n\n          if (!registeredAlgorithms[key.algorithm.name]) {\n            throw new NotSupportedError(key.algorithm.name);\n          }\n\n          if (key.extractable === false) {\n            throw new InvalidAccessError('Key is not extractable');\n          }\n\n          var result = key.algorithm.exportKey(format, key);\n          resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * wrapKey\n     *\n     * @description\n     *\n     * @param {KeyFormat} format\n     * @param {CryptoKey} key\n     * @param {CryptoKey} wrappingKey\n     * @param {AlgorithmIdentifier} wrapAlgorithm\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"wrapKey\",\n    value: function wrapKey(format, key, wrappingKey, wrapAlgorithm) {\n      var _this = this;\n\n      // 1. Parameters\n      // 2. Setup normalizedAlgorithm with op as 'unwrap'\n      var normalizedAlgorithm = supportedAlgorithms.normalize('wrapKey', wrapAlgorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        // 3. If failed, then try again with op as 'encrypt'\n        normalizedAlgorithm = supportedAlgorithms.normalize('encrypt', wrapAlgorithm);\n      } // 4. Otherwise reject outright\n\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      } // 5-6. Setup and asynchronously return a new promise\n\n\n      return new Promise(function (resolve, reject) {\n        // 7. Try catch the following step...\n        // if anything goes wrong then reject the promise outright\n        try {\n          // 8. Validate normalizedAlgorithm name property\n          if (normalizedAlgorithm.name !== wrappingKey.algorithm.name) {\n            throw new InvalidAccessError('NormalizedAlgorthm name must be same as wrappingKey algorithm name');\n          } // 9. Validate usages property contains wrap\n\n\n          if (!wrappingKey.usages.includes('wrapKey')) {\n            throw new InvalidAccessError('Wrapping key usages must include \"wrapKey\"');\n          } // 10. Validate algorithm contains exportKey\n\n\n          var exportKeyAlgorithms = supportedAlgorithms['exportKey'];\n\n          if (!exportKeyAlgorithms[key.algorithm.name]) {\n            throw new NotSupportedError(key.algorithm.name);\n          } // 11. Validate extractable property\n\n\n          if (key.extractable === false) {\n            throw new InvalidAccessError('Key is not extractable');\n          } // 12. Generate extracted key\n\n\n          return _this.exportKey(format, key).then(function (exportedKey) {\n            var bytes; // 13.1. If format is \"raw\", \"pkcs8\", or \"spki\":\n\n            if ([\"raw\", \"pkcs8\", \"spki\"].includes(format)) {\n              bytes = exportedKey;\n            } // 13.2. If format is \"jwk\"\n            else if (format === \"jwk\") {\n                var json = JSON.stringify(exportedKey);\n                bytes = new TextEncoder().encode(json);\n              } // 14.1. If the normalizedAlgorithm supports wrapKey then use it\n\n\n            if (normalizedAlgorithm['wrapKey']) {\n              return normalizedAlgorithm.wrapKey(format, bytes, wrappingKey, wrapAlgorithm);\n            } // 14.2. Otherwise try with encrypt\n            else if (normalizedAlgorithm['encrypt']) {\n                return normalizedAlgorithm.encrypt(wrapAlgorithm, wrappingKey, new Uint8Array(bytes));\n              } // 14.3. Otherwise throw error\n              else {\n                  return reject(new NotSupportedError(normalizedAlgorithm.name));\n                }\n          }) // 15. Return the resulting promise\n          .then(resolve);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * unwrapKey\n     *\n     * @description\n     *\n     * @param {KeyFormat} format\n     * @param {BufferSource} wrappedKey\n     * @param {CryptoKey} unwrappingKey\n     * @param {AlgorithmIdentifier} unwrapAlgorithm\n     * @param {AlgorithmIdentifier} unwrappedKeyAlgorithm\n     * @param {Boolean} extractable\n     * @param {Array} keyUsages\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"unwrapKey\",\n    value: function unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\n      // 1. Parameters\n      // 2. Ommited due to redundancy\n      // 3. Setup normalizedAlgorithm with op as 'unwrap'\n      var normalizedAlgorithm = supportedAlgorithms.normalize('unwrapKey', unwrapAlgorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        // 4. If failed, then try again with op as 'encrypt'\n        normalizedAlgorithm = supportedAlgorithms.normalize('decrypt', unwrapAlgorithm);\n      } // 5. Otherwise reject outright\n\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      } // 6. Setup normalizedKeyAlgorithm\n\n\n      var normalizedKeyAlgorithm = supportedAlgorithms.normalize('importKey', unwrappedKeyAlgorithm);\n\n      if (normalizedKeyAlgorithm instanceof Error) {\n        // 7. If failed, then try again with op as 'encrypt'\n        return Promise.reject(normalizedKeyAlgorithm);\n      } // 8-9. Setup and asynchronously return a new promise\n\n\n      return new Promise(function (resolve, reject) {\n        // 10. Try catch the following step...\n        // if anything goes wrong then reject the promise outright\n        try {\n          // 11. Validate normalizedAlgorithm name property\n          if (normalizedAlgorithm.name !== unwrappingKey.algorithm.name) {\n            throw new InvalidAccessError('NormalizedAlgorthm name must be same as unwrappingKey algorithm name');\n          } // 12. Validate usages property contains unwrap\n\n\n          if (!unwrappingKey.usages.includes('unwrapKey')) {\n            throw new InvalidAccessError('Unwrapping key usages must include \"unwrapKey\"');\n          }\n\n          var key; // 13.1. If the normalizedAlgorithm supports unwrapKey then use it\n\n          if (normalizedAlgorithm['unwrapKey']) {\n            key = normalizedAlgorithm.unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages);\n          } // 13.2. Otherwise try with decrypt\n          else if (normalizedAlgorithm['decrypt']) {\n              key = normalizedAlgorithm.decrypt(unwrapAlgorithm, unwrappingKey, wrappedKey);\n            } // 13.3. Otherwise throw error\n            else {\n                return reject(new NotSupportedError(normalizedAlgorithm.name));\n              }\n\n          var bytes; // 14.1. If format is \"raw\", \"pkcs8\", or \"spki\":\n\n          if ([\"raw\", \"pkcs8\", \"spki\"].includes(format)) {\n            bytes = key;\n          } // 14.2. If format is \"jwk\"\n          else if (format === \"jwk\") {\n              bytes = JSON.parse(new TextDecoder().decode(key));\n            } // 15. Import the resulting unwrapped content\n          // 16-18. Ommitted because it is handled by importKey interface\n\n\n          var result = normalizedKeyAlgorithm.importKey(format, bytes, unwrappedKeyAlgorithm, extractable, keyUsages); // 19. Resolve the result\n\n          return resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n  }]);\n\n  return SubtleCrypto;\n}();\n/**\n * Export\n */\n\n\nmodule.exports = SubtleCrypto;","map":null,"metadata":{},"sourceType":"script"}