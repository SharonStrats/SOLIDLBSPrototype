"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parse;

var _blankNode = _interopRequireDefault(require("./blank-node"));

var _dataFactory = _interopRequireDefault(require("./data-factory"));

var _jsonld = _interopRequireDefault(require("jsonld"));

var _literal = _interopRequireDefault(require("./literal"));

var _n = require("n3");

var _n3parser = _interopRequireDefault(require("./n3parser"));

var _namedNode = _interopRequireDefault(require("./named-node"));

var _rdfaparser = require("./rdfaparser");

var _rdfxmlparser = _interopRequireDefault(require("./rdfxmlparser"));

var _patchParser = _interopRequireDefault(require("./patch-parser"));

var Util = _interopRequireWildcard(require("./util"));

// @@ Goal: remove this dependency

/**
 * Parse a string and put the result into the graph kb.
 * Normal method is sync.
 * Unfortunately jsdonld is currently written to need to be called async.
 * Hence the mess below with executeCallback.
 */
function parse(str, kb, base, contentType, callback) {
  contentType = contentType || 'text/turtle';
  contentType = contentType.split(';')[0];

  try {
    if (contentType === 'text/n3' || contentType === 'text/turtle') {
      var p = (0, _n3parser.default)(kb, kb, base, base, null, null, '', null);
      p.loadBuf(str);
      executeCallback();
    } else if (contentType === 'application/rdf+xml') {
      var parser = new _rdfxmlparser.default(kb);
      parser.parse(Util.parseXML(str), base, kb.sym(base));
      executeCallback();
    } else if (contentType === 'application/xhtml+xml') {
      (0, _rdfaparser.parseRDFaDOM)(Util.parseXML(str, {
        contentType: 'application/xhtml+xml'
      }), kb, base);
      executeCallback();
    } else if (contentType === 'text/html') {
      (0, _rdfaparser.parseRDFaDOM)(Util.parseXML(str, {
        contentType: 'text/html'
      }), kb, base);
      executeCallback();
    } else if (contentType === 'application/sparql-update') {
      // @@ we handle a subset
      (0, _patchParser.default)(str, kb, base);
      executeCallback();
    } else if (contentType === 'application/ld+json' || contentType === 'application/nquads' || contentType === 'application/n-quads') {
      var n3Parser = new _n.Parser({
        factory: _dataFactory.default
      });
      var triples = [];

      if (contentType === 'application/ld+json') {
        var jsonDocument;

        try {
          jsonDocument = JSON.parse(str);
        } catch (parseErr) {
          return callback(parseErr, null);
        }

        _jsonld.default.toRDF(jsonDocument, {
          format: 'application/nquads',
          base: base
        }, nquadCallback);
      } else {
        nquadCallback(null, str);
      }
    } else {
      throw new Error("Don't know how to parse " + contentType + ' yet');
    }
  } catch (e) {
    executeErrorCallback(e);
  }

  parse.handled = {
    'text/n3': true,
    'text/turtle': true,
    'application/rdf+xml': true,
    'application/xhtml+xml': true,
    'text/html': true,
    'application/sparql-update': true,
    'application/ld+json': true,
    'application/nquads': true,
    'application/n-quads': true
  };

  function executeCallback() {
    if (callback) {
      callback(null, kb);
    } else {
      return;
    }
  }

  function executeErrorCallback(e) {
    if (contentType !== 'application/ld+json' || contentType !== 'application/nquads' || contentType !== 'application/n-quads') {
      if (callback) {
        callback(e, kb);
      } else {
        var e2 = new Error('' + e + ' while trying to parse <' + base + '> as ' + contentType);
        e2.cause = e;
        throw e2;
      }
    }
  }
  /*
    function setJsonLdBase (doc, base) {
      if (doc instanceof Array) {
        return
      }
      if (!('@context' in doc)) {
        doc['@context'] = {}
      }
      doc['@context']['@base'] = base
    }
  */


  function nquadCallback(err, nquads) {
    if (err) {
      callback(err, kb);
    }

    try {
      n3Parser.parse(nquads, tripleCallback);
    } catch (err) {
      callback(err, kb);
    }
  }

  function tripleCallback(err, triple, prefixes) {
    if (triple) {
      kb.add(triple);
    } else {
      callback(err, kb);
    }
  }
}