'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _node = _interopRequireDefault(require("./node"));

var Statement =
/*#__PURE__*/
function () {
  /* Construct a new statment
  **
  ** @param {Term} subject - The subject of the triple.  What the efact is about
  ** @ param {Term} predciate - The relationship which is assrted between the subject and object
  ** @param {Term} object - The thing or data value which is asserted to be related to the subject
  ** @param {NamedNode} why - The document where thr triple is or was or will be stored on the web.
  **
  ** The why param is a named node of the document in which the triple when
  ** it is stored on the web.
  ** It is called “why” because when you have read data from varou slaces the
  **  “why” tells you why you have the triple. (At the moment, it is just the
  ** document, in future it could be an inference step). When you do
  ** UpdateManager.update() then the why’s of all the statmemts must be the same,
  ** and give the document you are patching. In future, we may have a more
  ** powerful update() which can update more than one docment.
  */
  function Statement(subject, predicate, object, graph) {
    (0, _classCallCheck2.default)(this, Statement);
    this.subject = _node.default.fromValue(subject);
    this.predicate = _node.default.fromValue(predicate);
    this.object = _node.default.fromValue(object);
    this.why = graph; // property currently used by rdflib
  }

  (0, _createClass2.default)(Statement, [{
    key: "equals",
    value: function equals(other) {
      return other.subject.equals(this.subject) && other.predicate.equals(this.predicate) && other.object.equals(this.object) && other.graph.equals(this.graph);
    }
  }, {
    key: "substitute",
    value: function substitute(bindings) {
      var y = new Statement(this.subject.substitute(bindings), this.predicate.substitute(bindings), this.object.substitute(bindings), this.why.substitute(bindings)); // 2016

      console.log('@@@ statement substitute:' + y);
      return y;
    }
  }, {
    key: "toCanonical",
    value: function toCanonical() {
      var terms = [this.subject.toCanonical(), this.predicate.toCanonical(), this.object.toCanonical()];

      if (this.graph && this.graph.termType !== 'DefaultGraph') {
        terms.push(this.graph.toCanonical());
      }

      return terms.join(' ') + ' .';
    }
  }, {
    key: "toNT",
    value: function toNT() {
      return [this.subject.toNT(), this.predicate.toNT(), this.object.toNT()].join(' ') + ' .';
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.toNT();
    }
  }, {
    key: "graph",
    get: function get() {
      return this.why;
    },
    set: function set(g) {
      this.why = g;
    }
  }]);
  return Statement;
}();

exports.default = Statement;