"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_sparql_serialize_1 = require("@comunica/bus-sparql-serialize");
const core_1 = require("@comunica/core");
const immutable_1 = require("immutable");
const sparqljson_to_tree_1 = require("sparqljson-to-tree");
const stream_1 = require("stream");
var isMap = immutable_1.Map.isMap;
/**
 * A comunica Tree SPARQL Serialize Actor.
 */
class ActorSparqlSerializeTree extends bus_sparql_serialize_1.ActorSparqlSerializeFixedMediaTypes {
    constructor(args) {
        super(args);
    }
    /**
     *
     * @param {BindingsStream} bindingsStream
     * @param context
     * @param {IConverterSettings} converterSettings
     * @return {Promise<string>}
     */
    static bindingsStreamToGraphQl(bindingsStream, context, converterSettings) {
        const actionContext = isMap(context) ? context : core_1.ActionContext(context);
        return new Promise((resolve, reject) => {
            const bindingsArray = [];
            const converter = new sparqljson_to_tree_1.Converter(converterSettings);
            const schema = { singularizeVariables: {} };
            if (actionContext && actionContext.has('@context')) {
                for (const key of Object.keys(actionContext.get('@context'))) {
                    if (actionContext.get('@context')[key]['@singular']) {
                        schema.singularizeVariables[key] = true;
                    }
                }
            }
            bindingsStream.on('error', reject);
            bindingsStream.on('data', (bindings) => {
                const rawBindings = bindings.toJS();
                const reKeyedBindings = {};
                // Removes the '?' prefix
                for (const key in rawBindings) {
                    const bindingValue = rawBindings[key];
                    if (bindingValue) {
                        reKeyedBindings[key.substr(1)] = bindingValue;
                    }
                }
                bindingsArray.push(reKeyedBindings);
            });
            bindingsStream.on('end', () => {
                resolve(converter.bindingsToTree(bindingsArray, schema));
            });
        });
    }
    async testHandleChecked(action) {
        if (action.type !== 'bindings') {
            throw new Error('This actor can only handle bindings streams.');
        }
        return true;
    }
    async runHandle(action, mediaType) {
        const data = new stream_1.Readable();
        data._read = () => {
            return;
        };
        const resultStream = action.bindingsStream;
        resultStream.on('error', (e) => data.emit('error', e));
        ActorSparqlSerializeTree.bindingsStreamToGraphQl(resultStream, action.context, { materializeRdfJsTerms: true })
            .then((result) => {
            data.push(JSON.stringify(result, null, '  '));
            data.push(null);
        });
        return { data };
    }
}
exports.ActorSparqlSerializeTree = ActorSparqlSerializeTree;
//# sourceMappingURL=ActorSparqlSerializeTree.js.map