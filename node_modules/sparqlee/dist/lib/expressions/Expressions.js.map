{"version":3,"file":"Expressions.js","sourceRoot":"","sources":["../../../lib/expressions/Expressions.ts"],"names":[],"mappings":";;AAKA,IAAY,cAQX;AARD,WAAY,cAAc;IACxB,yCAAuB,CAAA;IACvB,yCAAuB,CAAA;IACvB,iCAAe,CAAA;IACf,uCAAqB,CAAA;IACrB,qDAAmC,CAAA;IACnC,+BAAa,CAAA;IACb,uCAAqB,CAAA;AACvB,CAAC,EARW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAQzB","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra } from 'sparqlalgebrajs';\n\nimport { Bindings } from '../Types';\n\nexport enum ExpressionType {\n  Aggregate = 'aggregate',\n  Existence = 'existence',\n  Named = 'named',\n  Operator = 'operator',\n  SpecialOperator = 'specialOperator',\n  Term = 'term',\n  Variable = 'variable',\n}\n\nexport type Expression =\n  AggregateExpression |\n  ExistenceExpression |\n  NamedExpression |\n  OperatorExpression |\n  SpecialOperatorExpression |\n  TermExpression |\n  VariableExpression;\n\nexport interface ExpressionProps {\n  expressionType: ExpressionType;\n}\n\nexport type AggregateExpression = ExpressionProps & {\n  expressionType: ExpressionType.Aggregate;\n  name: string;\n  expression: Algebra.AggregateExpression;\n  aggregate(): Promise<RDF.Term>;\n};\n\nexport type ExistenceExpression = ExpressionProps & {\n  expressionType: ExpressionType.Existence;\n  expression: Algebra.ExistenceExpression;\n  exists_with(mapping: Bindings): Promise<boolean>\n};\n\nexport type NamedExpression = ExpressionProps & {\n  expressionType: ExpressionType.Named;\n  name: RDF.NamedNode;\n  apply: SimpleApplication;\n  args: Expression[];\n};\n\n// export type Application = SimpleApplication | SpecialApplication;\nexport type SimpleApplication = (args: TermExpression[]) => TermExpression;\n\nexport type OperatorExpression = ExpressionProps & {\n  expressionType: ExpressionType.Operator;\n  args: Expression[];\n  apply: SimpleApplication;\n};\n\n// TODO: Move to Types.ts?\nexport type EvaluatorAsync = (expr: Expression, mapping: Bindings) => Promise<TermExpression>;\nexport type EvalContextAsync = { args: Expression[], mapping: Bindings, evaluate: EvaluatorAsync };\nexport type SpecialApplicationAsync = (context: EvalContextAsync) => Promise<TermExpression>;\n\nexport type EvaluatorSync = (expr: Expression, mapping: Bindings) => TermExpression;\nexport type EvalContextSync = { args: Expression[], mapping: Bindings, evaluate: EvaluatorSync };\nexport type SpecialApplicationSync = (context: EvalContextSync) => TermExpression;\n\nexport type SpecialOperatorExpression = ExpressionProps & {\n  expressionType: ExpressionType.SpecialOperator,\n  args: Expression[],\n  applyAsync: SpecialApplicationAsync,\n  applySync: SpecialApplicationSync,\n};\n\n// TODO: Create alias Term = TermExpression\nexport type TermType = 'namedNode' | 'literal' | 'blankNode';\nexport type TermExpression = ExpressionProps & {\n  expressionType: ExpressionType.Term;\n  termType: TermType;\n  str(): string;\n  coerceEBV(): boolean;\n  toRDF(): RDF.Term;\n};\n\nexport type VariableExpression = ExpressionProps & {\n  expressionType: ExpressionType.Variable;\n  name: string;\n};\n"]}