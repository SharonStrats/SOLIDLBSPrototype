"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const E = require("./expressions/Expressions");
const Err = require("./util/Errors");
const Transformation_1 = require("./Transformation");
class AsyncEvaluator {
    // TODO: Support passing functions to override default behaviour;
    constructor(algExpr, lookup, aggregator) {
        this.algExpr = algExpr;
        this.lookup = lookup;
        this.aggregator = aggregator;
        // tslint:disable-next-line:member-ordering
        this.evalLookup = {
            [E.ExpressionType.Term]: this.evalTerm.bind(this),
            [E.ExpressionType.Variable]: this.evalVariable,
            [E.ExpressionType.Operator]: this.evalOperator,
            [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,
            [E.ExpressionType.Named]: this.evalNamed,
            [E.ExpressionType.Existence]: this.evalExistence,
            [E.ExpressionType.Aggregate]: this.evalAggregate,
        };
        this.expr = Transformation_1.transformAlgebra(algExpr, aggregator);
    }
    async evaluate(mapping) {
        const result = await this.evalRecursive(this.expr, mapping);
        return log(result).toRDF();
    }
    async evaluateAsEBV(mapping) {
        const result = await this.evalRecursive(this.expr, mapping);
        return log(result).coerceEBV();
    }
    async evaluateAsInternal(mapping) {
        return this.evalRecursive(this.expr, mapping);
    }
    async evalRecursive(expr, mapping) {
        const evaluatorFunction = this.evalLookup[expr.expressionType];
        if (!evaluatorFunction) {
            throw new Err.InvalidExpressionType(expr);
        }
        return evaluatorFunction.bind(this)(expr, mapping);
    }
    async evalTerm(expr, mapping) {
        return expr;
    }
    async evalVariable(expr, mapping) {
        const term = mapping.get(expr.name);
        if (!term) {
            throw new Err.UnboundVariableError(expr.name, mapping);
        }
        return Transformation_1.transformTerm({
            term,
            type: 'expression',
            expressionType: 'term',
        });
    }
    async evalOperator(expr, mapping) {
        const argPromises = expr.args.map((arg) => this.evalRecursive(arg, mapping));
        const argResults = await Promise.all(argPromises);
        return expr.apply(argResults);
    }
    async evalSpecialOperator(expr, mapping) {
        const evaluate = this.evalRecursive.bind(this);
        const context = { args: expr.args, mapping, evaluate };
        return expr.apply(context);
    }
    async evalNamed(expr, mapping) {
        const argPromises = expr.args.map((arg) => this.evalRecursive(arg, mapping));
        const argResults = await Promise.all(argPromises);
        return expr.apply(argResults);
    }
    // TODO
    async evalExistence(expr, mapping) {
        throw new Err.UnimplementedError('Existence Operator');
    }
    // TODO
    async evalAggregate(expr, mapping) {
        const result = await expr.aggregate(mapping);
        return Transformation_1.transformTerm({
            type: 'expression',
            expressionType: 'term',
            term: result,
        });
    }
}
exports.AsyncEvaluator = AsyncEvaluator;
function log(val) {
    // console.log(val);
    return val;
}
//# sourceMappingURL=AsyncEvaluator.js.map