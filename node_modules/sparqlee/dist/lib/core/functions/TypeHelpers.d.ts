/**
 * These helpers provide a (albeit inflexible) DSL for writing function
 * definitions for the SPARQL functions.
 */
import { List, Record } from 'immutable';
import * as C from '../../util/Consts';
import * as E from '../Expressions';
import { ArgumentType, OverloadMap } from './RegularFunctions';
export declare function declare(): Builder;
export declare class Builder {
    private implementations;
    private arity;
    collect(): OverloadMap;
    withArity(arity: number): Builder;
    set(types: ArgumentType[], func: E.SimpleApplication): Builder;
    setBinary<L, R>(types: ArgumentType[], op: (left: L, right: R) => Term): Builder;
    setTernary<A1, A2, A3>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term): Builder;
    unimplemented(msg: string): Builder;
    log(): Builder;
    add(impl: Impl): Builder;
    onTerm1(op: (term: Term) => Term): Builder;
    onLiteral1<T>(op: (lit: E.Literal<T>) => Term): Builder;
    onString1(op: (lit: E.Literal<string>) => Term): Builder;
    arithmetic(op: (left: number, right: number) => number): Builder;
    numberTest(test: (left: number, right: number) => boolean): Builder;
    stringTest(test: (left: string, right: string) => boolean): Builder;
    booleanTest(test: (left: boolean, right: boolean) => boolean): Builder;
    dateTimeTest(test: (left: Date, right: Date) => boolean): Builder;
    numeric(opFac: OpFactory): Builder;
    invalidLexicalForm(types: ArgumentType[], index: number): Builder;
    private chain;
}
export declare function _impl(): ImplBuilder;
export declare class ImplBuilder {
    private types;
    private func;
    build(): Impl;
    withTypes(types: ArgumentType[]): ImplBuilder;
    arithmetic(func: (left: number, right: number) => E.NumericLiteral): ImplBuilder;
}
/**
 * Immutable.js type definitions are pretty unsafe, and this is typo-prone work.
 * These helpers allow use to create OverloadMaps with more type-safety.
 * One entry in the OverloadMap is described by the record Impl;
 *
 * A list of Impl's then gets constructed into an Immutable.js Map.
 *
 * See:
 * https://medium.com/@alexxgent/enforcing-types-with-immutablejs-and-typescript-6ab980819b6a
 */
export declare type ImplType = {
    types: ArgumentType[];
    func: E.SimpleApplication;
};
declare const Impl_base: Record.Class;
export declare class Impl extends Impl_base {
    constructor(params: ImplType);
    get<T extends keyof ImplType>(value: T): ImplType[T];
    toPair(): [List<ArgumentType>, E.SimpleApplication];
}
export declare function map(implementations: Impl[]): OverloadMap;
export declare function bool(val: boolean): E.BooleanLiteral;
export declare function number(num: number, dt?: C.TypeURL): E.NumericLiteral;
export declare function str(s: string): E.StringLiteral;
export declare function list(...args: ArgumentType[]): List<ArgumentType>;
declare type Term = E.TermExpression;
export declare function simple(types: ArgumentType[], func: E.SimpleApplication): OverloadMap;
export declare function forAll(allTypes: ArgumentType[][], func: E.SimpleApplication): OverloadMap;
export declare type ArithmeticOperator = (left: number, right: number) => number;
export declare function arithmetic(op: ArithmeticOperator): OverloadMap;
export declare type XPathTest<T> = (left: T, right: T) => boolean;
export declare function xPathTest(numOp: XPathTest<number>, strOp: XPathTest<string>, boolOp: XPathTest<boolean>, dateOp: XPathTest<Date>): OverloadMap;
export declare type OpFactory = (dt?: C.TypeURL) => E.SimpleApplication;
/**
 * DataType will be generalized to float,
 * or to the the category-parent (interger, decimal, ...) if both have the same.
 */
export declare function numeric(opFac: OpFactory): Impl[];
export declare type UnLiteralOp<T, R> = (val: T) => R;
export declare function unary<T, R>(op: UnLiteralOp<T, R>, args: E.TermExpression[]): R;
export declare type BinLiteralOp<T, R> = (left: T, right: T) => R;
export declare function binary<T, R>(op: BinLiteralOp<T, R>, args: E.TermExpression[]): R;
export {};
