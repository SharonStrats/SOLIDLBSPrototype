{"version":3,"file":"Helpers.js","sourceRoot":"","sources":["../../../../lib/core/functions/Helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\n\nimport { List, Map, Record } from 'immutable';\n\nimport * as C from '../../util/Consts';\nimport * as Err from '../../util/Errors';\nimport * as E from '../Expressions';\n\nimport { TypeURL as Type } from '../../util/Consts';\nimport { ArgumentType, OverloadMap } from './FunctionClasses';\n\ntype Term = E.TermExpression;\ntype OpFactory = (dt?: C.TypeURL) => E.SimpleApplication;\n\nexport function declare(): Builder {\n  return new Builder();\n}\n\nexport class Builder {\n  private implementations: Impl[] = [];\n\n  collect(): OverloadMap {\n    return map(this.implementations);\n  }\n\n  log(): Builder {\n    // tslint:disable-next-line:no-console\n    console.log(this.implementations);\n    return this;\n  }\n\n  add(impl: Impl): Builder {\n    this.implementations.push(impl);\n    return this;\n  }\n\n  set(argTypes: ArgumentType[], func: E.SimpleApplication): Builder {\n    const types = List(argTypes);\n    return this.add(new Impl({ types, func }));\n  }\n\n  copy({ from, to }: { from: ArgumentType[], to: ArgumentType[] }): Builder {\n    const last = this.implementations.length - 1;\n    const _from = List(from);\n    for (let i = last; i >= 0; i--) {\n      const impl = this.implementations[i];\n      if (impl.get('types').equals(_from)) {\n        return this.set(to, impl.get('func'));\n      }\n    }\n    throw new Err.UnexpectedError(\n      'Tried to copy implementation, but types not found',\n      { from, to });\n  }\n\n  setUnary<T extends Term>(type: ArgumentType, op: (val: T) => Term) {\n    return this.set([type], ([val]: [T]) => {\n      return op(val);\n    });\n  }\n\n  setLitUnary<T>(type: ArgumentType, op: (val: T) => Term) {\n    return this.set([type], ([val]: [E.Literal<T>]) => {\n      return op(val.typedValue);\n    });\n  }\n\n  setLitBinary<L, R>(types: ArgumentType[], op: (left: L, right: R) => Term) {\n    return this.set(types, ([left, right]: [E.Literal<L>, E.Literal<R>]) => {\n      return op(left.typedValue, right.typedValue);\n    });\n  }\n\n  setLitTernary<A1, A2, A3>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term) {\n    return this.set(types, ([a1, a2, a3]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>]) => {\n      return op(a1.typedValue, a2.typedValue, a3.typedValue);\n    });\n  }\n\n  unimplemented(msg: string): Builder {\n    for (let arity = 0; arity <= 5; arity++) {\n      const types = Array(arity).fill('term');\n      const func = (_args: Term[]) => { throw new Err.UnimplementedError(msg); };\n      this.set(types, func);\n    }\n    return this;\n  }\n\n  onTerm1(op: (term: Term) => Term): Builder {\n    return this.set(['term'], ([term]: [Term]) => op(term));\n  }\n\n  onLiteral1<T>(op: (lit: E.Literal<T>) => Term): Builder {\n    return this.set(['literal'], ([term]: [E.Literal<T>]) => op(term));\n  }\n\n  onString1(op: (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit))\n      .set(['langString'], ([lit]: [E.Literal<string>]) => op(lit));\n  }\n\n  onNumeric1(op: (val: E.NumericLiteral) => Term): Builder {\n    return this\n      .set(['integer'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['decimal'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['float'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['double'], ([val]: [E.NumericLiteral]) => op(val))\n      .invalidLexicalForm(['nonlexical'], 1);\n  }\n  /*\n  * Arithetic Operators take numbers, and return numbers.\n  * Check 'numeric' for behaviour of the generic numeric helper.\n  * https://www.w3.org/TR/sparql11-query/#OperatorMapping\n  */\n  arithmetic(op: (left: number, right: number) => number): Builder {\n    const opFac = (dt?: Type) => ([left, right]: Array<E.Literal<number>>) =>\n      number(op(left.typedValue, right.typedValue), dt || Type.XSD_FLOAT);\n    return this.numeric(opFac);\n  }\n\n  numberTest(test: (left: number, right: number) => boolean): Builder {\n    const func = ([left, right]: E.NumericLiteral[]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    };\n    return this.numeric(() => func);\n  }\n\n  stringTest(test: (left: string, right: string) => boolean): Builder {\n    return this\n      .set(\n        ['string', 'string'],\n        ([left, right]: E.StringLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'string'], 1)\n      .invalidLexicalForm(['string', 'nonlexical'], 2);\n  }\n\n  booleanTest(test: (left: boolean, right: boolean) => boolean): Builder {\n    return this\n      .set(\n        ['boolean', 'boolean'],\n        ([left, right]: E.BooleanLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'boolean'], 1)\n      .invalidLexicalForm(['boolean', 'nonlexical'], 2);\n  }\n\n  dateTimeTest(test: (left: Date, right: Date) => boolean): Builder {\n    return this\n      .set(\n        ['date', 'date'],\n        ([left, right]: E.DateTimeLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'date'], 1)\n      .invalidLexicalForm(['date', 'nonlexical'], 2);\n  }\n\n  numeric(opFac: OpFactory): Builder {\n    return this\n      .set(['integer', 'integer'], opFac(Type.XSD_INTEGER))\n      .set(['integer', 'decimal'], opFac())\n      .set(['integer', 'float'], opFac())\n      .set(['integer', 'double'], opFac())\n      .invalidLexicalForm(['integer', 'nonlexical'], 2)\n\n      .set(['decimal', 'integer'], opFac())\n      .set(['decimal', 'decimal'], opFac(Type.XSD_DECIMAL))\n      .set(['decimal', 'float'], opFac())\n      .set(['decimal', 'double'], opFac())\n      .invalidLexicalForm(['decimal', 'nonlexical'], 2)\n\n      .set(['float', 'integer'], opFac())\n      .set(['float', 'decimal'], opFac())\n      .set(['float', 'float'], opFac(Type.XSD_FLOAT))\n      .set(['float', 'double'], opFac())\n      .invalidLexicalForm(['float', 'nonlexical'], 2)\n\n      .set(['double', 'integer'], opFac())\n      .set(['double', 'decimal'], opFac())\n      .set(['double', 'float'], opFac())\n      .set(['double', 'double'], opFac(Type.XSD_DOUBLE))\n      .invalidLexicalForm(['double', 'nonlexical'], 2)\n\n      .invalidLexicalForm(['nonlexical', 'integer'], 1)\n      .invalidLexicalForm(['nonlexical', 'decimal'], 1)\n      .invalidLexicalForm(['nonlexical', 'float'], 1)\n      .invalidLexicalForm(['nonlexical', 'double'], 1);\n\n  }\n\n  invalidLexicalForm(types: ArgumentType[], index: number): Builder {\n    return this.set(types, (args: Term[]): E.TermExpression => {\n      throw new Err.InvalidLexicalForm(args[index - 1].toRDF());\n    });\n  }\n\n  private chain(impls: Impl[]): Builder {\n    this.implementations = this.implementations.concat(impls);\n    return this;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Type Safety Helpers\n// ----------------------------------------------------------------------------\n\n/**\n * Immutable.js type definitions are pretty unsafe, and this is typo-prone work.\n * These helpers allow use to create OverloadMaps with more type-safety.\n * One entry in the OverloadMap is described by the record Impl;\n *\n * A list of Impl's then gets constructed into an Immutable.js Map.\n *\n * See:\n * https://medium.com/@alexxgent/enforcing-types-with-immutablejs-and-typescript-6ab980819b6a\n */\n\nexport type ImplType = {\n  types: List<ArgumentType>;\n  func: E.SimpleApplication;\n};\n\nconst implDefaults = {\n  types: [] as ArgumentType[],\n  func() {\n    const msg = 'Implementation not set yet declared as implemented';\n    throw new Err.UnexpectedError(msg);\n  },\n};\n\nexport class Impl extends Record(implDefaults) {\n\n  constructor(params: ImplType) { super(params); }\n\n  get<T extends keyof ImplType>(value: T): ImplType[T] {\n    return super.get(value);\n  }\n\n  toPair(): [List<ArgumentType>, E.SimpleApplication] {\n    return [this.get('types'), this.get('func')];\n  }\n}\n\nexport function map(implementations: Impl[]): OverloadMap {\n  const typeImplPair = implementations.map((i) => i.toPair());\n  return Map<List<ArgumentType>, E.SimpleApplication>(typeImplPair);\n}\n\n// ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nexport function bool(val: boolean): E.BooleanLiteral {\n  return new E.BooleanLiteral(val);\n}\n\nexport function number(num: number, dt?: C.TypeURL): E.NumericLiteral {\n  return new E.NumericLiteral(num, undefined, C.make(dt || Type.XSD_FLOAT));\n}\n\nexport function string(s: string): E.StringLiteral {\n  return new E.StringLiteral(s);\n}\n\nexport function dateTime(date: Date, str: string): E.DateTimeLiteral {\n  return new E.DateTimeLiteral(date, str);\n}\n"]}