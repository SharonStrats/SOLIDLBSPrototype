"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
const Err = require("../../util/Errors");
const E = require("../Expressions");
const X = require("./XPathFunctions");
const Consts_1 = require("../../util/Consts");
const Helpers_1 = require("./Helpers");
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// Begin definitions
// ----------------------------------------------------------------------------
// Operator Mapping
// https://www.w3.org/TR/sparql11-query/#OperatorMapping
// ----------------------------------------------------------------------------
const not = {
    arity: 1,
    overloads: Helpers_1.declare()
        .onTerm1((val) => Helpers_1.bool(!val.coerceEBV()))
        .collect(),
};
const unaryPlus = {
    arity: 1,
    overloads: Helpers_1.declare()
        .onNumeric1((val) => {
        return Helpers_1.number(val.typedValue, val.typeURL.value);
    })
        .collect(),
};
const unaryMinus = {
    arity: 1,
    overloads: Helpers_1.declare()
        .onNumeric1((val) => {
        return Helpers_1.number(-val.typedValue, val.typeURL.value);
    })
        .collect(),
};
const multiplication = {
    arity: 2,
    overloads: Helpers_1.declare()
        .arithmetic((left, right) => left * right)
        .collect(),
};
const division = {
    arity: 2,
    overloads: Helpers_1.declare()
        .arithmetic((left, right) => left / right)
        .setLitBinary(['integer', 'integer'], (left, right) => {
        if (right === 0) {
            throw new Err.ExpressionError('Integer division by 0');
        }
        return Helpers_1.number(left / right, Consts_1.TypeURL.XSD_DECIMAL);
    })
        .collect(),
};
const addition = {
    arity: 2,
    overloads: Helpers_1.declare()
        .arithmetic((left, right) => left + right)
        .collect(),
};
const subtraction = {
    arity: 2,
    overloads: Helpers_1.declare()
        .arithmetic((left, right) => left - right)
        .collect(),
};
// https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal
const equality = {
    arity: 2,
    overloads: Helpers_1.declare()
        .numberTest((left, right) => left === right)
        .stringTest((left, right) => left.localeCompare(right) === 0)
        .booleanTest((left, right) => left === right)
        .dateTimeTest((left, right) => left.getTime() === right.getTime())
        .set(['term', 'term'], ([left, right]) => Helpers_1.bool(RDFTermEqual(left, right)))
        .collect(),
};
function RDFTermEqual(_left, _right) {
    const left = _left.toRDF();
    const right = _right.toRDF();
    const val = left.equals(right);
    if ((left.termType === 'Literal') && (right.termType === 'Literal')) {
        throw new Err.RDFEqualTypeError([_left, _right]);
    }
    return val;
}
const inequality = {
    arity: 2,
    overloads: Helpers_1.declare()
        .numberTest((left, right) => left !== right)
        .stringTest((left, right) => left.localeCompare(right) !== 0)
        .booleanTest((left, right) => left !== right)
        .dateTimeTest((left, right) => left.getTime() !== right.getTime())
        .set(['term', 'term'], ([left, right]) => Helpers_1.bool(!RDFTermEqual(left, right)))
        .collect(),
};
const lesserThan = {
    arity: 2,
    overloads: Helpers_1.declare()
        .numberTest((left, right) => left < right)
        .stringTest((left, right) => left.localeCompare(right) === -1)
        .booleanTest((left, right) => left < right)
        .dateTimeTest((left, right) => left.getTime() < right.getTime())
        .collect(),
};
const greaterThan = {
    arity: 2,
    overloads: Helpers_1.declare()
        .numberTest((left, right) => left > right)
        .stringTest((left, right) => left.localeCompare(right) === 1)
        .booleanTest((left, right) => left > right)
        .dateTimeTest((left, right) => left.getTime() > right.getTime())
        .collect(),
};
const lesserThanEqual = {
    arity: 2,
    overloads: Helpers_1.declare()
        .numberTest((left, right) => left <= right)
        .stringTest((left, right) => left.localeCompare(right) !== 1)
        .booleanTest((left, right) => left <= right)
        .dateTimeTest((left, right) => left.getTime() <= right.getTime())
        .collect(),
};
const greaterThanEqual = {
    arity: 2,
    overloads: Helpers_1.declare()
        .numberTest((left, right) => left >= right)
        .stringTest((left, right) => left.localeCompare(right) !== -1)
        .booleanTest((left, right) => left >= right)
        .dateTimeTest((left, right) => left.getTime() >= right.getTime())
        .collect(),
};
// ----------------------------------------------------------------------------
// Functions on RDF Terms
// https://www.w3.org/TR/sparql11-query/#func-rdfTerms
// ----------------------------------------------------------------------------
const isIRI = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('isIRI').collect(),
};
const isBlank = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('isBlank').collect(),
};
const isLiteral = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('isLiteral').collect(),
};
const isNumeric = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('isNumeric').collect(),
};
const toString = {
    arity: 1,
    overloads: Helpers_1.declare()
        .onTerm1((term) => Helpers_1.string(term.str()))
        .collect(),
};
const lang = {
    arity: 1,
    overloads: Helpers_1.declare().onLiteral1((lit) => Helpers_1.string(lit.language || '')).collect(),
};
const datatype = {
    arity: 1,
    overloads: Helpers_1.declare().onLiteral1((lit) => Helpers_1.string((lit.typeURL) ? lit.typeURL.value : Consts_1.TypeURL.XSD_STRING)).collect(),
};
const IRI = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('IRI').collect(),
};
// https://www.w3.org/TR/sparql11-query/#func-bnode
// id has to be distinct over all id's in dataset
const BNODE = {
    arity: [0, 1],
    overloads: Helpers_1.declare()
        // .set([], () => new E.BlankNode()) // TODO
        .setLitUnary('string', (val) => new E.BlankNode(val))
        .collect(),
};
const STRDT = {
    arity: 2,
    overloads: Helpers_1.declare().unimplemented('STRDT').collect(),
};
const STRLANG = {
    arity: 2,
    overloads: Helpers_1.declare().unimplemented('STRLANG').collect(),
};
const UUID = {
    arity: 0,
    overloads: Helpers_1.declare().unimplemented('UUID').collect(),
};
const STRUUID = {
    arity: 0,
    overloads: Helpers_1.declare().unimplemented('STRUUID').collect(),
};
// ----------------------------------------------------------------------------
// Functions on strings
// https://www.w3.org/TR/sparql11-query/#func-forms
// ----------------------------------------------------------------------------
const STRLEN = {
    arity: 1,
    overloads: Helpers_1.declare()
        .onLiteral1((lit) => Helpers_1.number(lit.typedValue.length, Consts_1.TypeURL.XSD_INTEGER))
        .collect(),
};
const SUBSTR = {
    arity: [2, 3],
    overloads: Helpers_1.declare().unimplemented('SUBSTR').collect(),
};
const UCASE = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('UCASE').collect(),
};
const LCASE = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('LCASE').collect(),
};
const STRSTARTS = {
    arity: 2,
    overloads: Helpers_1.declare().unimplemented('STRSTARTS').collect(),
};
const STRENDS = {
    arity: 2,
    overloads: Helpers_1.declare().unimplemented('STRENDS').collect(),
};
const CONTAINS = {
    arity: 2,
    overloads: Helpers_1.declare().unimplemented('CONTAINS').collect(),
};
const STRBEFORE = {
    arity: 2,
    overloads: Helpers_1.declare().unimplemented('STRBEFORE').collect(),
};
const STRAFTER = {
    arity: 2,
    overloads: Helpers_1.declare().unimplemented('STRAFTER').collect(),
};
const ENCODE_FOR_URI = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('ENCODE_FOR_URI').collect(),
};
const CONCAT = {
    arity: Infinity,
    overloads: Helpers_1.declare().unimplemented('CONCAT').collect(),
};
const langmatches = {
    arity: 2,
    overloads: Helpers_1.declare()
        .setLitBinary(['string', 'string'], (tag, range) => Helpers_1.bool(X.langMatches(tag, range))).collect(),
};
const regex2 = (text, pattern) => Helpers_1.bool(X.matches(text, pattern));
const regex3 = (text, pattern, flags) => Helpers_1.bool(X.matches(text, pattern, flags));
const REGEX = {
    arity: [2, 3],
    overloads: Helpers_1.declare()
        .setLitBinary(['string', 'string'], regex2)
        .setLitBinary(['langString', 'langString'], regex2)
        .setLitTernary(['string', 'string', 'string'], regex3)
        .setLitTernary(['langString', 'string', 'string'], regex3)
        .collect(),
};
const REPLACE = {
    arity: [3, 4],
    overloads: Helpers_1.declare().unimplemented('REPLACE').collect(),
};
// ----------------------------------------------------------------------------
// Functions on numerics
// https://www.w3.org/TR/sparql11-query/#func-numerics
// ----------------------------------------------------------------------------
const abs = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('abs').collect(),
};
const round = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('round').collect(),
};
const ceil = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('ceil').collect(),
};
const floor = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('floor').collect(),
};
const RAND = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('RAND').collect(),
};
// ----------------------------------------------------------------------------
// Functions on Dates and Times
// https://www.w3.org/TR/sparql11-query/#func-date-time
// ----------------------------------------------------------------------------
const now = {
    arity: 0,
    overloads: Helpers_1.declare().unimplemented('now').collect(),
};
const year = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('year').collect(),
};
const month = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('month').collect(),
};
const day = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('day').collect(),
};
const hours = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('hours').collect(),
};
const minutes = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('minutes').collect(),
};
const seconds = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('seconds').collect(),
};
const timezone = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('timezone').collect(),
};
const tz = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('tz').collect(),
};
// ----------------------------------------------------------------------------
// Hash functions
// https://www.w3.org/TR/sparql11-query/#func-hash
// ----------------------------------------------------------------------------
const MD5 = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('MD5').collect(),
};
const SHA1 = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('SHA1').collect(),
};
const SHA256 = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('SHA256').collect(),
};
const SHA384 = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('SHA384').collect(),
};
const SHA512 = {
    arity: 1,
    overloads: Helpers_1.declare().unimplemented('SHA512').collect(),
};
// End definitions.
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
/*
 * Collect all the definitions from above into an object
 */
const _definitions = {
    // --------------------------------------------------------------------------
    // Operator Mapping
    // https://www.w3.org/TR/sparql11-query/#OperatorMapping
    // --------------------------------------------------------------------------
    '!': not,
    'UPLUS': unaryPlus,
    'UMINUS': unaryMinus,
    '*': multiplication,
    '/': division,
    '+': addition,
    '-': subtraction,
    '=': equality,
    '!=': inequality,
    '<': lesserThan,
    '>': greaterThan,
    '<=': lesserThanEqual,
    '>=': greaterThanEqual,
    // --------------------------------------------------------------------------
    // Functions on RDF Terms
    // https://www.w3.org/TR/sparql11-query/#func-rdfTerms
    // --------------------------------------------------------------------------
    'isIRI': isIRI,
    'isBlank': isBlank,
    'isLiteral': isLiteral,
    'isNumeric': isNumeric,
    'str': toString,
    'lang': lang,
    'datatype': datatype,
    'IRI': IRI,
    'BNODE': BNODE,
    'STRDT': STRDT,
    'STRLANG': STRLANG,
    'UUID': UUID,
    'STRUUID': STRUUID,
    // --------------------------------------------------------------------------
    // Functions on strings
    // https://www.w3.org/TR/sparql11-query/#func-forms
    // --------------------------------------------------------------------------
    'strlen': STRLEN,
    'SUBSTR': SUBSTR,
    'UCASE': UCASE,
    'LCASE': LCASE,
    'STRSTARTS': STRSTARTS,
    'STRENDS': STRENDS,
    'CONTAINS': CONTAINS,
    'STRBEFORE': STRBEFORE,
    'STRAFTER': STRAFTER,
    'ENCODE_FOR_URI': ENCODE_FOR_URI,
    'CONCAT': CONCAT,
    'langmatches': langmatches,
    'regex': REGEX,
    'REPLACE': REPLACE,
    // --------------------------------------------------------------------------
    // Functions on numerics
    // https://www.w3.org/TR/sparql11-query/#func-numerics
    // --------------------------------------------------------------------------
    'abs': abs,
    'round': round,
    'ceil': ceil,
    'floor': floor,
    'RAND': RAND,
    // --------------------------------------------------------------------------
    // Functions on Dates and Times
    // https://www.w3.org/TR/sparql11-query/#func-date-time
    // --------------------------------------------------------------------------
    'now': now,
    'year': year,
    'month': month,
    'day': day,
    'hours': hours,
    'minutes': minutes,
    'seconds': seconds,
    'timezone': timezone,
    'tz': tz,
    // --------------------------------------------------------------------------
    // Hash functions
    // https://www.w3.org/TR/sparql11-query/#func-hash
    // --------------------------------------------------------------------------
    'MD5': MD5,
    'SHA1': SHA1,
    'SHA256': SHA256,
    'SHA384': SHA384,
    'SHA512': SHA512,
};
exports.definitions = immutable_1.Map(_definitions);
//# sourceMappingURL=RegularFunctions.js.map