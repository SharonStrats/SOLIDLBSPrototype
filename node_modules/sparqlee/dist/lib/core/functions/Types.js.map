{"version":3,"file":"Types.js","sourceRoot":"","sources":["../../../../lib/core/functions/Types.ts"],"names":[],"mappings":";;AACA,yCAAsC;AAKtC,8CAAyD;AAgBzD,MAAa,cAAc;IAEzB,sEAAsE;IACtE,YACS,QAAoB,EACpB,KAAa,EACb,KAAqB,EAClB,MAAsD;QAHzD,aAAQ,GAAR,QAAQ,CAAY;QACpB,UAAK,GAAL,KAAK,CAAQ;QACb,UAAK,GAAL,KAAK,CAAgB;QAClB,WAAM,GAAN,MAAM,CAAgD;QANlE,kBAAa,GAAa,QAAQ,CAAC;IAO/B,CAAC;IAEL,KAAK,CAAC,IAAwB;QAC5B,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE;YAC7B,MAAM,IAAI,6BAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SACrD;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAED,aAAa;IACb,iCAAiC;IACjC,gEAAgE;IACxD,aAAa,CAAC,IAAwB;QAC5C,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE;YAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAM,GAAqB,CAAC,QAAQ;mBACnD,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,QAAQ;mBAC9B,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC;QAChC,CAAC,CAAC,CAAC;QACH,kCAAkC;QAClC,sDAAsD;QACtD,yCAAyC;QACzC,8BAA8B;QAC9B,yDAAyD;IAC3D,CAAC;CACF;AAhCD,wCAgCC;AA6BD,MAAa,kBAAkB;IAG7B,YACS,QAAoB,EACpB,KAAwB,EACvB,WAAwB;QAFzB,aAAQ,GAAR,QAAQ,CAAY;QACpB,UAAK,GAAL,KAAK,CAAmB;QACvB,gBAAW,GAAX,WAAW,CAAa;QALlC,kBAAa,GAAiB,YAAY,CAAC;IAMvC,CAAC;IAEL,KAAK,CAAC,IAAwB;QAC5B,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,IAAI,EAAE;YAAE,MAAM,IAAI,6BAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SAAE;QACnE,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;IACpB,CAAC;IAED,uBAAuB;IACf,UAAU,CAAC,IAAwB;QACzC,kCAAkC;QAClC,MAAM,QAAQ,GAAG,gBAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAM,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QACtE,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC;eAChC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,gBAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC7D,CAAC;CACF;AAvBD,gDAuBC;AAED,+EAA+E;AAC/E;;;;;;;;;;;;;;GAcG;AAEH,MAAsB,oBAAoB;IAA1C;QACE,kBAAa,GAAc,SAAS,CAAC;IASvC,CAAC;CAAA;AAVD,oDAUC","sourcesContent":["import * as Promise from 'bluebird';\nimport { List, Map } from 'immutable';\n\nimport * as C from '../../util/Consts';\nimport * as E from '../Expressions';\n\nimport { InvalidArgumentTypes } from '../../util/Errors';\nimport { Bindings } from '../Types';\n\n// ----------------------------------------------------------------------------\n// Functions\n// ---------------------------------------------------------------------------\n\n// Argument Types and their specificity ---------------------------------------\n\n// Function and operator arguments are 'flattened' in the SPARQL spec.\n// If the argument is a literal, the datatype often also matters.\nexport type ArgumentType = 'term' | E.TermType | C.DataTypeCategory;\n\n// Simple Functions -----------------------------------------------------------\n\nexport type TypeChecker = (args: E.TermExpression[]) => boolean;\nexport class SimpleFunction implements E.SimpleFunc {\n  functionClass: 'simple' = 'simple';\n  // Add functions that select a datatype to compare to in _isValidTypes\n  constructor(\n    public operator: C.Operator,\n    public arity: number,\n    public types: ArgumentType[],\n    protected _apply: (args: E.TermExpression[]) => E.TermExpression,\n  ) { }\n\n  apply(args: E.TermExpression[]): E.TermExpression {\n    if (!this._isValidTypes(args)) {\n      throw new InvalidArgumentTypes(args, this.operator);\n    }\n    return this._apply(args);\n  }\n\n  // TODO: Test\n  // TODO Can be optimised probably\n  // TODO Put in documentation, this is our TypeChecker for simple\n  private _isValidTypes(args: E.TermExpression[]): boolean {\n    return args.every((arg, i) => {\n      return this.types[i] === (arg as E.LiteralTerm).category\n        || this.types[i] === arg.termType\n        || this.types[i] === 'term';\n    });\n    // tslint:disable-next-line:no-any\n    // const argTypes = args.map((a) => a. || a.termType);\n    // return _.isEqual(this.types, argTypes)\n    // // TODO this arity is wrong\n    //   || _.isEqual(this.types, Array(arity).fill('term'));\n  }\n}\n\n// Overloaded Functions -------------------------------------------------------\n\n/*\n * Varying kinds of functions take arguments of different types on which the\n * specific behaviour is dependant. Although their behaviour is often varying,\n * it is always relatively simple, and better suited for synced behaviour.\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * Note: functions that have multiple arities do not belong in this category.\n * Eg: BNODE.\n *\n * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\n\n// Maps argument types on their specific implementation.\nexport type OverloadMap = Map<List<ArgumentType>, E.SimpleApplication>;\n\nexport class OverloadedFunction implements E.OverloadedFunc {\n  functionClass: 'overloaded' = 'overloaded';\n\n  constructor(\n    public operator: C.Operator,\n    public arity: number | number[],\n    private overloadMap: OverloadMap,\n  ) { }\n\n  apply(args: E.TermExpression[]): E.TermExpression {\n    const func = this._monomorph(args);\n    if (!func) { throw new InvalidArgumentTypes(args, this.operator); }\n    return func(args);\n  }\n\n  // TODO: Clean up a bit\n  private _monomorph(args: E.TermExpression[]): E.SimpleApplication {\n    // tslint:disable-next-line:no-any\n    const argTypes = List(args.map((a: any) => a.category || a.termType));\n    const arity = args.length;\n    return this.overloadMap.get(argTypes)\n      || this.overloadMap.get(List(Array(arity).fill('term')));\n  }\n}\n\n// Special Functions ----------------------------------------------------------\n/*\n * Special Functions are those that don't really fit in sensible categories and\n * have extremely heterogeneous signatures that make them impossible to abstract\n * over. They are small in number, and their behaviour is often complex and open\n * for multiple correct implementations with different trade-offs.\n *\n * Due to their varying nature, they need all available information present\n * during evaluation. This reflects in the signature of the apply() method.\n *\n * They need access to an evaluator to be able to even implement their logic.\n * Especially relevant for IF, and the logical connectives.\n *\n * They can have both sync and async implementations, and both would make sense\n * in some contexts.\n */\n\nexport abstract class SpecialFunctionAsync implements E.SpecialFunc {\n  functionClass: 'special' = 'special';\n  abstract operator: C.Operator;\n\n  abstract apply(\n    args: E.Expression[],\n    mapping: Bindings,\n    evaluate: (e: E.Expression, mapping: Bindings) => Promise<E.TermExpression>,\n  ): Promise<E.TermExpression>;\n\n}\n"]}