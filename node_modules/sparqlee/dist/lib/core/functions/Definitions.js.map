{"version":3,"file":"Definitions.js","sourceRoot":"","sources":["../../../../lib/core/functions/Definitions.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Promise from 'bluebird';\nimport { Map } from 'immutable';\nimport { expand, forAll, Impl, map, str, unary } from './Helpers';\n\nimport * as C from '../../util/Consts';\nimport * as E from './../Expressions';\nimport * as Special from './SpecialFunctions';\nimport * as X from './XPath';\n\nimport { DataType as DT } from '../../util/Consts';\nimport { ExpressionError, UnimplementedError } from '../../util/Errors';\nimport { arithmetic, binary, bool, list, number, numeric, xPathTest } from './Helpers';\nimport { ArgumentType, OverloadMap, SpecialFunctionAsync } from './Types';\n\n// ----------------------------------------------------------------------------\n// The definitions and functionality for all operators\n// ----------------------------------------------------------------------------\n\nexport type FuncDefinition =\n  SimpleDefinition\n  | OverloadedDefinition\n  | SpecialDefinition;\n\nexport interface DefinitionProps {\n  arity: number | number[];\n  category: C.OperatorCategory;\n}\n\nexport type SimpleDefinition = DefinitionProps & {\n  arity: number;\n  category: 'simple';\n  types: ArgumentType[];\n  apply(args: E.TermExpression[]): E.TermExpression;\n};\n\nexport type OverloadedDefinition = DefinitionProps & {\n  arity: number | number[];\n  category: 'overloaded';\n  overloads: OverloadMap;\n};\n\nexport type SpecialDefinition = DefinitionProps & {\n  arity: number;\n  category: 'special';\n  constructor: new () => SpecialFunctionAsync;\n};\n\ntype IDefinitionMap = { [key in C.Operator]: FuncDefinition };\ntype Term = E.TermExpression;\n\n// TODO Maybe split in definitions for simple, overloaded and async functions.\nconst _definitions: IDefinitionMap = {\n  // --------------------------------------------------------------------------\n  // Operator Mapping\n  // https://www.w3.org/TR/sparql11-query/#OperatorMapping\n  // --------------------------------------------------------------------------\n  '!': {\n    arity: 1,\n    category: 'simple',\n    types: [],\n    apply: () => { throw new UnimplementedError('! operator'); },\n  },\n  'UPLUS': {\n    arity: 1,\n    category: 'simple',\n    types: [],\n    apply: () => { throw new UnimplementedError('Unary plus operator'); },\n  },\n  'UMINUS': {\n    arity: 1,\n    category: 'simple',\n    types: [],\n    apply: () => { throw new UnimplementedError('Unary minus operator'); },\n  },\n  '&&': {\n    arity: 2,\n    category: 'special',\n    constructor: Special.LogicalAndAsync,\n  },\n  '||': {\n    arity: 2,\n    category: 'special',\n    constructor: Special.LogicalOrAsync,\n  },\n  '*': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: arithmetic(X.numericMultiply),\n  },\n  '/': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: arithmetic(X.numericDivide).set(\n      list('integer', 'integer'),\n      (args: Term[]) => {\n        if ((args[1] as E.NumericLiteral).typedValue === 0) {\n          throw new ExpressionError('Integer division by 0');\n        }\n        return number(binary(X.numericDivide, args), DT.XSD_DECIMAL);\n      },\n    ),\n  },\n  '+': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: arithmetic(X.numericAdd),\n  },\n  '-': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: arithmetic(X.numericSubtract),\n  },\n  '=': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: xPathTest(\n      X.numericEqual,\n      (left, right) => X.numericEqual(X.compare(left, right), 0),\n      X.booleanEqual,\n      X.dateTimeEqual,\n    ).set(\n      list('term', 'term'),\n      (args: Term[]) => {\n        return bool(Special.RDFTermEqual(args[0], args[1]));\n      },\n    ),\n  },\n  '!=': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: xPathTest(\n      (left, right) => !X.numericEqual(left, right),\n      (left, right) => !X.numericEqual(X.compare(left, right), 0),\n      (left, right) => !X.booleanEqual(left, right),\n      (left, right) => !X.dateTimeEqual(left, right),\n    ),\n  },\n  '<': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: xPathTest(\n      X.numericLessThan,\n      (left, right) => X.numericEqual(X.compare(left, right), -1),\n      X.booleanLessThan,\n      X.dateTimeLessThan,\n    ),\n  },\n  '>': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: xPathTest(\n      X.numericGreaterThan,\n      (left, right) => X.numericEqual(X.compare(left, right), 1),\n      X.booleanGreaterThan,\n      X.dateTimeGreaterThan,\n    ),\n  },\n  '<=': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: xPathTest(\n      (left, right) => X.numericLessThan(left, right) || X.numericEqual(left, right),\n      (left, right) => !X.numericEqual(X.compare(left, right), 1),\n      (left, right) => !X.booleanGreaterThan(left, right),\n      (left, right) => !X.dateTimeGreaterThan(left, right),\n    ),\n  },\n  '>=': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: xPathTest(\n      (left, right) => X.numericGreaterThan(left, right) || X.numericEqual(left, right),\n      (left, right) => !X.numericEqual(X.compare(left, right), -1),\n      (left, right) => !X.booleanLessThan(left, right),\n      (left, right) => !X.dateTimeLessThan(left, right),\n    ),\n  },\n  // --------------------------------------------------------------------------\n  // Functional Forms\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'bound': {\n    arity: 1,\n    category: 'special',\n    constructor: Special.Bound,\n  },\n  'if': {\n    arity: 3,\n    category: 'special',\n    constructor: Special.If,\n  },\n  'coalesce': {\n    arity: Infinity,\n    category: 'special',\n    constructor: Special.Coalesce,\n  },\n  'sameterm': {\n    arity: 2,\n    category: 'simple',\n    types: ['term', 'term'],\n    apply(args: Term[]) {\n      return bool(Special.sameTerm(args[1], args[2]));\n    },\n  },\n  'in': {\n    arity: Infinity,\n    category: 'special',\n    constructor: Special.In,\n  },\n  'notin': {\n    arity: Infinity,\n    category: 'special',\n    constructor: Special.NotIn,\n  },\n  // --------------------------------------------------------------------------\n  // Functions on RDF Terms\n  // https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n  // --------------------------------------------------------------------------\n  'str': {\n    arity: 1,\n    category: 'simple',\n    types: ['term'],\n    apply(args: Term[]) { return str(args[0].str()); },\n  },\n  'lang': {\n    arity: 1,\n    category: 'simple',\n    types: ['literal'],\n    apply(args: Array<E.Literal<string>>) {\n      return str(args[0].language || '');\n    },\n  },\n  'datatype': {\n    arity: 1,\n    category: 'simple',\n    types: ['literal'],\n    // tslint:disable-next-line:no-any\n    apply(args: Array<E.Literal<any>>) {\n      const arg = args[0];\n      return str((arg.dataType) ? arg.dataType.value : '');\n    },\n  },\n  // --------------------------------------------------------------------------\n  // Functions on strings\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // TODO: Note somewhere that 'overloaded' is in the context of this type system.\n  // Eg. strlen is overloaded, although it has identical behaviour,\n  // but the types can not be captured by a single ArgumentType.\n  // --------------------------------------------------------------------------\n  'strlen': {\n    arity: 1,\n    category: 'overloaded',\n    overloads: forAll(\n      [['plain'], ['simple'], ['string']],\n      (args: Term[]) => number(unary(X.stringLength, args), DT.XSD_INTEGER),\n    ),\n  },\n  'langmatches': {\n    arity: 2,\n    category: 'overloaded',\n    overloads: forAll(\n      [\n        // TODO: This deviates from the spec, as it only allows simple literals\n        ['simple', 'simple'],\n        ['simple', 'string'],\n        ['string', 'simple'],\n        ['string', 'string'],\n      ],\n      (args: Term[]) => bool(binary(X.langMatches, args)),\n    ),\n  },\n  'regex': {\n    arity: [2, 3],\n    category: 'overloaded',\n    // // TODO: This deviates from the spec, as the second and third argument should be simple literals\n    overloads: forAll(\n      [].concat(expand(['stringly', 'simple']))\n        .concat(expand(['stringly', 'simple', 'simple'])),\n      (args: Array<E.Literal<string>>) => bool(X.matches(\n        args[0].typedValue,\n        args[1].typedValue,\n        ((args[2]) ? args[2].typedValue : ''),\n      )),\n    ),\n  },\n\n  // --------------------------------------------------------------------------\n  // Functions on numerics\n  // https://www.w3.org/TR/sparql11-query/#func-numerics\n  // --------------------------------------------------------------------------\n  'abs': {\n    arity: 1,\n    category: 'overloaded',\n    overloads: forAll(\n      [['term']],\n      () => { throw new UnimplementedError('abs'); },\n    ),\n  },\n\n  // --------------------------------------------------------------------------\n  // Functions on Dates and Times\n  // https://www.w3.org/TR/sparql11-query/#func-date-time\n  // --------------------------------------------------------------------------\n  'now': {\n    arity: 0,\n    category: 'simple',\n    types: [],\n    apply: (args: Term[]) => {\n      throw new UnimplementedError('now function');\n    },\n  },\n\n  // --------------------------------------------------------------------------\n  // Hash functions\n  // https://www.w3.org/TR/sparql11-query/#func-hash\n  // --------------------------------------------------------------------------\n\n  // --------------------------------------------------------------------------\n  // XPath Constructor functions\n  // https://www.w3.org/TR/sparql11-query/#FunctionMapping\n  // --------------------------------------------------------------------------\n};\n\nexport const definitions = Map<C.Operator, FuncDefinition>(_definitions);\n"]}