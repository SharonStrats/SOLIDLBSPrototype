{"version":3,"file":"SpecialFunctions.js","sourceRoot":"","sources":["../../../../lib/core/functions/SpecialFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport * as Promise from 'bluebird';\n\nimport * as C from '../../util/Consts';\nimport * as Err from '../../util/Errors';\nimport * as E from '../Expressions';\n\nimport { Bindings } from '../Types';\nimport { bool } from './Helpers';\nimport { functions } from './index';\nimport { OverloadedFunction, SpecialFunctionAsync } from './Types';\n\nexport type AsyncTerm = Promise<E.TermExpression>;\nexport type Evaluator = (expr: E.Expression, mapping: Bindings) => AsyncTerm;\n\nexport class Bound extends SpecialFunctionAsync {\n  operator = C.Operator.BOUND;\n  apply(args: E.Expression[], mapping: Bindings, evaluate: Evaluator): AsyncTerm {\n    const variable = args[0] as E.VariableExpression;\n    if (variable.expressionType !== 'variable') {\n      throw new Err.InvalidArgumentTypes(args, C.Operator.BOUND);\n    }\n    const val = mapping.has(variable.name) && !!mapping.get(variable.name);\n    return Promise.resolve(bool(val));\n  }\n}\n\nexport class If extends SpecialFunctionAsync {\n  operator = C.Operator.IF;\n  apply(args: E.Expression[], mapping: Bindings, evaluate: Evaluator): AsyncTerm {\n    const valFirstP = evaluate(args[0], mapping);\n    return valFirstP.then((valFirst) => {\n      const ebv = valFirst.coerceEBV();\n      return (ebv)\n        ? evaluate(args[1], mapping)\n        : evaluate(args[2], mapping);\n    });\n  }\n}\n\nexport class Coalesce extends SpecialFunctionAsync {\n  operator = C.Operator.COALESCE;\n  apply(args: E.Expression[], mapping: Bindings, evaluate: Evaluator): AsyncTerm {\n    return Promise\n      .mapSeries(args, (expr) =>\n        evaluate(expr, mapping)\n          .then((term) => new CoalesceBreaker(term))\n          .catch((err) => new CoalesceContinuer(err))\n          .then((controller) => {\n            if (controller.type === 'breaker') {\n              throw controller;\n            } else {\n              return controller;\n            }\n          }))\n      .map((continuer: CoalesceContinuer) => continuer.err)\n      .then((errors) => { throw new Err.CoalesceError(errors); })\n      .catch(CoalesceBreaker, (br) => {\n        return br.val;\n      });\n  }\n}\n\n// tslint:disable-next-line:interface-over-type-literal\ntype CoalesceController = { type: 'breaker' | 'continuer' };\nclass CoalesceBreaker extends Error implements CoalesceController {\n  type: 'breaker' = 'breaker';\n  constructor(public val: E.TermExpression) {\n    super();\n  }\n}\nclass CoalesceContinuer implements CoalesceController {\n  type: 'continuer' = 'continuer';\n  constructor(public err: Error) { }\n}\n\n// TODO: Might benefit from some smart people's input\n// https://www.w3.org/TR/sparql11-query/#func-logical-or\nexport class LogicalOrAsync extends SpecialFunctionAsync {\n  operator = C.Operator.LOGICAL_OR;\n  apply(args: E.Expression[], mapping: Bindings, evaluate: Evaluator): AsyncTerm {\n    const [leftExpr, rightExpr] = args;\n    return evaluate(leftExpr, mapping)\n      .then((left) => left.coerceEBV())\n      .then((left) => {\n        if (left) { return bool(true); }\n\n        return evaluate(rightExpr, mapping)\n          .then((right) => right.coerceEBV())\n          .then((right) => bool(right));\n      })\n      .catch((err) => {\n        return evaluate(rightExpr, mapping)\n          .then((right) => right.coerceEBV())\n          .then((right) => {\n            if (right) { return bool(true); }\n            throw err;\n          });\n      });\n  }\n}\n\n// https://www.w3.org/TR/sparql11-query/#func-logical-and\nexport class LogicalAndAsync extends SpecialFunctionAsync {\n  operator = C.Operator.LOGICAL_AND;\n  apply(args: E.Expression[], mapping: Bindings, evaluate: Evaluator): AsyncTerm {\n    const [leftExpr, rightExpr] = args;\n\n    return evaluate(leftExpr, mapping)\n      .then((left) => left.coerceEBV())\n      .then((left) => {\n        if (!left) { return bool(false); }\n        return evaluate(rightExpr, mapping)\n          .then((right) => right.coerceEBV())\n          .then((right) => bool(right));\n      })\n      .catch((err) => {\n        return evaluate(rightExpr, mapping)\n          .then((right) => right.coerceEBV())\n          .then((right) => {\n            if (!right) { return bool(false); }\n            throw err;\n          });\n      });\n  }\n}\n\n// Maybe put some place else\n// https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal\nexport function RDFTermEqual(_left: E.TermExpression, _right: E.TermExpression) {\n  const left = _left.toRDF();\n  const right = _right.toRDF();\n  const val = left.equals(right);\n  if ((left.termType === 'Literal') && (right.termType === 'Literal')) {\n    throw new Err.RDFEqualTypeError([_left, _right]);\n  }\n  return val;\n}\n\nexport function sameTerm(left: E.TermExpression, right: E.TermExpression) {\n  return left.toRDF().equals(right.toRDF());\n}\n\nexport class In extends SpecialFunctionAsync {\n  operator = C.Operator.IN;\n  apply(args: E.Expression[], mapping: Bindings, evaluate: Evaluator): AsyncTerm {\n    if (args.length < 1) { throw new Err.InvalidArity(args, C.Operator.IN); }\n    const [left, ...remaining] = args;\n    const thunks = remaining.map((expr) => () => evaluate(expr, mapping));\n    return evaluate(left, mapping)\n      .then((_left) => inR(_left, thunks, []));\n  }\n}\n\nfunction inR(left: E.TermExpression, args: Array<() => AsyncTerm>, results: Array<Error | false>): AsyncTerm {\n  if (args.length === 0) {\n    return (results.every((v) => !v))\n      ? Promise.resolve(bool(false))\n      : Promise.reject(new Err.InError(results));\n  }\n  const first = args.shift();\n  return first()\n    .then((v) => {\n      const op = functions.get(C.Operator.EQUAL) as E.OverloadedFunc;\n      return op.apply([left, v]);\n    })\n    .then(\n      (result) => ((result as E.BooleanLiteral).typedValue)\n        ? bool(true)\n        : inR(left, args, [...results, false]),\n      (err) => inR(left, args, [...results, err]),\n    );\n}\n\nexport class NotIn extends SpecialFunctionAsync {\n  operator = C.Operator.NOT_IN;\n  apply(args: E.Expression[], mapping: Bindings, evaluate: Evaluator): AsyncTerm {\n    return new In()\n      .apply(args, mapping, evaluate)\n      .then((term: E.TermExpression) => (term as E.BooleanLiteral).typedValue)\n      .then((isIn) => bool(!isIn));\n  }\n}\n"]}