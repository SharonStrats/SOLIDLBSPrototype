"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
const Helpers_1 = require("./Helpers");
const Special = require("./SpecialFunctions");
const X = require("./XPath");
const Consts_1 = require("../../util/Consts");
const Errors_1 = require("../../util/Errors");
const Helpers_2 = require("./Helpers");
// TODO Maybe split in definitions for overloaded and async functions.
const _definitions = {
    // --------------------------------------------------------------------------
    // Operator Mapping
    // https://www.w3.org/TR/sparql11-query/#OperatorMapping
    // --------------------------------------------------------------------------
    '!': {
        arity: 1,
        overloads: Helpers_1.simple(['term'], () => { throw new Errors_1.UnimplementedError('! operator'); }),
    },
    'UPLUS': {
        arity: 1,
        overloads: Helpers_1.simple(['term'], () => { throw new Errors_1.UnimplementedError('Unary plus operator'); }),
    },
    'UMINUS': {
        arity: 1,
        overloads: Helpers_1.simple(['term'], () => { throw new Errors_1.UnimplementedError('Unary minus operator'); }),
    },
    '*': {
        arity: 2,
        overloads: Helpers_2.arithmetic(X.numericMultiply),
    },
    '/': {
        arity: 2,
        overloads: Helpers_2.arithmetic(X.numericDivide).set(Helpers_2.list('integer', 'integer'), (args) => {
            if (args[1].typedValue === 0) {
                throw new Errors_1.ExpressionError('Integer division by 0');
            }
            return Helpers_2.number(Helpers_2.binary(X.numericDivide, args), Consts_1.TypeURL.XSD_DECIMAL);
        }),
    },
    '+': {
        arity: 2,
        overloads: Helpers_2.arithmetic(X.numericAdd),
    },
    '-': {
        arity: 2,
        overloads: Helpers_2.arithmetic(X.numericSubtract),
    },
    '=': {
        arity: 2,
        overloads: Helpers_2.xPathTest(X.numericEqual, (left, right) => X.numericEqual(X.compare(left, right), 0), X.booleanEqual, X.dateTimeEqual).set(Helpers_2.list('term', 'term'), (args) => {
            return Helpers_2.bool(Special.RDFTermEqual(args[0], args[1]));
        }),
    },
    '!=': {
        arity: 2,
        overloads: Helpers_2.xPathTest((left, right) => !X.numericEqual(left, right), (left, right) => !X.numericEqual(X.compare(left, right), 0), (left, right) => !X.booleanEqual(left, right), (left, right) => !X.dateTimeEqual(left, right)),
    },
    '<': {
        arity: 2,
        overloads: Helpers_2.xPathTest(X.numericLessThan, (left, right) => X.numericEqual(X.compare(left, right), -1), X.booleanLessThan, X.dateTimeLessThan),
    },
    '>': {
        arity: 2,
        overloads: Helpers_2.xPathTest(X.numericGreaterThan, (left, right) => X.numericEqual(X.compare(left, right), 1), X.booleanGreaterThan, X.dateTimeGreaterThan),
    },
    '<=': {
        arity: 2,
        overloads: Helpers_2.xPathTest((left, right) => X.numericLessThan(left, right) || X.numericEqual(left, right), (left, right) => !X.numericEqual(X.compare(left, right), 1), (left, right) => !X.booleanGreaterThan(left, right), (left, right) => !X.dateTimeGreaterThan(left, right)),
    },
    '>=': {
        arity: 2,
        overloads: Helpers_2.xPathTest((left, right) => X.numericGreaterThan(left, right) || X.numericEqual(left, right), (left, right) => !X.numericEqual(X.compare(left, right), -1), (left, right) => !X.booleanLessThan(left, right), (left, right) => !X.dateTimeLessThan(left, right)),
    },
    // --------------------------------------------------------------------------
    // Functions on RDF Terms
    // https://www.w3.org/TR/sparql11-query/#func-rdfTerms
    // --------------------------------------------------------------------------
    'str': {
        arity: 1,
        overloads: Helpers_1.simple(['term'], (args) => Helpers_1.str(args[0].str())),
    },
    'lang': {
        arity: 1,
        overloads: Helpers_1.simple(['literal'], (args) => Helpers_1.str(args[0].language || '')),
    },
    'datatype': {
        arity: 1,
        overloads: Helpers_1.simple(['literal'], 
        // tslint:disable-next-line:no-any
        (args) => {
            const arg = args[0];
            return Helpers_1.str((arg.typeURL) ? arg.typeURL.value : '');
        }),
    },
    // --------------------------------------------------------------------------
    // Functions on strings
    // https://www.w3.org/TR/sparql11-query/#func-forms
    // --------------------------------------------------------------------------
    'strlen': {
        arity: 1,
        overloads: Helpers_1.forAll([['string'], ['langString']], (args) => Helpers_2.number(Helpers_1.unary(X.stringLength, args), Consts_1.TypeURL.XSD_INTEGER)),
    },
    'langmatches': {
        arity: 2,
        overloads: Helpers_1.simple(['string', 'string'], (args) => Helpers_2.bool(Helpers_2.binary(X.langMatches, args))),
    },
    'regex': {
        arity: [2, 3],
        // // TODO: This deviates from the spec, as the second and third argument should be simple literals
        overloads: Helpers_1.forAll([
            ['string', 'string'],
            ['langString', 'string'],
            ['string', 'string', 'string'],
            ['langString', 'string', 'string'],
        ], (args) => Helpers_2.bool(X.matches(args[0].typedValue, args[1].typedValue, ((args[2]) ? args[2].typedValue : '')))),
    },
    // --------------------------------------------------------------------------
    // Functions on numerics
    // https://www.w3.org/TR/sparql11-query/#func-numerics
    // --------------------------------------------------------------------------
    'abs': {
        arity: 1,
        overloads: Helpers_1.forAll([['term']], () => { throw new Errors_1.UnimplementedError('abs'); }),
    },
    // --------------------------------------------------------------------------
    // Functions on Dates and Times
    // https://www.w3.org/TR/sparql11-query/#func-date-time
    // --------------------------------------------------------------------------
    'now': {
        arity: 0,
        overloads: Helpers_1.simple(['term'], () => { throw new Errors_1.UnimplementedError('now function'); }),
    },
};
exports.definitions = immutable_1.Map(_definitions);
exports.specialDefinitions = immutable_1.Map(_specialDefinitions);
//# sourceMappingURL=RegularDefinitions.js.map