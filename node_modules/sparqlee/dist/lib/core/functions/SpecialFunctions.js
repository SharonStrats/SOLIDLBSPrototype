"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Promise = require("bluebird");
const C = require("../../util/Consts");
const Err = require("../../util/Errors");
const Helpers_1 = require("./Helpers");
const index_1 = require("./index");
const Types_1 = require("./Types");
class Bound extends Types_1.SpecialFunctionAsync {
    constructor() {
        super(...arguments);
        this.operator = C.Operator.BOUND;
    }
    apply(args, mapping, evaluate) {
        const variable = args[0];
        if (variable.expressionType !== 'variable') {
            throw new Err.InvalidArgumentTypes(args, C.Operator.BOUND);
        }
        const val = mapping.has(variable.name) && !!mapping.get(variable.name);
        return Promise.resolve(Helpers_1.bool(val));
    }
}
exports.Bound = Bound;
class If extends Types_1.SpecialFunctionAsync {
    constructor() {
        super(...arguments);
        this.operator = C.Operator.IF;
    }
    apply(args, mapping, evaluate) {
        const valFirstP = evaluate(args[0], mapping);
        return valFirstP.then((valFirst) => {
            const ebv = valFirst.coerceEBV();
            return (ebv)
                ? evaluate(args[1], mapping)
                : evaluate(args[2], mapping);
        });
    }
}
exports.If = If;
class Coalesce extends Types_1.SpecialFunctionAsync {
    constructor() {
        super(...arguments);
        this.operator = C.Operator.COALESCE;
    }
    apply(args, mapping, evaluate) {
        return Promise
            .mapSeries(args, (expr) => evaluate(expr, mapping)
            .then((term) => new CoalesceBreaker(term))
            .catch((err) => new CoalesceContinuer(err))
            .then((controller) => {
            if (controller.type === 'breaker') {
                throw controller;
            }
            else {
                return controller;
            }
        }))
            .map((continuer) => continuer.err)
            .then((errors) => { throw new Err.CoalesceError(errors); })
            .catch(CoalesceBreaker, (br) => {
            return br.val;
        });
    }
}
exports.Coalesce = Coalesce;
class CoalesceBreaker extends Error {
    constructor(val) {
        super();
        this.val = val;
        this.type = 'breaker';
    }
}
class CoalesceContinuer {
    constructor(err) {
        this.err = err;
        this.type = 'continuer';
    }
}
// TODO: Might benefit from some smart people's input
// https://www.w3.org/TR/sparql11-query/#func-logical-or
class LogicalOrAsync extends Types_1.SpecialFunctionAsync {
    constructor() {
        super(...arguments);
        this.operator = C.Operator.LOGICAL_OR;
    }
    apply(args, mapping, evaluate) {
        const [leftExpr, rightExpr] = args;
        return evaluate(leftExpr, mapping)
            .then((left) => left.coerceEBV())
            .then((left) => {
            if (left) {
                return Helpers_1.bool(true);
            }
            return evaluate(rightExpr, mapping)
                .then((right) => right.coerceEBV())
                .then((right) => Helpers_1.bool(right));
        })
            .catch((err) => {
            return evaluate(rightExpr, mapping)
                .then((right) => right.coerceEBV())
                .then((right) => {
                if (right) {
                    return Helpers_1.bool(true);
                }
                throw err;
            });
        });
    }
}
exports.LogicalOrAsync = LogicalOrAsync;
// https://www.w3.org/TR/sparql11-query/#func-logical-and
class LogicalAndAsync extends Types_1.SpecialFunctionAsync {
    constructor() {
        super(...arguments);
        this.operator = C.Operator.LOGICAL_AND;
    }
    apply(args, mapping, evaluate) {
        const [leftExpr, rightExpr] = args;
        return evaluate(leftExpr, mapping)
            .then((left) => left.coerceEBV())
            .then((left) => {
            if (!left) {
                return Helpers_1.bool(false);
            }
            return evaluate(rightExpr, mapping)
                .then((right) => right.coerceEBV())
                .then((right) => Helpers_1.bool(right));
        })
            .catch((err) => {
            return evaluate(rightExpr, mapping)
                .then((right) => right.coerceEBV())
                .then((right) => {
                if (!right) {
                    return Helpers_1.bool(false);
                }
                throw err;
            });
        });
    }
}
exports.LogicalAndAsync = LogicalAndAsync;
// Maybe put some place else
// https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal
function RDFTermEqual(_left, _right) {
    const left = _left.toRDF();
    const right = _right.toRDF();
    const val = left.equals(right);
    if ((left.termType === 'Literal') && (right.termType === 'Literal')) {
        throw new Err.RDFEqualTypeError([_left, _right]);
    }
    return val;
}
exports.RDFTermEqual = RDFTermEqual;
function sameTerm(left, right) {
    return left.toRDF().equals(right.toRDF());
}
exports.sameTerm = sameTerm;
class In extends Types_1.SpecialFunctionAsync {
    constructor() {
        super(...arguments);
        this.operator = C.Operator.IN;
    }
    apply(args, mapping, evaluate) {
        if (args.length < 1) {
            throw new Err.InvalidArity(args, C.Operator.IN);
        }
        const [left, ...remaining] = args;
        const thunks = remaining.map((expr) => () => evaluate(expr, mapping));
        return evaluate(left, mapping)
            .then((_left) => inR(_left, thunks, []));
    }
}
exports.In = In;
function inR(left, args, results) {
    if (args.length === 0) {
        return (results.every((v) => !v))
            ? Promise.resolve(Helpers_1.bool(false))
            : Promise.reject(new Err.InError(results));
    }
    const first = args.shift();
    return first()
        .then((v) => {
        const op = index_1.functions.get(C.Operator.EQUAL);
        return op.apply([left, v]);
    })
        .then((result) => (result.typedValue)
        ? Helpers_1.bool(true)
        : inR(left, args, [...results, false]), (err) => inR(left, args, [...results, err]));
}
class NotIn extends Types_1.SpecialFunctionAsync {
    constructor() {
        super(...arguments);
        this.operator = C.Operator.NOT_IN;
    }
    apply(args, mapping, evaluate) {
        return new In()
            .apply(args, mapping, evaluate)
            .then((term) => term.typedValue)
            .then((isIn) => Helpers_1.bool(!isIn));
    }
}
exports.NotIn = NotIn;
//# sourceMappingURL=SpecialFunctions.js.map