{"version":3,"file":"TypeHelpers.js","sourceRoot":"","sources":["../../../../lib/core/functions/TypeHelpers.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAEH,yCAA8C;AAE9C,uCAAuC;AACvC,yCAAyC;AACzC,oCAAoC;AAEpC,8CAAoD;AAGpD,SAAgB,OAAO;IACrB,OAAO,IAAI,OAAO,EAAE,CAAC;AACvB,CAAC;AAFD,0BAEC;AAED,MAAa,OAAO;IAApB;QACU,oBAAe,GAAW,EAAE,CAAC;QAC7B,UAAK,GAAG,CAAC,CAAC;IAqKpB,CAAC;IAnKC,OAAO;QACL,OAAO,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IACnC,CAAC;IAED,SAAS,CAAC,KAAa;QACrB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,GAAG,CAAC,KAAqB,EAAE,IAAyB;QAClD,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;IAC7C,CAAC;IAED,SAAS,CAAO,KAAqB,EAAE,EAA+B;QACpE,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,EAAE,KAAK,CAA+B,EAAE,EAAE;YACrE,OAAO,EAAE,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;QAC/C,CAAC,CAAC,CAAC;IACL,CAAC;IAED,UAAU,CAAa,KAAqB,EAAE,EAAoC;QAChF,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAgD,EAAE,EAAE;YACrF,OAAO,EAAE,CAAC,EAAE,CAAC,UAAU,EAAE,EAAE,CAAC,UAAU,EAAE,EAAE,CAAC,UAAU,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC;IACL,CAAC;IAED,aAAa,CAAC,GAAW;QACvB,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC7C,MAAM,IAAI,GAAG,CAAC,KAAa,EAAE,EAAE,GAAG,MAAM,IAAI,GAAG,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3E,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;IAC7C,CAAC;IAED,GAAG;QACD,sCAAsC;QACtC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAClC,OAAO,IAAI,CAAC;IACd,CAAC;IAED,GAAG,CAAC,IAAU;QACZ,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,OAAO,IAAI,CAAC;IACd,CAAC;IAED,OAAO,CAAC,EAAwB;QAC9B,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC;YACvB,KAAK,EAAE,CAAC,MAAM,CAAC;YACf,IAAI,EAAE,CAAC,CAAC,IAAI,CAAS,EAAE,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC;SACnC,CAAC,CAAC,CAAC;IACN,CAAC;IAED,UAAU,CAAI,EAA+B;QAC3C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,IAAI,CAAiB,EAAE,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;IACrE,CAAC;IAED,SAAS,CAAC,EAAoC;QAC5C,OAAO,IAAI;aACR,GAAG,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,GAAG,CAAsB,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;aACxD,GAAG,CAAC,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,CAAsB,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IAClE,CAAC;IAED;;;;MAIE;IACF,UAAU,CAAC,EAA2C;QACpD,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;QACf,MAAM,KAAK,GAAG,CAAC,EAAS,EAAE,EAAE,CAAC,CAC3B,CAAC,IAAY,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,gBAAI,CAAC,SAAS,CAAC,CACjE,CAAC;QACF,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;IAED,UAAU,CAAC,IAA8C;QACvD,MAAM,IAAI,GAAG,CAAC,CAAC,IAAI,EAAE,KAAK,CAAqB,EAAE,EAAE;YACjD,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;YACvD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;QACtB,CAAC,CAAC;QACF,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAED,UAAU,CAAC,IAA8C;QACvD,OAAO,IAAI;aACR,GAAG,CACF,CAAC,QAAQ,EAAE,QAAQ,CAAC,EACpB,CAAC,CAAC,IAAI,EAAE,KAAK,CAAoB,EAAE,EAAE;YACnC,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;YACvD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;QACtB,CAAC,CAAC;aACH,kBAAkB,CAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC;aAC5C,kBAAkB,CAAC,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;IAClD,CAAC;IAED,WAAW,CAAC,IAAgD;QAC1D,OAAO,IAAI;aACR,GAAG,CACF,CAAC,SAAS,EAAE,SAAS,CAAC,EACtB,CAAC,CAAC,IAAI,EAAE,KAAK,CAAqB,EAAE,EAAE;YACpC,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;YACvD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;QACtB,CAAC,CAAC;aACH,kBAAkB,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC;aAC7C,kBAAkB,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;IACnD,CAAC;IAED,YAAY,CAAC,IAA0C;QACrD,OAAO,IAAI;aACR,GAAG,CACF,CAAC,MAAM,EAAE,MAAM,CAAC,EAChB,CAAC,CAAC,IAAI,EAAE,KAAK,CAAsB,EAAE,EAAE;YACrC,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;YACvD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;QACtB,CAAC,CAAC;aACH,kBAAkB,CAAC,CAAC,SAAS,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC;aAC1C,kBAAkB,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;IAChD,CAAC;IAED,OAAO,CAAC,KAAgB;QACtB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;QACf,OAAO,IAAI;aACR,GAAG,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,KAAK,CAAC,gBAAI,CAAC,WAAW,CAAC,CAAC;aACpD,GAAG,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,KAAK,EAAE,CAAC;aACpC,GAAG,CAAC,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC;aAClC,GAAG,CAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,KAAK,EAAE,CAAC;aACnC,kBAAkB,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC;aAE7C,GAAG,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,KAAK,EAAE,CAAC;aACpC,GAAG,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,KAAK,CAAC,gBAAI,CAAC,WAAW,CAAC,CAAC;aACpD,GAAG,CAAC,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC;aAClC,GAAG,CAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,KAAK,EAAE,CAAC;aACnC,kBAAkB,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC;aAE7C,GAAG,CAAC,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,KAAK,EAAE,CAAC;aAClC,GAAG,CAAC,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,KAAK,EAAE,CAAC;aAClC,GAAG,CAAC,CAAC,OAAO,EAAE,OAAO,CAAC,EAAE,KAAK,CAAC,gBAAI,CAAC,SAAS,CAAC,CAAC;aAC9C,GAAG,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,KAAK,EAAE,CAAC;aACjC,kBAAkB,CAAC,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC;aAE3C,GAAG,CAAC,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,KAAK,EAAE,CAAC;aACnC,GAAG,CAAC,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,KAAK,EAAE,CAAC;aACnC,GAAG,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC;aACjC,GAAG,CAAC,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE,KAAK,CAAC,gBAAI,CAAC,UAAU,CAAC,CAAC;aACjD,kBAAkB,CAAC,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC;aAE5C,kBAAkB,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC;aAC7C,kBAAkB,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC;aAC7C,kBAAkB,CAAC,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC;aAC3C,kBAAkB,CAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;IAElD,CAAC;IAED,kBAAkB,CAAC,KAAqB,EAAE,KAAa;QACrD,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC;YACvB,KAAK;YACL,IAAI,CAAC,IAAY;gBACf,MAAM,IAAI,GAAG,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;YACxD,CAAC;SACF,CAAC,CAAC,CAAC;IACN,CAAC;IAEO,KAAK,CAAC,KAAa;QACzB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC1D,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAvKD,0BAuKC;AAED,SAAgB,KAAK;IACnB,OAAO,IAAI,WAAW,EAAE,CAAC;AAC3B,CAAC;AAFD,sBAEC;AAED,MAAa,WAAW;IAItB,KAAK;QACH,OAAO,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;IAC1D,CAAC;IAED,SAAS,CAAC,KAAqB;QAC7B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,UAAU,CAAC,IAAuD;QAChE,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,EAAE,KAAK,CAAqB,EAAE,EAAE;YAChD,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;QACjD,CAAC,CAAC;QACF,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAnBD,kCAmBC;AA4BD,MAAM,YAAY,GAAG;IACnB,KAAK,EAAE,EAAoB;IAC3B,IAAI;QACF,MAAM,GAAG,GAAG,oDAAoD,CAAC;QACjE,MAAM,IAAI,GAAG,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;IACrC,CAAC;CACF,CAAC;AAEF,MAAa,IAAK,SAAQ,kBAAM,CAAC,YAAY,CAAC;IAE5C,YAAY,MAAgB,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAEhD,GAAG,CAA2B,KAAQ;QACpC,OAAO,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAC1B,CAAC;IAED,MAAM;QACJ,OAAO,CAAC,gBAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;IACrD,CAAC;CACF;AAXD,oBAWC;AAED,SAAgB,GAAG,CAAC,eAAuB;IACzC,MAAM,YAAY,GAAG,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC;IAC5D,OAAO,eAAG,CAA0C,YAAY,CAAC,CAAC;AACpE,CAAC;AAHD,kBAGC;AAED,+EAA+E;AAC/E,+BAA+B;AAC/B,+EAA+E;AAE/E,SAAgB,IAAI,CAAC,GAAY;IAC/B,OAAO,IAAI,CAAC,CAAC,cAAc,CAAC,GAAG,EAAE,SAAS,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAI,CAAC,WAAW,CAAC,CAAC,CAAC;AACxE,CAAC;AAFD,oBAEC;AAED,SAAgB,MAAM,CAAC,GAAW,EAAE,EAAc;IAChD,OAAO,IAAI,CAAC,CAAC,cAAc,CAAC,GAAG,EAAE,SAAS,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,IAAI,gBAAI,CAAC,SAAS,CAAC,CAAC,CAAC;AAC5E,CAAC;AAFD,wBAEC;AAED,SAAgB,GAAG,CAAC,CAAS;IAC3B,OAAO,IAAI,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC;AAFD,kBAEC;AAED,SAAgB,IAAI,CAAC,GAAG,IAAoB;IAC1C,OAAO,gBAAI,CAAC,IAAI,CAAC,CAAC;AACpB,CAAC;AAFD,oBAEC;AAQD,SAAgB,MAAM,CAAC,KAAqB,EAAE,IAAyB;IACrE,OAAO,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC;AAFD,wBAEC;AAED,SAAgB,MAAM,CAAC,QAA0B,EAAE,IAAyB;IAC1E,OAAO,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;AACjE,CAAC;AAFD,wBAEC;AAQD,SAAgB,UAAU,CAAC,EAAsB;IAC/C,MAAM,IAAI,GAAG,CAAC,EAAS,EAAE,EAAE,CAAC,CAC1B,CAAC,IAAY,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,gBAAI,CAAC,SAAS,CAAC,CACjE,CAAC;IACF,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;AAC5B,CAAC;AALD,gCAKC;AASD,SAAgB,SAAS,CACvB,KAAwB,EACxB,KAAwB,EACxB,MAA0B,EAC1B,MAAuB;IAEvB,MAAM,aAAa,GAAG,CAAC,IAAY,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;IAElE,MAAM,IAAI,GAAG,CAAI,IAAkB,EAAE,EAAE,CAAC,CAAC,IAAY,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;IACnF,OAAO,GAAG,CAAC;QACT,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QAC5D,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;QAC/D,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;QAEzD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACxE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACvE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACxE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,MAAM,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACrE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACvE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACxE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;KAEtE,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC;AAvBD,8BAuBC;AAID;;;GAGG;AACH,SAAgB,OAAO,CAAC,KAAgB;IACtC,OAAO;QACL,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,gBAAI,CAAC,WAAW,CAAC,EAAE,CAAC;QAC1E,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QAC1D,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACxD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACzD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QAExE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QAC1D,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,gBAAI,CAAC,WAAW,CAAC,EAAE,CAAC;QAC1E,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACxD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACzD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QAExE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACxD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACxD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,gBAAI,CAAC,SAAS,CAAC,EAAE,CAAC;QACpE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACvD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QAEtE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACzD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACzD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QACvD,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,gBAAI,CAAC,UAAU,CAAC,EAAE,CAAC;QACvE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QAEvE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACxE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACxE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;QACtE,IAAI,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC;KACxE,CAAC;AACJ,CAAC;AA/BD,0BA+BC;AAGD,SAAgB,KAAK,CAAO,EAAqB,EAAE,IAAwB;IACzE,MAAM,CAAC,GAAG,CAAC,GAAG,IAA2B,CAAC;IAC1C,OAAO,EAAE,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;AAC5B,CAAC;AAHD,sBAGC;AAGD,SAAgB,MAAM,CAAO,EAAsB,EAAE,IAAwB;IAC3E,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,IAA2B,CAAC;IAClD,OAAO,EAAE,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;AAC/C,CAAC;AAHD,wBAGC;AAED,+CAA+C;AAC/C,sFAAsF;AACtF,+CAA+C;AAC/C,+BAA+B;AAC/B,IAAI;AAEJ,SAAS,kBAAkB,CAAC,KAAa;IACvC,OAAO,CAAC,IAAY,EAAE,EAAE;QACtB,MAAM,IAAI,GAAG,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;IAC5D,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\n\nimport { List, Map, Record } from 'immutable';\n\nimport * as C from '../../util/Consts';\nimport * as Err from '../../util/Errors';\nimport * as E from '../Expressions';\n\nimport { TypeURL as Type } from '../../util/Consts';\nimport { ArgumentType, OverloadMap } from './RegularFunctions';\n\nexport function declare(): Builder {\n  return new Builder();\n}\n\nexport class Builder {\n  private implementations: Impl[] = [];\n  private arity = 1;\n\n  collect(): OverloadMap {\n    return map(this.implementations);\n  }\n\n  withArity(arity: number): Builder {\n    this.arity = arity;\n    return this;\n  }\n\n  set(types: ArgumentType[], func: E.SimpleApplication): Builder {\n    return this.add(new Impl({ types, func }));\n  }\n\n  setBinary<L, R>(types: ArgumentType[], op: (left: L, right: R) => Term) {\n    return this.set(types, ([left, right]: [E.Literal<L>, E.Literal<R>]) => {\n      return op(left.typedValue, right.typedValue);\n    });\n  }\n\n  setTernary<A1, A2, A3>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term) {\n    return this.set(types, ([a1, a2, a3]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>]) => {\n      return op(a1.typedValue, a2.typedValue, a3.typedValue);\n    });\n  }\n\n  unimplemented(msg: string): Builder {\n    const types = Array(this.arity).fill('term');\n    const func = (_args: Term[]) => { throw new Err.UnimplementedError(msg); };\n    return this.add(new Impl({ types, func }));\n  }\n\n  log(): Builder {\n    // tslint:disable-next-line:no-console\n    console.log(this.implementations);\n    return this;\n  }\n\n  add(impl: Impl): Builder {\n    this.implementations.push(impl);\n    return this;\n  }\n\n  onTerm1(op: (term: Term) => Term): Builder {\n    return this.add(new Impl({\n      types: ['term'],\n      func: ([term]: [Term]) => op(term),\n    }));\n  }\n\n  onLiteral1<T>(op: (lit: E.Literal<T>) => Term): Builder {\n    return this.set(['literal'], ([term]: [E.Literal<T>]) => op(term));\n  }\n\n  onString1(op: (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit))\n      .set(['langString'], ([lit]: [E.Literal<string>]) => op(lit));\n  }\n\n  /*\n  * Arithetic Operators take numbers, and return numbers.\n  * Check 'numeric' for behaviour of the generic numeric helper.\n  * https://www.w3.org/TR/sparql11-query/#OperatorMapping\n  */\n  arithmetic(op: (left: number, right: number) => number): Builder {\n    this.arity = 2;\n    const opFac = (dt?: Type) => (\n      (args: Term[]) => number(binary(op, args), dt || Type.XSD_FLOAT)\n    );\n    return this.numeric(opFac);\n  }\n\n  numberTest(test: (left: number, right: number) => boolean): Builder {\n    const func = ([left, right]: E.NumericLiteral[]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    };\n    return this.numeric(() => func);\n  }\n\n  stringTest(test: (left: string, right: string) => boolean): Builder {\n    return this\n      .set(\n        ['string', 'string'],\n        ([left, right]: E.StringLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['invalid', 'string'], 1)\n      .invalidLexicalForm(['string', 'invalid'], 2);\n  }\n\n  booleanTest(test: (left: boolean, right: boolean) => boolean): Builder {\n    return this\n      .set(\n        ['boolean', 'boolean'],\n        ([left, right]: E.BooleanLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['invalid', 'boolean'], 1)\n      .invalidLexicalForm(['boolean', 'invalid'], 2);\n  }\n\n  dateTimeTest(test: (left: Date, right: Date) => boolean): Builder {\n    return this\n      .set(\n        ['date', 'date'],\n        ([left, right]: E.DateTimeLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['invalid', 'date'], 1)\n      .invalidLexicalForm(['date', 'invalid'], 2);\n  }\n\n  numeric(opFac: OpFactory): Builder {\n    this.arity = 2;\n    return this\n      .set(['integer', 'integer'], opFac(Type.XSD_INTEGER))\n      .set(['integer', 'decimal'], opFac())\n      .set(['integer', 'float'], opFac())\n      .set(['integer', 'double'], opFac())\n      .invalidLexicalForm(['integer', 'invalid'], 2)\n\n      .set(['decimal', 'integer'], opFac())\n      .set(['decimal', 'decimal'], opFac(Type.XSD_DECIMAL))\n      .set(['decimal', 'float'], opFac())\n      .set(['decimal', 'double'], opFac())\n      .invalidLexicalForm(['decimal', 'invalid'], 2)\n\n      .set(['float', 'integer'], opFac())\n      .set(['float', 'decimal'], opFac())\n      .set(['float', 'float'], opFac(Type.XSD_FLOAT))\n      .set(['float', 'double'], opFac())\n      .invalidLexicalForm(['float', 'invalid'], 2)\n\n      .set(['double', 'integer'], opFac())\n      .set(['double', 'decimal'], opFac())\n      .set(['double', 'float'], opFac())\n      .set(['double', 'double'], opFac(Type.XSD_DOUBLE))\n      .invalidLexicalForm(['double', 'invalid'], 2)\n\n      .invalidLexicalForm(['invalid', 'integer'], 1)\n      .invalidLexicalForm(['invalid', 'decimal'], 1)\n      .invalidLexicalForm(['invalid', 'float'], 1)\n      .invalidLexicalForm(['invalid', 'double'], 1);\n\n  }\n\n  invalidLexicalForm(types: ArgumentType[], index: number): Builder {\n    return this.add(new Impl({\n      types,\n      func(args: Term[]): E.TermExpression {\n        throw new Err.InvalidLexicalForm(args[index].toRDF());\n      },\n    }));\n  }\n\n  private chain(impls: Impl[]): Builder {\n    this.implementations = this.implementations.concat(impls);\n    return this;\n  }\n}\n\nexport function _impl(): ImplBuilder {\n  return new ImplBuilder();\n}\n\nexport class ImplBuilder {\n  private types: ArgumentType[];\n  private func: E.SimpleApplication;\n\n  build(): Impl {\n    return new Impl({ types: this.types, func: this.func });\n  }\n\n  withTypes(types: ArgumentType[]): ImplBuilder {\n    this.types = types;\n    return this;\n  }\n\n  arithmetic(func: (left: number, right: number) => E.NumericLiteral): ImplBuilder {\n    this.func = ([left, right]: E.NumericLiteral[]) => {\n      return func(left.typedValue, right.typedValue);\n    };\n    return this;\n  }\n}\n\n// export type BinLiteralOp<T, R> = (left: T, right: T) => R;\n// export function binary<T, R>(op: BinLiteralOp<T, R>, args: E.TermExpression[]): R {\n//   const [left, right] = args as Array<E.Literal<T>>;\n//   return op(left.typedValue, right.typedValue);\n// }\n\n// ----------------------------------------------------------------------------\n// Type Safety Helpers\n// ----------------------------------------------------------------------------\n\n/**\n * Immutable.js type definitions are pretty unsafe, and this is typo-prone work.\n * These helpers allow use to create OverloadMaps with more type-safety.\n * One entry in the OverloadMap is described by the record Impl;\n *\n * A list of Impl's then gets constructed into an Immutable.js Map.\n *\n * See:\n * https://medium.com/@alexxgent/enforcing-types-with-immutablejs-and-typescript-6ab980819b6a\n */\n\nexport type ImplType = {\n  types: ArgumentType[];\n  func: E.SimpleApplication;\n};\n\nconst implDefaults = {\n  types: [] as ArgumentType[],\n  func() {\n    const msg = 'Implementation not set yet declared as implemented';\n    throw new Err.UnexpectedError(msg);\n  },\n};\n\nexport class Impl extends Record(implDefaults) {\n\n  constructor(params: ImplType) { super(params); }\n\n  get<T extends keyof ImplType>(value: T): ImplType[T] {\n    return super.get(value);\n  }\n\n  toPair(): [List<ArgumentType>, E.SimpleApplication] {\n    return [List(this.get('types')), this.get('func')];\n  }\n}\n\nexport function map(implementations: Impl[]): OverloadMap {\n  const typeImplPair = implementations.map((i) => i.toPair());\n  return Map<List<ArgumentType>, E.SimpleApplication>(typeImplPair);\n}\n\n// ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nexport function bool(val: boolean): E.BooleanLiteral {\n  return new E.BooleanLiteral(val, undefined, C.make(Type.XSD_BOOLEAN));\n}\n\nexport function number(num: number, dt?: C.TypeURL): E.NumericLiteral {\n  return new E.NumericLiteral(num, undefined, C.make(dt || Type.XSD_FLOAT));\n}\n\nexport function str(s: string): E.StringLiteral {\n  return new E.StringLiteral(s);\n}\n\nexport function list(...args: ArgumentType[]) {\n  return List(args);\n}\n\n// ----------------------------------------------------------------------------\n// Shorthands\n// ----------------------------------------------------------------------------\n\ntype Term = E.TermExpression;\n\nexport function simple(types: ArgumentType[], func: E.SimpleApplication): OverloadMap {\n  return map([new Impl({ types, func })]);\n}\n\nexport function forAll(allTypes: ArgumentType[][], func: E.SimpleApplication): OverloadMap {\n  return map(allTypes.map((types) => new Impl({ types, func })));\n}\n\n/*\n* Arithetic Operators take numbers, and return numbers.\n* Check 'numeric' for behaviour of the generic numeric helper.\n* https://www.w3.org/TR/sparql11-query/#OperatorMapping\n*/\nexport type ArithmeticOperator = (left: number, right: number) => number;\nexport function arithmetic(op: ArithmeticOperator): OverloadMap {\n  const func = (dt?: Type) => (\n    (args: Term[]) => number(binary(op, args), dt || Type.XSD_FLOAT)\n  );\n  return map(numeric(func));\n}\n\n/*\n * XPath Tests take numbers, booleans, strings, simple strings, and dates,\n * and they return booleans.\n * Check 'numeric' for behaviour of the generic numeric helper.\n * https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\nexport type XPathTest<T> = (left: T, right: T) => boolean;\nexport function xPathTest(\n  numOp: XPathTest<number>,\n  strOp: XPathTest<string>,\n  boolOp: XPathTest<boolean>,\n  dateOp: XPathTest<Date>,\n): OverloadMap {\n  const numericHelper = (args: Term[]) => bool(binary(numOp, args));\n\n  const wrap = <T>(func: XPathTest<T>) => (args: Term[]) => bool(binary(func, args));\n  return map([\n    new Impl({ types: ['string', 'string'], func: wrap(strOp) }),\n    new Impl({ types: ['boolean', 'boolean'], func: wrap(boolOp) }),\n    new Impl({ types: ['date', 'date'], func: wrap(dateOp) }),\n\n    new Impl({ types: ['invalid', 'invalid'], func: invalidLexicalForm(1) }),\n    new Impl({ types: ['invalid', 'string'], func: invalidLexicalForm(1) }),\n    new Impl({ types: ['invalid', 'boolean'], func: invalidLexicalForm(1) }),\n    new Impl({ types: ['invalid', 'date'], func: invalidLexicalForm(1) }),\n    new Impl({ types: ['string', 'invalid'], func: invalidLexicalForm(2) }),\n    new Impl({ types: ['boolean', 'invalid'], func: invalidLexicalForm(2) }),\n    new Impl({ types: ['date', 'invalid'], func: invalidLexicalForm(2) }),\n\n  ].concat(numeric(() => numericHelper)));\n}\n\nexport type OpFactory = (dt?: C.TypeURL) => E.SimpleApplication;\n\n/**\n * DataType will be generalized to float,\n * or to the the category-parent (interger, decimal, ...) if both have the same.\n */\nexport function numeric(opFac: OpFactory): Impl[] {\n  return [\n    new Impl({ types: ['integer', 'integer'], func: opFac(Type.XSD_INTEGER) }),\n    new Impl({ types: ['integer', 'decimal'], func: opFac() }),\n    new Impl({ types: ['integer', 'float'], func: opFac() }),\n    new Impl({ types: ['integer', 'double'], func: opFac() }),\n    new Impl({ types: ['integer', 'invalid'], func: invalidLexicalForm(2) }),\n\n    new Impl({ types: ['decimal', 'integer'], func: opFac() }),\n    new Impl({ types: ['decimal', 'decimal'], func: opFac(Type.XSD_DECIMAL) }),\n    new Impl({ types: ['decimal', 'float'], func: opFac() }),\n    new Impl({ types: ['decimal', 'double'], func: opFac() }),\n    new Impl({ types: ['decimal', 'invalid'], func: invalidLexicalForm(2) }),\n\n    new Impl({ types: ['float', 'integer'], func: opFac() }),\n    new Impl({ types: ['float', 'decimal'], func: opFac() }),\n    new Impl({ types: ['float', 'float'], func: opFac(Type.XSD_FLOAT) }),\n    new Impl({ types: ['float', 'double'], func: opFac() }),\n    new Impl({ types: ['float', 'invalid'], func: invalidLexicalForm(2) }),\n\n    new Impl({ types: ['double', 'integer'], func: opFac() }),\n    new Impl({ types: ['double', 'decimal'], func: opFac() }),\n    new Impl({ types: ['double', 'float'], func: opFac() }),\n    new Impl({ types: ['double', 'double'], func: opFac(Type.XSD_DOUBLE) }),\n    new Impl({ types: ['double', 'invalid'], func: invalidLexicalForm(2) }),\n\n    new Impl({ types: ['invalid', 'integer'], func: invalidLexicalForm(1) }),\n    new Impl({ types: ['invalid', 'decimal'], func: invalidLexicalForm(1) }),\n    new Impl({ types: ['invalid', 'float'], func: invalidLexicalForm(1) }),\n    new Impl({ types: ['invalid', 'double'], func: invalidLexicalForm(1) }),\n  ];\n}\n\nexport type UnLiteralOp<T, R> = (val: T) => R;\nexport function unary<T, R>(op: UnLiteralOp<T, R>, args: E.TermExpression[]): R {\n  const [val] = args as Array<E.Literal<T>>;\n  return op(val.typedValue);\n}\n\nexport type BinLiteralOp<T, R> = (left: T, right: T) => R;\nexport function binary<T, R>(op: BinLiteralOp<T, R>, args: E.TermExpression[]): R {\n  const [left, right] = args as Array<E.Literal<T>>;\n  return op(left.typedValue, right.typedValue);\n}\n\n// export type TernaryOp<T, R> = (val: T) => R;\n// export function ternary<T, R>(op: UnLiteralOp<T, R>, args: E.TermExpression[]): R {\n//   const [val] = args as Array<E.Literal<T>>;\n//   return op(val.typedValue);\n// }\n\nfunction invalidLexicalForm(index: number) {\n  return (args: Term[]) => {\n    throw new Err.InvalidLexicalForm(args[index - 1].toRDF());\n  };\n}\n"]}