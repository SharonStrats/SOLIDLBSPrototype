import * as Promise from 'bluebird';
import { List, Map } from 'immutable';
import * as C from '../../util/Consts';
import * as E from '../Expressions';
import { Bindings } from '../Types';
export declare type ArgumentType = 'term' | E.TermType | C.DataTypeCategory;
export declare type TypeChecker = (args: E.TermExpression[]) => boolean;
export declare class SimpleFunction implements E.SimpleFunc {
    operator: C.Operator;
    arity: number;
    types: ArgumentType[];
    protected _apply: (args: E.TermExpression[]) => E.TermExpression;
    functionClass: 'simple';
    constructor(operator: C.Operator, arity: number, types: ArgumentType[], _apply: (args: E.TermExpression[]) => E.TermExpression);
    apply(args: E.TermExpression[]): E.TermExpression;
    private _isValidTypes;
}
export declare type OverloadMap = Map<List<ArgumentType>, E.SimpleApplication>;
export declare class OverloadedFunction implements E.OverloadedFunc {
    operator: C.Operator;
    arity: number | number[];
    private overloadMap;
    functionClass: 'overloaded';
    constructor(operator: C.Operator, arity: number | number[], overloadMap: OverloadMap);
    apply(args: E.TermExpression[]): E.TermExpression;
    private _monomorph;
}
export declare abstract class SpecialFunctionAsync implements E.SpecialFunc {
    functionClass: 'special';
    abstract operator: C.Operator;
    abstract apply(args: E.Expression[], mapping: Bindings, evaluate: (e: E.Expression, mapping: Bindings) => Promise<E.TermExpression>): Promise<E.TermExpression>;
}
