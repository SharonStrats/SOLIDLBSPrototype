{"version":3,"file":"RegularDefinitions.js","sourceRoot":"","sources":["../../../../lib/core/functions/RegularDefinitions.ts"],"names":[],"mappings":"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","sourcesContent":["import { Map } from 'immutable';\nimport { expand, forAll, simple, str, unary } from './Helpers';\n\nimport * as C from '../../util/Consts';\nimport * as E from '../Expressions';\nimport * as Special from './SpecialFunctions';\nimport * as X from './XPath';\n\nimport { TypeURL as DT } from '../../util/Consts';\nimport { ExpressionError, UnimplementedError } from '../../util/Errors';\nimport { arithmetic, binary, bool, list, number, xPathTest } from './Helpers';\nimport { OverloadMap, SpecialFunctionAsync } from './types';\n\n\n// ----------------------------------------------------------------------------\n// The definitions and functionality for all operators\n// ----------------------------------------------------------------------------\n\ntype Term = E.TermExpression;\n\n// TODO Maybe split in definitions for overloaded and async functions.\nconst _definitions: { [key in C.Operator]: Definition } = {\n  // --------------------------------------------------------------------------\n  // Operator Mapping\n  // https://www.w3.org/TR/sparql11-query/#OperatorMapping\n  // --------------------------------------------------------------------------\n  '!': {\n    arity: 1,\n    overloads: simple(\n      ['term'],\n      () => { throw new UnimplementedError('! operator'); },\n    ),\n  },\n  'UPLUS': {\n    arity: 1,\n    overloads: simple(\n      ['term'],\n      () => { throw new UnimplementedError('Unary plus operator'); },\n    ),\n  },\n  'UMINUS': {\n    arity: 1,\n    overloads: simple(\n      ['term'],\n      () => { throw new UnimplementedError('Unary minus operator'); },\n    ),\n  },\n  '*': {\n    arity: 2,\n    overloads: arithmetic(X.numericMultiply),\n  },\n  '/': {\n    arity: 2,\n    overloads: arithmetic(X.numericDivide).set(\n      list('integer', 'integer'),\n      (args: Term[]) => {\n        if ((args[1] as E.NumericLiteral).typedValue === 0) {\n          throw new ExpressionError('Integer division by 0');\n        }\n        return number(binary(X.numericDivide, args), DT.XSD_DECIMAL);\n      },\n    ),\n  },\n  '+': {\n    arity: 2,\n    overloads: arithmetic(X.numericAdd),\n  },\n  '-': {\n    arity: 2,\n    overloads: arithmetic(X.numericSubtract),\n  },\n  '=': {\n    arity: 2,\n    overloads: xPathTest(\n      X.numericEqual,\n      (left, right) => X.numericEqual(X.compare(left, right), 0),\n      X.booleanEqual,\n      X.dateTimeEqual,\n    ).set(\n      list('term', 'term'),\n      (args: Term[]) => {\n        return bool(Special.RDFTermEqual(args[0], args[1]));\n      },\n    ),\n  },\n  '!=': {\n    arity: 2,\n    overloads: xPathTest(\n      (left, right) => !X.numericEqual(left, right),\n      (left, right) => !X.numericEqual(X.compare(left, right), 0),\n      (left, right) => !X.booleanEqual(left, right),\n      (left, right) => !X.dateTimeEqual(left, right),\n    ),\n  },\n  '<': {\n    arity: 2,\n    overloads: xPathTest(\n      X.numericLessThan,\n      (left, right) => X.numericEqual(X.compare(left, right), -1),\n      X.booleanLessThan,\n      X.dateTimeLessThan,\n    ),\n  },\n  '>': {\n    arity: 2,\n    overloads: xPathTest(\n      X.numericGreaterThan,\n      (left, right) => X.numericEqual(X.compare(left, right), 1),\n      X.booleanGreaterThan,\n      X.dateTimeGreaterThan,\n    ),\n  },\n  '<=': {\n    arity: 2,\n    overloads: xPathTest(\n      (left, right) => X.numericLessThan(left, right) || X.numericEqual(left, right),\n      (left, right) => !X.numericEqual(X.compare(left, right), 1),\n      (left, right) => !X.booleanGreaterThan(left, right),\n      (left, right) => !X.dateTimeGreaterThan(left, right),\n    ),\n  },\n  '>=': {\n    arity: 2,\n    overloads: xPathTest(\n      (left, right) => X.numericGreaterThan(left, right) || X.numericEqual(left, right),\n      (left, right) => !X.numericEqual(X.compare(left, right), -1),\n      (left, right) => !X.booleanLessThan(left, right),\n      (left, right) => !X.dateTimeLessThan(left, right),\n    ),\n  },\n  // --------------------------------------------------------------------------\n  // Functions on RDF Terms\n  // https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n  // --------------------------------------------------------------------------\n  'str': {\n    arity: 1,\n    overloads: simple(\n      ['term'],\n      (args: Term[]) => str(args[0].str()),\n    ),\n  },\n  'lang': {\n    arity: 1,\n    overloads: simple(\n      ['literal'],\n      (args: Array<E.Literal<string>>) => str(args[0].language || ''),\n    ),\n  },\n  'datatype': {\n    arity: 1,\n    overloads: simple(\n      ['literal'],\n      // tslint:disable-next-line:no-any\n      (args: Array<E.Literal<any>>) => {\n        const arg = args[0];\n        return str((arg.typeURL) ? arg.typeURL.value : '');\n      },\n    ),\n  },\n  // --------------------------------------------------------------------------\n  // Functions on strings\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'strlen': {\n    arity: 1,\n    overloads: forAll(\n      [['string'], ['langString']],\n      (args: Term[]) => number(unary(X.stringLength, args), DT.XSD_INTEGER),\n    ),\n  },\n  'langmatches': {\n    arity: 2,\n    overloads: simple(\n      ['string', 'string'],\n      (args: Term[]) => bool(binary(X.langMatches, args)),\n    ),\n  },\n  'regex': {\n    arity: [2, 3],\n    // // TODO: This deviates from the spec, as the second and third argument should be simple literals\n    overloads: forAll(\n      [\n        ['string', 'string'],\n        ['langString', 'string'],\n        ['string', 'string', 'string'],\n        ['langString', 'string', 'string'],\n      ],\n      (args: Array<E.Literal<string>>) => bool(X.matches(\n        args[0].typedValue,\n        args[1].typedValue,\n        ((args[2]) ? args[2].typedValue : ''),\n      )),\n    ),\n  },\n\n  // --------------------------------------------------------------------------\n  // Functions on numerics\n  // https://www.w3.org/TR/sparql11-query/#func-numerics\n  // --------------------------------------------------------------------------\n  'abs': {\n    arity: 1,\n    overloads: forAll(\n      [['term']],\n      () => { throw new UnimplementedError('abs'); },\n    ),\n  },\n\n  // --------------------------------------------------------------------------\n  // Functions on Dates and Times\n  // https://www.w3.org/TR/sparql11-query/#func-date-time\n  // --------------------------------------------------------------------------\n  'now': {\n    arity: 0,\n    overloads: simple(\n      ['term'],\n      () => { throw new UnimplementedError('now function'); },\n    ),\n  },\n\n  // --------------------------------------------------------------------------\n  // Hash functions\n  // https://www.w3.org/TR/sparql11-query/#func-hash\n  // --------------------------------------------------------------------------\n\n  // --------------------------------------------------------------------------\n  // XPath Constructor functions\n  // https://www.w3.org/TR/sparql11-query/#FunctionMapping\n  // --------------------------------------------------------------------------\n};\n\nexport const definitions = Map<C.Operator, Definition>(_definitions);\nexport const specialDefinitions = Map<C.SpecialOperator, SpecialDefinition>(_specialDefinitions);\n"]}