"use strict";
/**
 * These helpers provide a (albeit inflexible) DSL for writing function
 * definitions for the SPARQL functions.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
const C = require("../../util/Consts");
const Err = require("../../util/Errors");
const E = require("../Expressions");
const Consts_1 = require("../../util/Consts");
function declare() {
    return new Builder();
}
exports.declare = declare;
class Builder {
    constructor() {
        this.implementations = [];
        this.arity = 1;
    }
    collect() {
        return map(this.implementations);
    }
    withArity(arity) {
        this.arity = arity;
        return this;
    }
    set(types, func) {
        return this.add(new Impl({ types, func }));
    }
    setBinary(types, op) {
        return this.set(types, ([left, right]) => {
            return op(left.typedValue, right.typedValue);
        });
    }
    setTernary(types, op) {
        return this.set(types, ([a1, a2, a3]) => {
            return op(a1.typedValue, a2.typedValue, a3.typedValue);
        });
    }
    unimplemented(msg) {
        const types = Array(this.arity).fill('term');
        const func = (_args) => { throw new Err.UnimplementedError(msg); };
        return this.add(new Impl({ types, func }));
    }
    log() {
        // tslint:disable-next-line:no-console
        console.log(this.implementations);
        return this;
    }
    add(impl) {
        this.implementations.push(impl);
        return this;
    }
    onTerm1(op) {
        return this.add(new Impl({
            types: ['term'],
            func: ([term]) => op(term),
        }));
    }
    onLiteral1(op) {
        return this.set(['literal'], ([term]) => op(term));
    }
    onString1(op) {
        return this
            .set(['string'], ([lit]) => op(lit))
            .set(['langString'], ([lit]) => op(lit));
    }
    /*
    * Arithetic Operators take numbers, and return numbers.
    * Check 'numeric' for behaviour of the generic numeric helper.
    * https://www.w3.org/TR/sparql11-query/#OperatorMapping
    */
    arithmetic(op) {
        this.arity = 2;
        const opFac = (dt) => ((args) => number(binary(op, args), dt || Consts_1.TypeURL.XSD_FLOAT));
        return this.numeric(opFac);
    }
    numberTest(test) {
        const func = ([left, right]) => {
            const result = test(left.typedValue, right.typedValue);
            return bool(result);
        };
        return this.numeric(() => func);
    }
    stringTest(test) {
        return this
            .set(['string', 'string'], ([left, right]) => {
            const result = test(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm(['invalid', 'string'], 1)
            .invalidLexicalForm(['string', 'invalid'], 2);
    }
    booleanTest(test) {
        return this
            .set(['boolean', 'boolean'], ([left, right]) => {
            const result = test(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm(['invalid', 'boolean'], 1)
            .invalidLexicalForm(['boolean', 'invalid'], 2);
    }
    dateTimeTest(test) {
        return this
            .set(['date', 'date'], ([left, right]) => {
            const result = test(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm(['invalid', 'date'], 1)
            .invalidLexicalForm(['date', 'invalid'], 2);
    }
    numeric(opFac) {
        this.arity = 2;
        return this
            .set(['integer', 'integer'], opFac(Consts_1.TypeURL.XSD_INTEGER))
            .set(['integer', 'decimal'], opFac())
            .set(['integer', 'float'], opFac())
            .set(['integer', 'double'], opFac())
            .invalidLexicalForm(['integer', 'invalid'], 2)
            .set(['decimal', 'integer'], opFac())
            .set(['decimal', 'decimal'], opFac(Consts_1.TypeURL.XSD_DECIMAL))
            .set(['decimal', 'float'], opFac())
            .set(['decimal', 'double'], opFac())
            .invalidLexicalForm(['decimal', 'invalid'], 2)
            .set(['float', 'integer'], opFac())
            .set(['float', 'decimal'], opFac())
            .set(['float', 'float'], opFac(Consts_1.TypeURL.XSD_FLOAT))
            .set(['float', 'double'], opFac())
            .invalidLexicalForm(['float', 'invalid'], 2)
            .set(['double', 'integer'], opFac())
            .set(['double', 'decimal'], opFac())
            .set(['double', 'float'], opFac())
            .set(['double', 'double'], opFac(Consts_1.TypeURL.XSD_DOUBLE))
            .invalidLexicalForm(['double', 'invalid'], 2)
            .invalidLexicalForm(['invalid', 'integer'], 1)
            .invalidLexicalForm(['invalid', 'decimal'], 1)
            .invalidLexicalForm(['invalid', 'float'], 1)
            .invalidLexicalForm(['invalid', 'double'], 1);
    }
    invalidLexicalForm(types, index) {
        return this.add(new Impl({
            types,
            func(args) {
                throw new Err.InvalidLexicalForm(args[index].toRDF());
            },
        }));
    }
    chain(impls) {
        this.implementations = this.implementations.concat(impls);
        return this;
    }
}
exports.Builder = Builder;
function _impl() {
    return new ImplBuilder();
}
exports._impl = _impl;
class ImplBuilder {
    build() {
        return new Impl({ types: this.types, func: this.func });
    }
    withTypes(types) {
        this.types = types;
        return this;
    }
    arithmetic(func) {
        this.func = ([left, right]) => {
            return func(left.typedValue, right.typedValue);
        };
        return this;
    }
}
exports.ImplBuilder = ImplBuilder;
const implDefaults = {
    types: [],
    func() {
        const msg = 'Implementation not set yet declared as implemented';
        throw new Err.UnexpectedError(msg);
    },
};
class Impl extends immutable_1.Record(implDefaults) {
    constructor(params) { super(params); }
    get(value) {
        return super.get(value);
    }
    toPair() {
        return [immutable_1.List(this.get('types')), this.get('func')];
    }
}
exports.Impl = Impl;
function map(implementations) {
    const typeImplPair = implementations.map((i) => i.toPair());
    return immutable_1.Map(typeImplPair);
}
exports.map = map;
// ----------------------------------------------------------------------------
// Literal Construction helpers
// ----------------------------------------------------------------------------
function bool(val) {
    return new E.BooleanLiteral(val, undefined, C.make(Consts_1.TypeURL.XSD_BOOLEAN));
}
exports.bool = bool;
function number(num, dt) {
    return new E.NumericLiteral(num, undefined, C.make(dt || Consts_1.TypeURL.XSD_FLOAT));
}
exports.number = number;
function str(s) {
    return new E.StringLiteral(s);
}
exports.str = str;
function list(...args) {
    return immutable_1.List(args);
}
exports.list = list;
function simple(types, func) {
    return map([new Impl({ types, func })]);
}
exports.simple = simple;
function forAll(allTypes, func) {
    return map(allTypes.map((types) => new Impl({ types, func })));
}
exports.forAll = forAll;
function arithmetic(op) {
    const func = (dt) => ((args) => number(binary(op, args), dt || Consts_1.TypeURL.XSD_FLOAT));
    return map(numeric(func));
}
exports.arithmetic = arithmetic;
function xPathTest(numOp, strOp, boolOp, dateOp) {
    const numericHelper = (args) => bool(binary(numOp, args));
    const wrap = (func) => (args) => bool(binary(func, args));
    return map([
        new Impl({ types: ['string', 'string'], func: wrap(strOp) }),
        new Impl({ types: ['boolean', 'boolean'], func: wrap(boolOp) }),
        new Impl({ types: ['date', 'date'], func: wrap(dateOp) }),
        new Impl({ types: ['invalid', 'invalid'], func: invalidLexicalForm(1) }),
        new Impl({ types: ['invalid', 'string'], func: invalidLexicalForm(1) }),
        new Impl({ types: ['invalid', 'boolean'], func: invalidLexicalForm(1) }),
        new Impl({ types: ['invalid', 'date'], func: invalidLexicalForm(1) }),
        new Impl({ types: ['string', 'invalid'], func: invalidLexicalForm(2) }),
        new Impl({ types: ['boolean', 'invalid'], func: invalidLexicalForm(2) }),
        new Impl({ types: ['date', 'invalid'], func: invalidLexicalForm(2) }),
    ].concat(numeric(() => numericHelper)));
}
exports.xPathTest = xPathTest;
/**
 * DataType will be generalized to float,
 * or to the the category-parent (interger, decimal, ...) if both have the same.
 */
function numeric(opFac) {
    return [
        new Impl({ types: ['integer', 'integer'], func: opFac(Consts_1.TypeURL.XSD_INTEGER) }),
        new Impl({ types: ['integer', 'decimal'], func: opFac() }),
        new Impl({ types: ['integer', 'float'], func: opFac() }),
        new Impl({ types: ['integer', 'double'], func: opFac() }),
        new Impl({ types: ['integer', 'invalid'], func: invalidLexicalForm(2) }),
        new Impl({ types: ['decimal', 'integer'], func: opFac() }),
        new Impl({ types: ['decimal', 'decimal'], func: opFac(Consts_1.TypeURL.XSD_DECIMAL) }),
        new Impl({ types: ['decimal', 'float'], func: opFac() }),
        new Impl({ types: ['decimal', 'double'], func: opFac() }),
        new Impl({ types: ['decimal', 'invalid'], func: invalidLexicalForm(2) }),
        new Impl({ types: ['float', 'integer'], func: opFac() }),
        new Impl({ types: ['float', 'decimal'], func: opFac() }),
        new Impl({ types: ['float', 'float'], func: opFac(Consts_1.TypeURL.XSD_FLOAT) }),
        new Impl({ types: ['float', 'double'], func: opFac() }),
        new Impl({ types: ['float', 'invalid'], func: invalidLexicalForm(2) }),
        new Impl({ types: ['double', 'integer'], func: opFac() }),
        new Impl({ types: ['double', 'decimal'], func: opFac() }),
        new Impl({ types: ['double', 'float'], func: opFac() }),
        new Impl({ types: ['double', 'double'], func: opFac(Consts_1.TypeURL.XSD_DOUBLE) }),
        new Impl({ types: ['double', 'invalid'], func: invalidLexicalForm(2) }),
        new Impl({ types: ['invalid', 'integer'], func: invalidLexicalForm(1) }),
        new Impl({ types: ['invalid', 'decimal'], func: invalidLexicalForm(1) }),
        new Impl({ types: ['invalid', 'float'], func: invalidLexicalForm(1) }),
        new Impl({ types: ['invalid', 'double'], func: invalidLexicalForm(1) }),
    ];
}
exports.numeric = numeric;
function unary(op, args) {
    const [val] = args;
    return op(val.typedValue);
}
exports.unary = unary;
function binary(op, args) {
    const [left, right] = args;
    return op(left.typedValue, right.typedValue);
}
exports.binary = binary;
// export type TernaryOp<T, R> = (val: T) => R;
// export function ternary<T, R>(op: UnLiteralOp<T, R>, args: E.TermExpression[]): R {
//   const [val] = args as Array<E.Literal<T>>;
//   return op(val.typedValue);
// }
function invalidLexicalForm(index) {
    return (args) => {
        throw new Err.InvalidLexicalForm(args[index - 1].toRDF());
    };
}
//# sourceMappingURL=TypeHelpers.js.map