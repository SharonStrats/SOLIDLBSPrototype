"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
const Errors_1 = require("../../util/Errors");
class SimpleFunction {
    // Add functions that select a datatype to compare to in _isValidTypes
    constructor(operator, arity, types, _apply) {
        this.operator = operator;
        this.arity = arity;
        this.types = types;
        this._apply = _apply;
        this.functionClass = 'simple';
    }
    apply(args) {
        if (!this._isValidTypes(args)) {
            throw new Errors_1.InvalidArgumentTypes(args, this.operator);
        }
        return this._apply(args);
    }
    // TODO: Test
    // TODO Can be optimised probably
    // TODO Put in documentation, this is our TypeChecker for simple
    _isValidTypes(args) {
        return args.every((arg, i) => {
            return this.types[i] === arg.category
                || this.types[i] === arg.termType
                || this.types[i] === 'term';
        });
        // tslint:disable-next-line:no-any
        // const argTypes = args.map((a) => a. || a.termType);
        // return _.isEqual(this.types, argTypes)
        // // TODO this arity is wrong
        //   || _.isEqual(this.types, Array(arity).fill('term'));
    }
}
exports.SimpleFunction = SimpleFunction;
class OverloadedFunction {
    constructor(operator, arity, overloadMap) {
        this.operator = operator;
        this.arity = arity;
        this.overloadMap = overloadMap;
        this.functionClass = 'overloaded';
    }
    apply(args) {
        const func = this._monomorph(args);
        if (!func) {
            throw new Errors_1.InvalidArgumentTypes(args, this.operator);
        }
        return func(args);
    }
    // TODO: Clean up a bit
    _monomorph(args) {
        // tslint:disable-next-line:no-any
        const argTypes = immutable_1.List(args.map((a) => a.category || a.termType));
        const arity = args.length;
        return this.overloadMap.get(argTypes)
            || this.overloadMap.get(immutable_1.List(Array(arity).fill('term')));
    }
}
exports.OverloadedFunction = OverloadedFunction;
// Special Functions ----------------------------------------------------------
/*
 * Special Functions are those that don't really fit in sensible categories and
 * have extremely heterogeneous signatures that make them impossible to abstract
 * over. They are small in number, and their behaviour is often complex and open
 * for multiple correct implementations with different trade-offs.
 *
 * Due to their varying nature, they need all available information present
 * during evaluation. This reflects in the signature of the apply() method.
 *
 * They need access to an evaluator to be able to even implement their logic.
 * Especially relevant for IF, and the logical connectives.
 *
 * They can have both sync and async implementations, and both would make sense
 * in some contexts.
 */
class SpecialFunctionAsync {
    constructor() {
        this.functionClass = 'special';
    }
}
exports.SpecialFunctionAsync = SpecialFunctionAsync;
//# sourceMappingURL=Types.js.map