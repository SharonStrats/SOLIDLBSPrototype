"use strict";
/**
 * These helpers provide a (albeit inflexible) DSL for writing function
 * definitions for the SPARQL functions.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
const C = require("../../util/Consts");
const Err = require("../../util/Errors");
const E = require("../Expressions");
const Consts_1 = require("../../util/Consts");
function declare() {
    return new Builder();
}
exports.declare = declare;
class Builder {
    constructor() {
        this.implementations = [];
    }
    collect() {
        return map(this.implementations);
    }
    log() {
        // tslint:disable-next-line:no-console
        console.log(this.implementations);
        return this;
    }
    add(impl) {
        this.implementations.push(impl);
        return this;
    }
    set(argTypes, func) {
        const types = immutable_1.List(argTypes);
        return this.add(new Impl({ types, func }));
    }
    copy({ from, to }) {
        const last = this.implementations.length - 1;
        const _from = immutable_1.List(from);
        for (let i = last; i >= 0; i--) {
            const impl = this.implementations[i];
            if (impl.get('types').equals(_from)) {
                return this.set(to, impl.get('func'));
            }
        }
        throw new Err.UnexpectedError('Tried to copy implementation, but types not found', { from, to });
    }
    setUnary(type, op) {
        return this.set([type], ([val]) => {
            return op(val);
        });
    }
    setLitUnary(type, op) {
        return this.set([type], ([val]) => {
            return op(val.typedValue);
        });
    }
    setLitBinary(types, op) {
        return this.set(types, ([left, right]) => {
            return op(left.typedValue, right.typedValue);
        });
    }
    setLitTernary(types, op) {
        return this.set(types, ([a1, a2, a3]) => {
            return op(a1.typedValue, a2.typedValue, a3.typedValue);
        });
    }
    unimplemented(msg) {
        for (let arity = 0; arity <= 5; arity++) {
            const types = Array(arity).fill('term');
            const func = (_args) => { throw new Err.UnimplementedError(msg); };
            this.set(types, func);
        }
        return this;
    }
    onTerm1(op) {
        return this.set(['term'], ([term]) => op(term));
    }
    onLiteral1(op) {
        return this.set(['literal'], ([term]) => op(term));
    }
    onString1(op) {
        return this
            .set(['string'], ([lit]) => op(lit))
            .set(['langString'], ([lit]) => op(lit));
    }
    onNumeric1(op) {
        return this
            .set(['integer'], ([val]) => op(val))
            .set(['decimal'], ([val]) => op(val))
            .set(['float'], ([val]) => op(val))
            .set(['double'], ([val]) => op(val))
            .invalidLexicalForm(['nonlexical'], 1);
    }
    /*
    * Arithetic Operators take numbers, and return numbers.
    * Check 'numeric' for behaviour of the generic numeric helper.
    * https://www.w3.org/TR/sparql11-query/#OperatorMapping
    */
    arithmetic(op) {
        const opFac = (dt) => ([left, right]) => number(op(left.typedValue, right.typedValue), dt || Consts_1.TypeURL.XSD_FLOAT);
        return this.numeric(opFac);
    }
    numberTest(test) {
        const func = ([left, right]) => {
            const result = test(left.typedValue, right.typedValue);
            return bool(result);
        };
        return this.numeric(() => func);
    }
    stringTest(test) {
        return this
            .set(['string', 'string'], ([left, right]) => {
            const result = test(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm(['nonlexical', 'string'], 1)
            .invalidLexicalForm(['string', 'nonlexical'], 2);
    }
    booleanTest(test) {
        return this
            .set(['boolean', 'boolean'], ([left, right]) => {
            const result = test(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm(['nonlexical', 'boolean'], 1)
            .invalidLexicalForm(['boolean', 'nonlexical'], 2);
    }
    dateTimeTest(test) {
        return this
            .set(['date', 'date'], ([left, right]) => {
            const result = test(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm(['nonlexical', 'date'], 1)
            .invalidLexicalForm(['date', 'nonlexical'], 2);
    }
    numeric(opFac) {
        return this
            .set(['integer', 'integer'], opFac(Consts_1.TypeURL.XSD_INTEGER))
            .set(['integer', 'decimal'], opFac())
            .set(['integer', 'float'], opFac())
            .set(['integer', 'double'], opFac())
            .invalidLexicalForm(['integer', 'nonlexical'], 2)
            .set(['decimal', 'integer'], opFac())
            .set(['decimal', 'decimal'], opFac(Consts_1.TypeURL.XSD_DECIMAL))
            .set(['decimal', 'float'], opFac())
            .set(['decimal', 'double'], opFac())
            .invalidLexicalForm(['decimal', 'nonlexical'], 2)
            .set(['float', 'integer'], opFac())
            .set(['float', 'decimal'], opFac())
            .set(['float', 'float'], opFac(Consts_1.TypeURL.XSD_FLOAT))
            .set(['float', 'double'], opFac())
            .invalidLexicalForm(['float', 'nonlexical'], 2)
            .set(['double', 'integer'], opFac())
            .set(['double', 'decimal'], opFac())
            .set(['double', 'float'], opFac())
            .set(['double', 'double'], opFac(Consts_1.TypeURL.XSD_DOUBLE))
            .invalidLexicalForm(['double', 'nonlexical'], 2)
            .invalidLexicalForm(['nonlexical', 'integer'], 1)
            .invalidLexicalForm(['nonlexical', 'decimal'], 1)
            .invalidLexicalForm(['nonlexical', 'float'], 1)
            .invalidLexicalForm(['nonlexical', 'double'], 1);
    }
    invalidLexicalForm(types, index) {
        return this.set(types, (args) => {
            throw new Err.InvalidLexicalForm(args[index - 1].toRDF());
        });
    }
    chain(impls) {
        this.implementations = this.implementations.concat(impls);
        return this;
    }
}
exports.Builder = Builder;
const implDefaults = {
    types: [],
    func() {
        const msg = 'Implementation not set yet declared as implemented';
        throw new Err.UnexpectedError(msg);
    },
};
class Impl extends immutable_1.Record(implDefaults) {
    constructor(params) { super(params); }
    get(value) {
        return super.get(value);
    }
    toPair() {
        return [this.get('types'), this.get('func')];
    }
}
exports.Impl = Impl;
function map(implementations) {
    const typeImplPair = implementations.map((i) => i.toPair());
    return immutable_1.Map(typeImplPair);
}
exports.map = map;
// ----------------------------------------------------------------------------
// Literal Construction helpers
// ----------------------------------------------------------------------------
function bool(val) {
    return new E.BooleanLiteral(val);
}
exports.bool = bool;
function number(num, dt) {
    return new E.NumericLiteral(num, undefined, C.make(dt || Consts_1.TypeURL.XSD_FLOAT));
}
exports.number = number;
function string(s) {
    return new E.StringLiteral(s);
}
exports.string = string;
function dateTime(date, str) {
    return new E.DateTimeLiteral(date, str);
}
exports.dateTime = dateTime;
//# sourceMappingURL=Helpers.js.map