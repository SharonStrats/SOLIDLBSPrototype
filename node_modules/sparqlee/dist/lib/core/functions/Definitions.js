"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
const Helpers_1 = require("./Helpers");
const Special = require("./SpecialFunctions");
const X = require("./XPath");
const Consts_1 = require("../../util/Consts");
const Errors_1 = require("../../util/Errors");
const Helpers_2 = require("./Helpers");
// TODO Maybe split in definitions for simple, overloaded and async functions.
const _definitions = {
    // --------------------------------------------------------------------------
    // Operator Mapping
    // https://www.w3.org/TR/sparql11-query/#OperatorMapping
    // --------------------------------------------------------------------------
    '!': {
        arity: 1,
        category: 'simple',
        types: [],
        apply: () => { throw new Errors_1.UnimplementedError('! operator'); },
    },
    'UPLUS': {
        arity: 1,
        category: 'simple',
        types: [],
        apply: () => { throw new Errors_1.UnimplementedError('Unary plus operator'); },
    },
    'UMINUS': {
        arity: 1,
        category: 'simple',
        types: [],
        apply: () => { throw new Errors_1.UnimplementedError('Unary minus operator'); },
    },
    '&&': {
        arity: 2,
        category: 'special',
        constructor: Special.LogicalAndAsync,
    },
    '||': {
        arity: 2,
        category: 'special',
        constructor: Special.LogicalOrAsync,
    },
    '*': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.arithmetic(X.numericMultiply),
    },
    '/': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.arithmetic(X.numericDivide).set(Helpers_2.list('integer', 'integer'), (args) => {
            if (args[1].typedValue === 0) {
                throw new Errors_1.ExpressionError('Integer division by 0');
            }
            return Helpers_2.number(Helpers_2.binary(X.numericDivide, args), Consts_1.DataType.XSD_DECIMAL);
        }),
    },
    '+': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.arithmetic(X.numericAdd),
    },
    '-': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.arithmetic(X.numericSubtract),
    },
    '=': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.xPathTest(X.numericEqual, (left, right) => X.numericEqual(X.compare(left, right), 0), X.booleanEqual, X.dateTimeEqual).set(Helpers_2.list('term', 'term'), (args) => {
            return Helpers_2.bool(Special.RDFTermEqual(args[0], args[1]));
        }),
    },
    '!=': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.xPathTest((left, right) => !X.numericEqual(left, right), (left, right) => !X.numericEqual(X.compare(left, right), 0), (left, right) => !X.booleanEqual(left, right), (left, right) => !X.dateTimeEqual(left, right)),
    },
    '<': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.xPathTest(X.numericLessThan, (left, right) => X.numericEqual(X.compare(left, right), -1), X.booleanLessThan, X.dateTimeLessThan),
    },
    '>': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.xPathTest(X.numericGreaterThan, (left, right) => X.numericEqual(X.compare(left, right), 1), X.booleanGreaterThan, X.dateTimeGreaterThan),
    },
    '<=': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.xPathTest((left, right) => X.numericLessThan(left, right) || X.numericEqual(left, right), (left, right) => !X.numericEqual(X.compare(left, right), 1), (left, right) => !X.booleanGreaterThan(left, right), (left, right) => !X.dateTimeGreaterThan(left, right)),
    },
    '>=': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_2.xPathTest((left, right) => X.numericGreaterThan(left, right) || X.numericEqual(left, right), (left, right) => !X.numericEqual(X.compare(left, right), -1), (left, right) => !X.booleanLessThan(left, right), (left, right) => !X.dateTimeLessThan(left, right)),
    },
    // --------------------------------------------------------------------------
    // Functional Forms
    // https://www.w3.org/TR/sparql11-query/#func-forms
    // --------------------------------------------------------------------------
    'bound': {
        arity: 1,
        category: 'special',
        constructor: Special.Bound,
    },
    'if': {
        arity: 3,
        category: 'special',
        constructor: Special.If,
    },
    'coalesce': {
        arity: Infinity,
        category: 'special',
        constructor: Special.Coalesce,
    },
    'sameterm': {
        arity: 2,
        category: 'simple',
        types: ['term', 'term'],
        apply(args) {
            return Helpers_2.bool(Special.sameTerm(args[1], args[2]));
        },
    },
    'in': {
        arity: Infinity,
        category: 'special',
        constructor: Special.In,
    },
    'notin': {
        arity: Infinity,
        category: 'special',
        constructor: Special.NotIn,
    },
    // --------------------------------------------------------------------------
    // Functions on RDF Terms
    // https://www.w3.org/TR/sparql11-query/#func-rdfTerms
    // --------------------------------------------------------------------------
    'str': {
        arity: 1,
        category: 'simple',
        types: ['term'],
        apply(args) { return Helpers_1.str(args[0].str()); },
    },
    'lang': {
        arity: 1,
        category: 'simple',
        types: ['literal'],
        apply(args) {
            return Helpers_1.str(args[0].language || '');
        },
    },
    'datatype': {
        arity: 1,
        category: 'simple',
        types: ['literal'],
        // tslint:disable-next-line:no-any
        apply(args) {
            const arg = args[0];
            return Helpers_1.str((arg.dataType) ? arg.dataType.value : '');
        },
    },
    // --------------------------------------------------------------------------
    // Functions on strings
    // https://www.w3.org/TR/sparql11-query/#func-forms
    // TODO: Note somewhere that 'overloaded' is in the context of this type system.
    // Eg. strlen is overloaded, although it has identical behaviour,
    // but the types can not be captured by a single ArgumentType.
    // --------------------------------------------------------------------------
    'strlen': {
        arity: 1,
        category: 'overloaded',
        overloads: Helpers_1.forAll([['plain'], ['simple'], ['string']], (args) => Helpers_2.number(Helpers_1.unary(X.stringLength, args), Consts_1.DataType.XSD_INTEGER)),
    },
    'langmatches': {
        arity: 2,
        category: 'overloaded',
        overloads: Helpers_1.forAll([
            // TODO: This deviates from the spec, as it only allows simple literals
            ['simple', 'simple'],
            ['simple', 'string'],
            ['string', 'simple'],
            ['string', 'string'],
        ], (args) => Helpers_2.bool(Helpers_2.binary(X.langMatches, args))),
    },
    'regex': {
        arity: [2, 3],
        category: 'overloaded',
        // // TODO: This deviates from the spec, as the second and third argument should be simple literals
        overloads: Helpers_1.forAll([].concat(Helpers_1.expand(['stringly', 'simple']))
            .concat(Helpers_1.expand(['stringly', 'simple', 'simple'])), (args) => Helpers_2.bool(X.matches(args[0].typedValue, args[1].typedValue, ((args[2]) ? args[2].typedValue : '')))),
    },
    // --------------------------------------------------------------------------
    // Functions on numerics
    // https://www.w3.org/TR/sparql11-query/#func-numerics
    // --------------------------------------------------------------------------
    'abs': {
        arity: 1,
        category: 'overloaded',
        overloads: Helpers_1.forAll([['term']], () => { throw new Errors_1.UnimplementedError('abs'); }),
    },
    // --------------------------------------------------------------------------
    // Functions on Dates and Times
    // https://www.w3.org/TR/sparql11-query/#func-date-time
    // --------------------------------------------------------------------------
    'now': {
        arity: 0,
        category: 'simple',
        types: [],
        apply: (args) => {
            throw new Errors_1.UnimplementedError('now function');
        },
    },
};
exports.definitions = immutable_1.Map(_definitions);
//# sourceMappingURL=Definitions.js.map