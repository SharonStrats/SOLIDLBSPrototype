{"version":3,"file":"SpecialFunctionsAsync.js","sourceRoot":"","sources":["../../../../lib/core/functions/SpecialFunctionsAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { Map } from 'immutable';\n\nimport * as C from '../../util/Consts';\nimport * as Err from '../../util/Errors';\nimport * as E from '../Expressions';\n\nimport { bool } from './Helpers';\nimport { regularFunctions, SPARQLFunction, specialFunctions } from './index';\n\ntype Term = E.TermExpression;\ntype Result = Promise<E.TermExpression>;\n\n// BOUND ----------------------------------------------------------------------\nconst bound = {\n  arity: 1,\n  async apply({ args, mapping }: E.EvalContext): Result {\n    const variable = args[0] as E.VariableExpression;\n    if (variable.expressionType !== E.ExpressionType.Variable) {\n      throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BOUND);\n    }\n    const val = mapping.has(variable.name) && !!mapping.get(variable.name);\n    return bool(val);\n  },\n};\n\n// IF -------------------------------------------------------------------------\nconst ifSPARQL = {\n  arity: 3,\n  async apply({ args, mapping, evaluate }: E.EvalContext): Result {\n    const valFirst = await evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return (ebv)\n      ? evaluate(args[1], mapping)\n      : evaluate(args[2], mapping);\n  },\n};\n\n// COALESCE -------------------------------------------------------------------\nconst coalesce = {\n  arity: Infinity,\n  async apply({ args, mapping, evaluate }: E.EvalContext): Result {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return await evaluate(expr, mapping);\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n};\n\n// logical-or (||) ------------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-or\nconst logicalOr = {\n  arity: 2,\n  async apply({ args, mapping, evaluate }: E.EvalContext): Result {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) { return bool(true); }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (!right) { throw leftErr; }\n      return bool(true);\n    }\n  },\n};\n\n// logical-and (&&) -----------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-and\nconst logicalAnd = {\n  arity: 2,\n  async apply({ args, mapping, evaluate }: E.EvalContext): Result {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) { return bool(false); }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (right) { throw leftErr; }\n      return bool(false);\n    }\n  },\n};\n\n// sameTerm -------------------------------------------------------------------\nconst sameTerm = {\n  arity: 2,\n  async apply({ args, mapping, evaluate }: E.EvalContext): Result {\n    if (args.length !== 2) { throw new Err.InvalidArity(args, C.SpecialOperator.SAME_TERM); }\n    const [leftExpr, rightExpr] = args.map((a) => evaluate(a, mapping));\n    const left = await leftExpr;\n    const right = await rightExpr;\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n};\n\n// IN -------------------------------------------------------------------------\nconst inSPARQL = {\n  arity: Infinity,\n  async apply({ args, mapping, evaluate }: E.EvalContext): Result {\n    if (args.length < 1) { throw new Err.InvalidArity(args, C.SpecialOperator.IN); }\n    const [leftExpr, ...remaining] = args;\n    const left = await evaluate(leftExpr, mapping);\n    return inRecursive(left, { args: remaining, mapping, evaluate }, []);\n  },\n};\n\nasync function inRecursive(\n  needle: Term,\n  { args, mapping, evaluate }: E.EvalContext,\n  results: Array<Error | false>,\n): Result {\n\n  if (args.length === 0) {\n    const noErrors = results.every((v) => !v);\n    return (noErrors) ? bool(false) : Promise.reject(new Err.InError(results));\n  }\n\n  try {\n    const next = await evaluate(args.shift(), mapping);\n    const isEqual = regularFunctions.get(C.RegularOperator.EQUAL);\n    if (isEqual.apply([needle, next])) {\n      return bool(true);\n    } else {\n      inRecursive(needle, { args, mapping, evaluate }, [...results, false]);\n    }\n  } catch (err) {\n    return inRecursive(needle, { args, mapping, evaluate }, [...results, err]);\n  }\n}\n\n// NOT IN ---------------------------------------------------------------------\nconst notInSPARQL = {\n  arity: Infinity,\n  async apply(context: E.EvalContext): Result {\n    const _in = specialFunctions.get(C.SpecialOperator.IN);\n    const isIn = await _in.apply(context);\n    return bool(!(isIn as E.BooleanLiteral).typedValue);\n  },\n};\n\n// ----------------------------------------------------------------------------\n// Wrap these declarations into functions\n// ----------------------------------------------------------------------------\n\nexport type SpecialDefinition = {\n  arity: number;\n  apply: E.SpecialApplication;\n};\n\nconst _specialDefinitions: { [key in C.SpecialOperator]: SpecialDefinition } = {\n  // --------------------------------------------------------------------------\n  // Functional Forms\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'bound': bound,\n  'if': ifSPARQL,\n  'coalesce': coalesce,\n  '&&': logicalAnd,\n  '||': logicalOr,\n  'sameterm': sameTerm,\n  'in': inSPARQL,\n  'notin': notInSPARQL,\n};\n\nexport const specialDefinitions = Map<C.SpecialOperator, SpecialDefinition>(_specialDefinitions);\n"]}