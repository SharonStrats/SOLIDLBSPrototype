/**
 * These helpers provide a (albeit inflexible) DSL for writing function
 * definitions for the SPARQL functions.
 */
import { List, Record } from 'immutable';
import * as C from '../../util/Consts';
import * as E from '../Expressions';
import { ArgumentType, OverloadMap } from './FunctionClasses';
declare type Term = E.TermExpression;
declare type OpFactory = (dt?: C.TypeURL) => E.SimpleApplication;
export declare function declare(): Builder;
export declare class Builder {
    private implementations;
    collect(): OverloadMap;
    log(): Builder;
    add(impl: Impl): Builder;
    set(argTypes: ArgumentType[], func: E.SimpleApplication): Builder;
    copy({ from, to }: {
        from: ArgumentType[];
        to: ArgumentType[];
    }): Builder;
    setUnary<T extends Term>(type: ArgumentType, op: (val: T) => Term): Builder;
    setLitUnary<T>(type: ArgumentType, op: (val: T) => Term): Builder;
    setLitBinary<L, R>(types: ArgumentType[], op: (left: L, right: R) => Term): Builder;
    setLitTernary<A1, A2, A3>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term): Builder;
    unimplemented(msg: string): Builder;
    onTerm1(op: (term: Term) => Term): Builder;
    onLiteral1<T>(op: (lit: E.Literal<T>) => Term): Builder;
    onString1(op: (lit: E.Literal<string>) => Term): Builder;
    onNumeric1(op: (val: E.NumericLiteral) => Term): Builder;
    arithmetic(op: (left: number, right: number) => number): Builder;
    numberTest(test: (left: number, right: number) => boolean): Builder;
    stringTest(test: (left: string, right: string) => boolean): Builder;
    booleanTest(test: (left: boolean, right: boolean) => boolean): Builder;
    dateTimeTest(test: (left: Date, right: Date) => boolean): Builder;
    numeric(opFac: OpFactory): Builder;
    invalidLexicalForm(types: ArgumentType[], index: number): Builder;
    private chain;
}
/**
 * Immutable.js type definitions are pretty unsafe, and this is typo-prone work.
 * These helpers allow use to create OverloadMaps with more type-safety.
 * One entry in the OverloadMap is described by the record Impl;
 *
 * A list of Impl's then gets constructed into an Immutable.js Map.
 *
 * See:
 * https://medium.com/@alexxgent/enforcing-types-with-immutablejs-and-typescript-6ab980819b6a
 */
export declare type ImplType = {
    types: List<ArgumentType>;
    func: E.SimpleApplication;
};
declare const Impl_base: Record.Class;
export declare class Impl extends Impl_base {
    constructor(params: ImplType);
    get<T extends keyof ImplType>(value: T): ImplType[T];
    toPair(): [List<ArgumentType>, E.SimpleApplication];
}
export declare function map(implementations: Impl[]): OverloadMap;
export declare function bool(val: boolean): E.BooleanLiteral;
export declare function number(num: number, dt?: C.TypeURL): E.NumericLiteral;
export declare function string(s: string): E.StringLiteral;
export declare function dateTime(date: Date, str: string): E.DateTimeLiteral;
export {};
