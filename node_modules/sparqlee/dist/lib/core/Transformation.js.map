{"version":3,"file":"Transformation.js","sourceRoot":"","sources":["../../../lib/core/Transformation.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from 'rdf-js';\nimport * as RDFString from 'rdf-string';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport * as P from '../util/Parsing';\nimport * as E from '../expressions.ts/Expressions';\n\nimport { TypeURL as DT } from '../util/Consts';\nimport {\n  namedFunctions,\n  regularFunctions,\n  specialFunctions,\n} from './functions';\n\nexport function transformAlgebra(expr: Alg.Expression): E.Expression {\n  if (!expr) { throw new Err.InvalidExpression(expr); }\n\n  const types = Alg.expressionTypes;\n\n  switch (expr.expressionType) {\n    case types.TERM: return transformTerm(expr as Alg.TermExpression);\n    case types.OPERATOR: return transformOperator(expr as Alg.OperatorExpression);\n    case types.NAMED: return transformNamed(expr as Alg.NamedExpression);\n    // TODO\n    case types.EXISTENCE: throw new Err.UnimplementedError('Existence Operator');\n    case types.AGGREGATE: throw new Err.UnimplementedError('Aggregate Operator');\n    default: throw new Err.InvalidExpressionType(expr);\n  }\n}\n\nexport function transformTerm(term: Alg.TermExpression): E.Expression {\n  if (!term.term) { throw new Err.InvalidExpression(term); }\n\n  switch (term.term.termType) {\n    case 'Variable': return new E.Variable(RDFString.termToString(term.term));\n    case 'Literal': return tranformLiteral(term.term as RDF.Literal);\n    case 'NamedNode': return new E.NamedNode(term.term.value);\n    case 'BlankNode': return new E.BlankNode(term.term.value);\n    default: throw new Err.InvalidTermType(term);\n  }\n}\n\n// TODO: Maybe do this with a map?\n// tslint:disable-next-line:no-any\nfunction tranformLiteral(lit: RDF.Literal): E.Literal<any> {\n\n  if (!lit.datatype) {\n    return (lit.language)\n      ? new E.LangStringLiteral(lit.value, lit.language)\n      : new E.StringLiteral(lit.value);\n  }\n\n  switch (lit.datatype.value) {\n    case null:\n    case undefined:\n    case '': {\n      return (lit.language)\n        ? new E.LangStringLiteral(lit.value, lit.language)\n        : new E.StringLiteral(lit.value);\n    }\n\n    case DT.XSD_STRING:\n      return new E.StringLiteral(lit.value);\n    case DT.RDF_LANG_STRING:\n      return new E.LangStringLiteral(lit.value, lit.language);\n\n    case DT.XSD_DATE_TIME: {\n      const val: Date = new Date(lit.value);\n      if (isNaN(val.getTime())) {\n        return new E.NonLexicalLiteral(undefined, lit.value, lit.datatype);\n      }\n      return new E.DateTimeLiteral(new Date(lit.value), lit.value);\n    }\n\n    case DT.XSD_BOOLEAN: {\n      if (lit.value !== 'true' && lit.value !== 'false') {\n        return new E.NonLexicalLiteral(undefined, lit.value, lit.datatype);\n      }\n      return new E.BooleanLiteral(lit.value === 'true', lit.value);\n    }\n\n    case DT.XSD_INTEGER:\n    case DT.XSD_DECIMAL:\n\n    case DT.XSD_NEGATIVE_INTEGER:\n    case DT.XSD_NON_NEGATIVE_INTEGER:\n    case DT.XSD_NON_POSITIVE_INTEGER:\n    case DT.XSD_POSITIVE_INTEGER:\n    case DT.XSD_LONG:\n    case DT.XSD_INT:\n    case DT.XSD_SHORT:\n    case DT.XSD_BYTE:\n    case DT.XSD_UNSIGNED_LONG:\n    case DT.XSD_UNSIGNED_INT:\n    case DT.XSD_UNSIGNED_SHORT:\n    case DT.XSD_UNSIGNED_BYTE:\n    case DT.XSD_INT: {\n      const val: number = P.parseXSDDecimal(lit.value);\n      if (val === undefined) {\n        return new E.NonLexicalLiteral(undefined, lit.value, lit.datatype);\n      }\n      return new E.NumericLiteral(val, lit.value, lit.datatype);\n    }\n    case DT.XSD_FLOAT:\n    case DT.XSD_DOUBLE: {\n      const val: number = P.parseXSDFloat(lit.value);\n      if (val === undefined) {\n        return new E.NonLexicalLiteral(undefined, lit.value, lit.datatype);\n      }\n      return new E.NumericLiteral(val, lit.value, lit.datatype);\n    }\n    default: return new E.Literal<string>(lit.value, lit.value, lit.datatype);\n  }\n}\n\nfunction transformOperator(expr: Alg.OperatorExpression)\n  : E.OperatorExpression | E.SpecialOperatorExpression {\n  if (C.SpecialOperators.contains(expr.operator)) {\n    const op = expr.operator as C.SpecialOperator;\n    const args = expr.args.map((a) => transformAlgebra(a));\n    const func = specialFunctions.get(op);\n    const expressionType = E.ExpressionType.SpecialOperator;\n    if (!hasCorrectArity(args, func.arity)) { throw new Err.InvalidArity(args, op); }\n    return { func, args, expressionType };\n  } else {\n    if (!C.Operators.contains(expr.operator)) {\n      throw new Err.UnknownOperator(expr.operator);\n    }\n    const op = expr.operator as C.RegularOperator;\n    const args = expr.args.map((a) => transformAlgebra(a));\n    const func = regularFunctions.get(op);\n    const expressionType = E.ExpressionType.Operator;\n    if (!hasCorrectArity(args, func.arity)) { throw new Err.InvalidArity(args, op); }\n    return { func, args, expressionType };\n  }\n}\n\nexport function transformNamed(expr: Alg.NamedExpression): E.NamedExpression {\n  const funcName = expr.name.value;\n  if (!C.NamedOperators.contains(funcName as C.NamedOperator)) {\n    throw new Err.UnknownNamedOperator(expr.name.value);\n  }\n\n  // tslint:disable-next-line:no-any\n  const op = expr.name.value as any as C.NamedOperator;\n  const args = expr.args.map((a) => transformAlgebra(a));\n  const func = namedFunctions.get(op);\n  const expressionType = E.ExpressionType.Named;\n  return { func, args, expressionType, name: expr.name };\n}\n\nfunction hasCorrectArity(args: E.Expression[], arity: number | number[]): boolean {\n  // Infinity is used to represent var-args, so it's always correct.\n  if (arity === Infinity) { return true; }\n\n  // If the function has overloaded arity, the actual arity needs to be present.\n  if (Array.isArray(arity)) {\n    return arity.indexOf(args.length) >= 0;\n  }\n\n  return args.length === arity;\n}\n"]}