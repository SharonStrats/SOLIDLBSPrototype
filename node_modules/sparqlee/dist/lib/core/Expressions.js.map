{"version":3,"file":"Expressions.js","sourceRoot":"","sources":["../../../lib/core/Expressions.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDFDM from '@rdfjs/data-model';\nimport * as RDF from 'rdf-js';\nimport { Algebra } from 'sparqlalgebrajs';\n\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { Bindings } from './Types';\n\nexport enum ExpressionType {\n  Aggregate = 'aggregate',\n  Existence = 'existence',\n  Named = 'named',\n  Operator = 'operator',\n  SpecialOperator = 'specialOperator',\n  Term = 'term',\n  Variable = 'variable',\n}\n\nexport type Expression =\n  AggregateExpression |\n  ExistenceExpression |\n  NamedExpression |\n  OperatorExpression |\n  SpecialOperatorExpression |\n  TermExpression |\n  VariableExpression;\n\nexport interface ExpressionProps {\n  expressionType: ExpressionType;\n}\n\nexport type AggregateExpression = ExpressionProps & {\n  expressionType: ExpressionType.Aggregate;\n  aggregator: string;\n  distinct: boolean;\n  separator?: string; // used by GROUP_CONCAT\n  expression: Expression;\n};\n\nexport type ExistenceExpression = ExpressionProps & {\n  expressionType: ExpressionType.Existence;\n  not: boolean;\n  input: Algebra.Operation;\n};\n\nexport type NamedExpression = ExpressionProps & {\n  expressionType: ExpressionType.Named;\n  name: RDF.NamedNode;\n  func: { apply: SimpleApplication }\n  args: Expression[];\n};\n\nexport type Evaluator = (e: Expression, mapping: Bindings) => Promise<TermExpression>;\nexport type EvalContext = { args: Expression[], mapping: Bindings, evaluate: Evaluator };\n\nexport type Application = SimpleApplication | SpecialApplication;\nexport type SimpleApplication = (args: TermExpression[]) => TermExpression;\nexport type SpecialApplication = (context: EvalContext) => Promise<TermExpression>;\n\nexport type OperatorExpression = ExpressionProps & {\n  expressionType: ExpressionType.Operator;\n  args: Expression[];\n  func: { apply: SimpleApplication; };\n};\n\nexport type SpecialOperatorExpression = ExpressionProps & {\n  expressionType: ExpressionType.SpecialOperator,\n  args: Expression[],\n  func: { apply: SpecialApplication; },\n};\n\nexport type TermType = 'namedNode' | 'literal' | 'blankNode';\nexport type TermExpression = ExpressionProps & {\n  expressionType: ExpressionType.Term;\n  termType: TermType;\n  str(): string;\n  coerceEBV(): boolean;\n  toRDF(): RDF.Term;\n};\n\nexport type VariableExpression = ExpressionProps & {\n  expressionType: ExpressionType.Variable;\n  name: string;\n};\n\n// ----------------------------------------------------------------------------\n// Variable\n// ----------------------------------------------------------------------------\n\nexport class Variable implements VariableExpression {\n  expressionType: ExpressionType.Variable = ExpressionType.Variable;\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n\n\n// ----------------------------------------------------------------------------\n// Terms\n// ----------------------------------------------------------------------------\n\nexport abstract class Term implements TermExpression {\n  expressionType: ExpressionType.Term = ExpressionType.Term;\n  abstract termType: TermType;\n\n  abstract toRDF(): RDF.Term;\n\n  str(): string {\n    throw new Err.InvalidArgumentTypes([this], C.RegularOperator.STR);\n  }\n\n  coerceEBV(): boolean {\n    throw new Err.EBVCoercionError(this);\n  }\n\n}\n\n// NamedNodes -----------------------------------------------------------------\nexport class NamedNode extends Term {\n\n  termType: TermType = 'namedNode';\n  constructor(public value: string) { super(); }\n\n  toRDF(): RDF.Term {\n    return RDFDM.namedNode(this.value);\n  }\n\n  str(): string {\n    return this.value;\n  }\n}\n\n// BlankNodes -----------------------------------------------------------------\n\nexport class BlankNode extends Term {\n  static _nextID = 0;\n\n  termType: TermType = 'blankNode';\n\n  constructor(public value: string) {\n    super();\n    this.value = value;\n  }\n\n  static nextID() {\n    BlankNode._nextID += 1;\n    return BlankNode.nextID.toString();\n  }\n\n  toRDF(): RDF.Term {\n    return RDFDM.blankNode(this.value);\n  }\n}\n\n// Literals-- -----------------------------------------------------------------\nexport interface LiteralTerm extends TermExpression {\n  type: C.Type;\n}\n\nexport class Literal<T> extends Term implements LiteralTerm {\n  termType: 'literal' = 'literal';\n  type: C.Type;\n\n  constructor(\n    public typedValue: T,\n    public strValue?: string,\n    public typeURL?: RDF.NamedNode,\n    public language?: string) {\n    super();\n    this.type = C.type(typeURL.value);\n  }\n\n  toRDF(): RDF.Term {\n    return RDFDM.literal(\n      this.strValue || this.typedValue.toString(),\n      this.language || this.typeURL);\n  }\n\n  str(): string {\n    return this.strValue || this.typedValue.toString();\n  }\n}\n\nexport class NumericLiteral extends Literal<number> {\n  type: C.NumericTypeCategory;\n  coerceEBV(): boolean {\n    return !!this.typedValue;\n  }\n  toRDF(): RDF.Term {\n    const term = super.toRDF();\n    if (!isFinite(this.typedValue)) {\n      term.value = term.value.replace('Infinity', 'INF');\n    }\n    return term;\n  }\n}\n\nexport class BooleanLiteral extends Literal<boolean> {\n  constructor(public typedValue: boolean, public strValue?: string) {\n    super(typedValue, strValue, C.make(C.TypeURL.XSD_BOOLEAN));\n  }\n  coerceEBV(): boolean {\n    return !!this.typedValue;\n  }\n}\n\nexport class DateTimeLiteral extends Literal<Date> {\n  // strValue is mandatory here because toISOString will always add\n  // milliseconds, even if they were not present.\n  constructor(public typedValue: Date, public strValue: string) {\n    super(typedValue, strValue, C.make(C.TypeURL.XSD_DATE_TIME));\n  }\n}\n\nexport class LangStringLiteral extends Literal<string> {\n  constructor(public typedValue: string, public language: string) {\n    super(typedValue, typedValue, C.make(C.TypeURL.RDF_LANG_STRING), language);\n  }\n\n  coerceEBV(): boolean {\n    return this.strValue.length !== 0;\n  }\n}\n\n// https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal\n// https://www.w3.org/TR/sparql11-query/#defn_SimpleLiteral\n// https://www.w3.org/TR/sparql11-query/#func-strings\n// This does not include language tagged literals\nexport class StringLiteral extends Literal<string> {\n  constructor(public typedValue: string) {\n    super(typedValue, typedValue, C.make(C.TypeURL.XSD_STRING));\n  }\n\n  coerceEBV(): boolean {\n    return this.strValue.length !== 0;\n  }\n}\n\n/*\n * This class is used when a literal is parsed, and it's value is\n * an invalid lexical form for it's datatype. The spec defines value with\n * invalid lexical form are still valid terms, and as such we can not error\n * immediately. This class makes sure that the typedValue will remain undefined,\n * and the category 'nonlexical'. This way, only when operators apply to the\n * 'nonlexical' category, they will keep working, otherwise they will throw a\n * type error.\n * This seems to match the spec, except maybe for functions that accept\n * non-lexical values for their datatype.\n *\n * See:\n *  - https://www.w3.org/TR/xquery/#dt-type-error\n *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value\n *  - https://www.w3.org/TR/xquery/#dt-ebv\n *  - ... some other more precise thing i can't find...\n */\nexport class NonLexicalLiteral extends Literal<undefined> {\n  private shouldBeCategory: C.Type;\n  constructor(\n    typedValue: undefined,\n    strValue?: string,\n    dataType?: RDF.NamedNode,\n    language?: string) {\n    super(typedValue, strValue, dataType, language);\n    this.typedValue = undefined;\n    this.type = 'nonlexical';\n    this.shouldBeCategory = C.type(dataType.value);\n  }\n\n  coerceEBV(): boolean {\n    const isNumericOrBool =\n      C.NumericTypeCategories.contains(this.shouldBeCategory)\n      || this.shouldBeCategory === 'boolean';\n\n    if (isNumericOrBool) { return false; }\n    throw new Err.EBVCoercionError(this);\n  }\n}\n"]}