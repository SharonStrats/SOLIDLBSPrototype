import * as RDF from 'rdf-js';
import { Algebra } from 'sparqlalgebrajs';
import * as C from '../util/Consts';
import { Bindings } from './Types';
export declare enum ExpressionType {
    Aggregate = "aggregate",
    Existence = "existence",
    Named = "named",
    Operator = "operator",
    SpecialOperator = "specialOperator",
    Term = "term",
    Variable = "variable"
}
export declare type Expression = AggregateExpression | ExistenceExpression | NamedExpression | OperatorExpression | SpecialOperatorExpression | TermExpression | VariableExpression;
export interface ExpressionProps {
    expressionType: ExpressionType;
}
export declare type AggregateExpression = ExpressionProps & {
    expressionType: ExpressionType.Aggregate;
    aggregator: string;
    distinct: boolean;
    separator?: string;
    expression: Expression;
};
export declare type ExistenceExpression = ExpressionProps & {
    expressionType: ExpressionType.Existence;
    not: boolean;
    input: Algebra.Operation;
};
export declare type NamedExpression = ExpressionProps & {
    expressionType: ExpressionType.Named;
    name: RDF.NamedNode;
    func: {
        apply: SimpleApplication;
    };
    args: Expression[];
};
export declare type Evaluator = (e: Expression, mapping: Bindings) => Promise<TermExpression>;
export declare type EvalContext = {
    args: Expression[];
    mapping: Bindings;
    evaluate: Evaluator;
};
export declare type Application = SimpleApplication | SpecialApplication;
export declare type SimpleApplication = (args: TermExpression[]) => TermExpression;
export declare type SpecialApplication = (context: EvalContext) => Promise<TermExpression>;
export declare type OperatorExpression = ExpressionProps & {
    expressionType: ExpressionType.Operator;
    args: Expression[];
    func: {
        apply: SimpleApplication;
    };
};
export declare type SpecialOperatorExpression = ExpressionProps & {
    expressionType: ExpressionType.SpecialOperator;
    args: Expression[];
    func: {
        apply: SpecialApplication;
    };
};
export declare type TermType = 'namedNode' | 'literal' | 'blankNode';
export declare type TermExpression = ExpressionProps & {
    expressionType: ExpressionType.Term;
    termType: TermType;
    str(): string;
    coerceEBV(): boolean;
    toRDF(): RDF.Term;
};
export declare type VariableExpression = ExpressionProps & {
    expressionType: ExpressionType.Variable;
    name: string;
};
export declare class Variable implements VariableExpression {
    expressionType: ExpressionType.Variable;
    name: string;
    constructor(name: string);
}
export declare abstract class Term implements TermExpression {
    expressionType: ExpressionType.Term;
    abstract termType: TermType;
    abstract toRDF(): RDF.Term;
    str(): string;
    coerceEBV(): boolean;
}
export declare class NamedNode extends Term {
    value: string;
    termType: TermType;
    constructor(value: string);
    toRDF(): RDF.Term;
    str(): string;
}
export declare class BlankNode extends Term {
    value: string;
    static _nextID: number;
    termType: TermType;
    constructor(value: string);
    static nextID(): string;
    toRDF(): RDF.Term;
}
export interface LiteralTerm extends TermExpression {
    type: C.Type;
}
export declare class Literal<T> extends Term implements LiteralTerm {
    typedValue: T;
    strValue?: string;
    typeURL?: RDF.NamedNode;
    language?: string;
    termType: 'literal';
    type: C.Type;
    constructor(typedValue: T, strValue?: string, typeURL?: RDF.NamedNode, language?: string);
    toRDF(): RDF.Term;
    str(): string;
}
export declare class NumericLiteral extends Literal<number> {
    type: C.NumericTypeCategory;
    coerceEBV(): boolean;
    toRDF(): RDF.Term;
}
export declare class BooleanLiteral extends Literal<boolean> {
    typedValue: boolean;
    strValue?: string;
    constructor(typedValue: boolean, strValue?: string);
    coerceEBV(): boolean;
}
export declare class DateTimeLiteral extends Literal<Date> {
    typedValue: Date;
    strValue: string;
    constructor(typedValue: Date, strValue: string);
}
export declare class LangStringLiteral extends Literal<string> {
    typedValue: string;
    language: string;
    constructor(typedValue: string, language: string);
    coerceEBV(): boolean;
}
export declare class StringLiteral extends Literal<string> {
    typedValue: string;
    constructor(typedValue: string);
    coerceEBV(): boolean;
}
export declare class NonLexicalLiteral extends Literal<undefined> {
    private shouldBeCategory;
    constructor(typedValue: undefined, strValue?: string, dataType?: RDF.NamedNode, language?: string);
    coerceEBV(): boolean;
}
