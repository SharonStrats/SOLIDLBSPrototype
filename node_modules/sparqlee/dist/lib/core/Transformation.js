"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RDFString = require("rdf-string");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const C = require("../util/Consts");
const Err = require("../util/Errors");
const P = require("../util/Parsing");
const E = require("../expressions.ts/Expressions");
const Consts_1 = require("../util/Consts");
const functions_1 = require("./functions");
function transformAlgebra(expr) {
    if (!expr) {
        throw new Err.InvalidExpression(expr);
    }
    const types = sparqlalgebrajs_1.Algebra.expressionTypes;
    switch (expr.expressionType) {
        case types.TERM: return transformTerm(expr);
        case types.OPERATOR: return transformOperator(expr);
        case types.NAMED: return transformNamed(expr);
        // TODO
        case types.EXISTENCE: throw new Err.UnimplementedError('Existence Operator');
        case types.AGGREGATE: throw new Err.UnimplementedError('Aggregate Operator');
        default: throw new Err.InvalidExpressionType(expr);
    }
}
exports.transformAlgebra = transformAlgebra;
function transformTerm(term) {
    if (!term.term) {
        throw new Err.InvalidExpression(term);
    }
    switch (term.term.termType) {
        case 'Variable': return new E.Variable(RDFString.termToString(term.term));
        case 'Literal': return tranformLiteral(term.term);
        case 'NamedNode': return new E.NamedNode(term.term.value);
        case 'BlankNode': return new E.BlankNode(term.term.value);
        default: throw new Err.InvalidTermType(term);
    }
}
exports.transformTerm = transformTerm;
// TODO: Maybe do this with a map?
// tslint:disable-next-line:no-any
function tranformLiteral(lit) {
    if (!lit.datatype) {
        return (lit.language)
            ? new E.LangStringLiteral(lit.value, lit.language)
            : new E.StringLiteral(lit.value);
    }
    switch (lit.datatype.value) {
        case null:
        case undefined:
        case '': {
            return (lit.language)
                ? new E.LangStringLiteral(lit.value, lit.language)
                : new E.StringLiteral(lit.value);
        }
        case Consts_1.TypeURL.XSD_STRING:
            return new E.StringLiteral(lit.value);
        case Consts_1.TypeURL.RDF_LANG_STRING:
            return new E.LangStringLiteral(lit.value, lit.language);
        case Consts_1.TypeURL.XSD_DATE_TIME: {
            const val = new Date(lit.value);
            if (isNaN(val.getTime())) {
                return new E.NonLexicalLiteral(undefined, lit.value, lit.datatype);
            }
            return new E.DateTimeLiteral(new Date(lit.value), lit.value);
        }
        case Consts_1.TypeURL.XSD_BOOLEAN: {
            if (lit.value !== 'true' && lit.value !== 'false') {
                return new E.NonLexicalLiteral(undefined, lit.value, lit.datatype);
            }
            return new E.BooleanLiteral(lit.value === 'true', lit.value);
        }
        case Consts_1.TypeURL.XSD_INTEGER:
        case Consts_1.TypeURL.XSD_DECIMAL:
        case Consts_1.TypeURL.XSD_NEGATIVE_INTEGER:
        case Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER:
        case Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER:
        case Consts_1.TypeURL.XSD_POSITIVE_INTEGER:
        case Consts_1.TypeURL.XSD_LONG:
        case Consts_1.TypeURL.XSD_INT:
        case Consts_1.TypeURL.XSD_SHORT:
        case Consts_1.TypeURL.XSD_BYTE:
        case Consts_1.TypeURL.XSD_UNSIGNED_LONG:
        case Consts_1.TypeURL.XSD_UNSIGNED_INT:
        case Consts_1.TypeURL.XSD_UNSIGNED_SHORT:
        case Consts_1.TypeURL.XSD_UNSIGNED_BYTE:
        case Consts_1.TypeURL.XSD_INT: {
            const val = P.parseXSDDecimal(lit.value);
            if (val === undefined) {
                return new E.NonLexicalLiteral(undefined, lit.value, lit.datatype);
            }
            return new E.NumericLiteral(val, lit.value, lit.datatype);
        }
        case Consts_1.TypeURL.XSD_FLOAT:
        case Consts_1.TypeURL.XSD_DOUBLE: {
            const val = P.parseXSDFloat(lit.value);
            if (val === undefined) {
                return new E.NonLexicalLiteral(undefined, lit.value, lit.datatype);
            }
            return new E.NumericLiteral(val, lit.value, lit.datatype);
        }
        default: return new E.Literal(lit.value, lit.value, lit.datatype);
    }
}
function transformOperator(expr) {
    if (C.SpecialOperators.contains(expr.operator)) {
        const op = expr.operator;
        const args = expr.args.map((a) => transformAlgebra(a));
        const func = functions_1.specialFunctions.get(op);
        const expressionType = E.ExpressionType.SpecialOperator;
        if (!hasCorrectArity(args, func.arity)) {
            throw new Err.InvalidArity(args, op);
        }
        return { func, args, expressionType };
    }
    else {
        if (!C.Operators.contains(expr.operator)) {
            throw new Err.UnknownOperator(expr.operator);
        }
        const op = expr.operator;
        const args = expr.args.map((a) => transformAlgebra(a));
        const func = functions_1.regularFunctions.get(op);
        const expressionType = E.ExpressionType.Operator;
        if (!hasCorrectArity(args, func.arity)) {
            throw new Err.InvalidArity(args, op);
        }
        return { func, args, expressionType };
    }
}
function transformNamed(expr) {
    const funcName = expr.name.value;
    if (!C.NamedOperators.contains(funcName)) {
        throw new Err.UnknownNamedOperator(expr.name.value);
    }
    // tslint:disable-next-line:no-any
    const op = expr.name.value;
    const args = expr.args.map((a) => transformAlgebra(a));
    const func = functions_1.namedFunctions.get(op);
    const expressionType = E.ExpressionType.Named;
    return { func, args, expressionType, name: expr.name };
}
exports.transformNamed = transformNamed;
function hasCorrectArity(args, arity) {
    // Infinity is used to represent var-args, so it's always correct.
    if (arity === Infinity) {
        return true;
    }
    // If the function has overloaded arity, the actual arity needs to be present.
    if (Array.isArray(arity)) {
        return arity.indexOf(args.length) >= 0;
    }
    return args.length === arity;
}
//# sourceMappingURL=Transformation.js.map