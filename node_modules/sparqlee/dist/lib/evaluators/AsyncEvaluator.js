"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RDFDM = require("@rdfjs/data-model");
const E = require("../expressions/Expressions");
const C = require("../util/Consts");
const Err = require("../util/Errors");
const Transformation_1 = require("../Transformation");
class AsyncEvaluator {
    constructor(algExpr, hooks = {}) {
        this.algExpr = algExpr;
        this.hooks = hooks;
        // tslint:disable-next-line:member-ordering
        this.evaluators = {
            [E.ExpressionType.Term]: this.evalTerm,
            [E.ExpressionType.Variable]: this.evalVariable,
            [E.ExpressionType.Operator]: this.evalOperator,
            [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,
            [E.ExpressionType.Named]: this.evalNamed,
            [E.ExpressionType.Existence]: this.evalExistence,
            [E.ExpressionType.Aggregate]: this.evalAggregate,
        };
        this.expr = Transformation_1.transformAlgebra(algExpr, hooks);
    }
    async evaluate(mapping) {
        const result = await this.evalRecursive(this.expr, mapping);
        return log(result).toRDF();
    }
    async evaluateAsEBV(mapping) {
        const result = await this.evalRecursive(this.expr, mapping);
        return log(result).coerceEBV();
    }
    async evaluateAsInternal(mapping) {
        return this.evalRecursive(this.expr, mapping);
    }
    async evalRecursive(expr, mapping) {
        const evaluator = this.evaluators[expr.expressionType];
        if (!evaluator) {
            throw new Err.InvalidExpressionType(expr);
        }
        return evaluator.bind(this)(expr, mapping);
    }
    async evalTerm(expr, mapping) {
        return expr;
    }
    async evalVariable(expr, mapping) {
        const term = mapping.get(expr.name);
        if (!term) {
            throw new Err.UnboundVariableError(expr.name, mapping);
        }
        return Transformation_1.transformRDFTermUnsafe(term);
    }
    async evalOperator(expr, mapping) {
        const argPromises = expr.args.map((arg) => this.evalRecursive(arg, mapping));
        const argResults = await Promise.all(argPromises);
        return expr.apply(argResults);
    }
    async evalSpecialOperator(expr, mapping) {
        const evaluate = this.evalRecursive.bind(this);
        const context = { args: expr.args, mapping, evaluate };
        return expr.applyAsync(context);
    }
    async evalNamed(expr, mapping) {
        const argPromises = expr.args.map((arg) => this.evalRecursive(arg, mapping));
        const argResults = await Promise.all(argPromises);
        return expr.apply(argResults);
    }
    async evalExistence(expr, mapping) {
        const result = await expr.exists_with(mapping);
        return Transformation_1.transformRDFTermUnsafe(RDFDM.literal(result.toString(), C.make(C.TypeURL.XSD_BOOLEAN)));
    }
    // TODO: Remove?
    async evalAggregate(expr, _mapping) {
        return Transformation_1.transformRDFTermUnsafe(await expr.aggregate());
    }
}
exports.AsyncEvaluator = AsyncEvaluator;
function log(val) {
    // console.log(val);
    return val;
}
//# sourceMappingURL=AsyncEvaluator.js.map