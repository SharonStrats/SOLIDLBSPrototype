{"version":3,"file":"AsyncEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/AsyncEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDFDM from '@rdfjs/data-model';\nimport * as RDF from 'rdf-js';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions/Expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { transformAlgebra, transformRDFTermUnsafe } from '../Transformation';\nimport { Bindings, Hooks } from '../Types';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\ntype Variable = E.VariableExpression;\ntype Existence = E.ExistenceExpression;\ntype Operator = E.OperatorExpression;\ntype SpecialOperator = E.SpecialOperatorExpression;\ntype Named = E.NamedExpression;\ntype Aggregate = E.AggregateExpression;\n\nexport class AsyncEvaluator {\n  private expr: Expression;\n\n  constructor(public algExpr: Alg.Expression, public hooks: Hooks = {}) {\n    this.expr = transformAlgebra(algExpr, hooks);\n  }\n\n  async evaluate(mapping: Bindings): Promise<RDF.Term> {\n    const result = await this.evalRecursive(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  async evaluateAsEBV(mapping: Bindings): Promise<boolean> {\n    const result = await this.evalRecursive(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  async evaluateAsInternal(mapping: Bindings): Promise<Term> {\n    return this.evalRecursive(this.expr, mapping);\n  }\n\n  // tslint:disable-next-line:member-ordering\n  private readonly evaluators: {\n    [key: string]: (expr: Expression, mapping: Bindings) => Promise<Term>;\n  } = {\n      [E.ExpressionType.Term]: this.evalTerm,\n      [E.ExpressionType.Variable]: this.evalVariable,\n      [E.ExpressionType.Operator]: this.evalOperator,\n      [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n      [E.ExpressionType.Named]: this.evalNamed,\n      [E.ExpressionType.Existence]: this.evalExistence,\n      [E.ExpressionType.Aggregate]: this.evalAggregate,\n    };\n\n  private async evalRecursive(expr: Expression, mapping: Bindings): Promise<Term> {\n    const evaluator = this.evaluators[expr.expressionType];\n    if (!evaluator) { throw new Err.InvalidExpressionType(expr); }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private async evalTerm(expr: Term, mapping: Bindings): Promise<Term> {\n    return expr;\n  }\n\n  private async evalVariable(expr: Variable, mapping: Bindings): Promise<Term> {\n    const term = mapping.get(expr.name);\n    if (!term) {\n      throw new Err.UnboundVariableError(expr.name, mapping);\n    }\n    return transformRDFTermUnsafe(term);\n  }\n\n  private async evalOperator(expr: Operator, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map((arg) => this.evalRecursive(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Promise<Term> {\n    const evaluate = this.evalRecursive.bind(this);\n    const context = { args: expr.args, mapping, evaluate };\n    return expr.applyAsync(context);\n  }\n\n  private async evalNamed(expr: Named, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map((arg) => this.evalRecursive(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalExistence(expr: Existence, mapping: Bindings): Promise<Term> {\n    const result = await expr.exists_with(mapping);\n    return transformRDFTermUnsafe(\n      RDFDM.literal(result.toString(), C.make(C.TypeURL.XSD_BOOLEAN)),\n    );\n  }\n\n  // TODO: Remove?\n  private async evalAggregate(expr: Aggregate, _mapping: Bindings): Promise<Term> {\n    return transformRDFTermUnsafe(await expr.aggregate());\n  }\n}\n\nfunction log<T>(val: T): T {\n  // console.log(val);\n  return val;\n}\n"]}