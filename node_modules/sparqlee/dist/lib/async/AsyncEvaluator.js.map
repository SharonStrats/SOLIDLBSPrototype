{"version":3,"file":"AsyncEvaluator.js","sourceRoot":"","sources":["../../../lib/async/AsyncEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Promise from 'bluebird';\nimport * as RDF from 'rdf-js';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from '../core/Expressions';\nimport * as Err from '../util/Errors';\nimport * as P from '../util/Parsing';\n\nimport { transformAlgebra, transformTerm } from '../core/Transformation';\nimport { AsyncAggregator, AsyncLookUp, Bindings } from '../core/Types';\nimport { DataType as DT } from '../util/Consts';\n\nexport class AsyncEvaluator {\n  private _expr: E.Expression;\n\n  // TODO: Support passing functions to override default behaviour;\n  constructor(\n    expr: Alg.Expression,\n    public lookup?: AsyncLookUp,\n    public aggregator?: AsyncAggregator) {\n    this._expr = transformAlgebra(expr);\n  }\n\n  evaluate(mapping: Bindings): Promise<RDF.Term> {\n    return this._eval(this._expr, mapping).then((val) => log(val).toRDF());\n  }\n\n  evaluateAsEBV(mapping: Bindings): Promise<boolean> {\n    return this._eval(this._expr, mapping).then((val) => log(val).coerceEBV());\n  }\n\n  evaluateAsInternal(mapping: Bindings): Promise<E.TermExpression> {\n    return this._eval(this._expr, mapping);\n  }\n\n  private _eval(expr: E.Expression, mapping: Bindings): Promise<E.TermExpression> {\n    const types = E.expressionTypes;\n    switch (expr.expressionType) {\n      case types.TERM:\n        return Promise.resolve(expr as E.TermExpression);\n      case types.VARIABLE:\n        return Promise.try(() => (\n          this._evalVar(expr as E.VariableExpression, mapping)\n        ));\n      case types.OPERATOR:\n        return this._evalOp(expr as E.OperatorExpression, mapping);\n      // TODO\n      case types.NAMED:\n        return Promise.reject(new Err.UnimplementedError('Named Operator'));\n      case types.EXISTENCE:\n        return Promise.reject(new Err.UnimplementedError('Existence Operator'));\n      case types.AGGREGATE:\n        return Promise.reject(new Err.UnimplementedError('Aggregate Operator'));\n      default: return Promise.reject(new Err.InvalidExpressionType(expr));\n    }\n  }\n\n  private _evalVar(expr: E.VariableExpression, mapping: Bindings): E.TermExpression {\n    const rdfTerm = mapping.get(expr.name);\n    if (rdfTerm) {\n      return transformTerm({\n        type: 'expression',\n        expressionType: 'term',\n        term: rdfTerm,\n      }) as E.TermExpression;\n    } else {\n      throw new Err.UnboundVariableError(expr.name, mapping);\n    }\n  }\n\n  private _evalOp(expr: E.OperatorExpression, mapping: Bindings): Promise<E.TermExpression> {\n    const { func, args } = expr;\n    switch (func.functionClass) {\n      case 'simple':\n      case 'overloaded': {\n        const pArgs = args.map((arg) => this._eval(arg, mapping));\n        return Promise.all(pArgs).then((rArgs) => func.apply(rArgs));\n      }\n      case 'special': return func.apply(args, mapping, this._eval.bind(this));\n      default: throw new Err.UnexpectedError('Unknown function class.');\n    }\n  }\n}\n\nfunction log<T>(val: T): T {\n  // console.log(val);\n  return val;\n}\n"]}