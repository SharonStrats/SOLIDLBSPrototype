"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Promise = require("bluebird");
const E = require("../core/Expressions");
const Err = require("../util/Errors");
const Transformation_1 = require("../core/Transformation");
class AsyncEvaluator {
    // TODO: Support passing functions to override default behaviour;
    constructor(expr, lookup, aggregator) {
        this.lookup = lookup;
        this.aggregator = aggregator;
        this._expr = Transformation_1.transformAlgebra(expr);
    }
    evaluate(mapping) {
        return this._eval(this._expr, mapping).then((val) => log(val).toRDF());
    }
    evaluateAsEBV(mapping) {
        return this._eval(this._expr, mapping).then((val) => log(val).coerceEBV());
    }
    evaluateAsInternal(mapping) {
        return this._eval(this._expr, mapping);
    }
    _eval(expr, mapping) {
        const types = E.expressionTypes;
        switch (expr.expressionType) {
            case types.TERM:
                return Promise.resolve(expr);
            case types.VARIABLE:
                return Promise.try(() => (this._evalVar(expr, mapping)));
            case types.OPERATOR:
                return this._evalOp(expr, mapping);
            // TODO
            case types.NAMED:
                return Promise.reject(new Err.UnimplementedError('Named Operator'));
            case types.EXISTENCE:
                return Promise.reject(new Err.UnimplementedError('Existence Operator'));
            case types.AGGREGATE:
                return Promise.reject(new Err.UnimplementedError('Aggregate Operator'));
            default: return Promise.reject(new Err.InvalidExpressionType(expr));
        }
    }
    _evalVar(expr, mapping) {
        const rdfTerm = mapping.get(expr.name);
        if (rdfTerm) {
            return Transformation_1.transformTerm({
                type: 'expression',
                expressionType: 'term',
                term: rdfTerm,
            });
        }
        else {
            throw new Err.UnboundVariableError(expr.name, mapping);
        }
    }
    _evalOp(expr, mapping) {
        const { func, args } = expr;
        switch (func.functionClass) {
            case 'simple':
            case 'overloaded': {
                const pArgs = args.map((arg) => this._eval(arg, mapping));
                return Promise.all(pArgs).then((rArgs) => func.apply(rArgs));
            }
            case 'special': return func.apply(args, mapping, this._eval.bind(this));
            default: throw new Err.UnexpectedError('Unknown function class.');
        }
    }
}
exports.AsyncEvaluator = AsyncEvaluator;
function log(val) {
    // console.log(val);
    return val;
}
//# sourceMappingURL=AsyncEvaluator.js.map