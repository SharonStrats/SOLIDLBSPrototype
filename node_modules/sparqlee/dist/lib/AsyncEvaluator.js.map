{"version":3,"file":"AsyncEvaluator.js","sourceRoot":"","sources":["../../lib/AsyncEvaluator.ts"],"names":[],"mappings":";;AAGA,+CAA+C;AAC/C,qCAAqC;AAErC,qDAAmE;AAYnE,MAAa,cAAc;IAGzB,iEAAiE;IACjE,YACS,OAAuB,EACvB,MAAoB,EACpB,UAA4B;QAF5B,YAAO,GAAP,OAAO,CAAgB;QACvB,WAAM,GAAN,MAAM,CAAc;QACpB,eAAU,GAAV,UAAU,CAAkB;QAmBrC,2CAA2C;QAC1B,eAAU,GAAe;YACxC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;YACjD,CAAC,CAAC,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,YAAY;YAC9C,CAAC,CAAC,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,YAAY;YAC9C,CAAC,CAAC,CAAC,cAAc,CAAC,eAAe,CAAC,EAAE,IAAI,CAAC,mBAAmB;YAC5D,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,SAAS;YACxC,CAAC,CAAC,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE,IAAI,CAAC,aAAa;YAChD,CAAC,CAAC,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE,IAAI,CAAC,aAAa;SACjD,CAAC;QA1BA,IAAI,CAAC,IAAI,GAAG,iCAAgB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,OAAiB;QAC9B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC5D,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC;IAC7B,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,OAAiB;QACnC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC5D,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,SAAS,EAAE,CAAC;IACjC,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,OAAiB;QACxC,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAChD,CAAC;IAaO,KAAK,CAAC,aAAa,CAAC,IAAgB,EAAE,OAAiB;QAC7D,MAAM,iBAAiB,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC/D,IAAI,CAAC,iBAAiB,EAAE;YAAE,MAAM,IAAI,GAAG,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;SAAE;QACtE,OAAO,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACrD,CAAC;IAEO,KAAK,CAAC,QAAQ,CAAC,IAAU,EAAE,OAAiB;QAClD,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,IAAc,EAAE,OAAiB;QAC1D,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEpC,IAAI,CAAC,IAAI,EAAE;YAAE,MAAM,IAAI,GAAG,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;SAAE;QAEtE,OAAO,8BAAa,CAAC;YACnB,IAAI;YACJ,IAAI,EAAE,YAAY;YAClB,cAAc,EAAE,MAAM;SACvB,CAAS,CAAC;IACb,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,IAAc,EAAE,OAAiB;QAC1D,MAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC;QAC7E,MAAM,UAAU,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAClD,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IAChC,CAAC;IAEO,KAAK,CAAC,mBAAmB,CAAC,IAAqB,EAAE,OAAiB;QACxE,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC/C,MAAM,OAAO,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;QACvD,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IAC7B,CAAC;IAEO,KAAK,CAAC,SAAS,CAAC,IAAW,EAAE,OAAiB;QACpD,MAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC;QAC7E,MAAM,UAAU,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAClD,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IAChC,CAAC;IAED,OAAO;IACC,KAAK,CAAC,aAAa,CAAC,IAAe,EAAE,OAAiB;QAC5D,MAAM,IAAI,GAAG,CAAC,kBAAkB,CAAC,oBAAoB,CAAC,CAAC;IACzD,CAAC;IAED,OAAO;IACC,KAAK,CAAC,aAAa,CAAC,IAAe,EAAE,OAAiB;QAC5D,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QAC7C,OAAO,8BAAa,CAAC;YACnB,IAAI,EAAE,YAAY;YAClB,cAAc,EAAE,MAAM;YACtB,IAAI,EAAE,MAAM;SACb,CAAS,CAAC;IACb,CAAC;CACF;AA3FD,wCA2FC;AAMD,SAAS,GAAG,CAAI,GAAM;IACpB,oBAAoB;IACpB,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from './expressions/Expressions';\nimport * as Err from './util/Errors';\n\nimport { transformAlgebra, transformTerm } from './Transformation';\nimport { AsyncAggregator, AsyncLookUp, Bindings } from './Types';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\ntype Variable = E.VariableExpression;\ntype Existence = E.ExistenceExpression;\ntype Operator = E.OperatorExpression;\ntype SpecialOperator = E.SpecialOperatorExpression;\ntype Named = E.NamedExpression;\ntype Aggregate = E.AggregateExpression;\n\nexport class AsyncEvaluator {\n  private expr: Expression;\n\n  // TODO: Support passing functions to override default behaviour;\n  constructor(\n    public algExpr: Alg.Expression,\n    public lookup?: AsyncLookUp,\n    public aggregator?: AsyncAggregator,\n  ) {\n    this.expr = transformAlgebra(algExpr, aggregator);\n  }\n\n  async evaluate(mapping: Bindings): Promise<RDF.Term> {\n    const result = await this.evalRecursive(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  async evaluateAsEBV(mapping: Bindings): Promise<boolean> {\n    const result = await this.evalRecursive(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  async evaluateAsInternal(mapping: Bindings): Promise<Term> {\n    return this.evalRecursive(this.expr, mapping);\n  }\n\n  // tslint:disable-next-line:member-ordering\n  private readonly evalLookup: EvalLookup = {\n    [E.ExpressionType.Term]: this.evalTerm.bind(this),\n    [E.ExpressionType.Variable]: this.evalVariable,\n    [E.ExpressionType.Operator]: this.evalOperator,\n    [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n    [E.ExpressionType.Named]: this.evalNamed,\n    [E.ExpressionType.Existence]: this.evalExistence,\n    [E.ExpressionType.Aggregate]: this.evalAggregate,\n  };\n\n  private async evalRecursive(expr: Expression, mapping: Bindings): Promise<Term> {\n    const evaluatorFunction = this.evalLookup[expr.expressionType];\n    if (!evaluatorFunction) { throw new Err.InvalidExpressionType(expr); }\n    return evaluatorFunction.bind(this)(expr, mapping);\n  }\n\n  private async evalTerm(expr: Term, mapping: Bindings): Promise<Term> {\n    return expr;\n  }\n\n  private async evalVariable(expr: Variable, mapping: Bindings): Promise<Term> {\n    const term = mapping.get(expr.name);\n\n    if (!term) { throw new Err.UnboundVariableError(expr.name, mapping); }\n\n    return transformTerm({\n      term,\n      type: 'expression',\n      expressionType: 'term',\n    }) as Term;\n  }\n\n  private async evalOperator(expr: Operator, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map((arg) => this.evalRecursive(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Promise<Term> {\n    const evaluate = this.evalRecursive.bind(this);\n    const context = { args: expr.args, mapping, evaluate };\n    return expr.apply(context);\n  }\n\n  private async evalNamed(expr: Named, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map((arg) => this.evalRecursive(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  // TODO\n  private async evalExistence(expr: Existence, mapping: Bindings): Promise<Term> {\n    throw new Err.UnimplementedError('Existence Operator');\n  }\n\n  // TODO\n  private async evalAggregate(expr: Aggregate, mapping: Bindings): Promise<Term> {\n    const result = await expr.aggregate(mapping);\n    return transformTerm({\n      type: 'expression',\n      expressionType: 'term',\n      term: result,\n    }) as Term;\n  }\n}\n\ninterface EvalLookup {\n  [key: string]: (expr: Expression, mapping: Bindings) => Promise<Term>;\n}\n\nfunction log<T>(val: T): T {\n  // console.log(val);\n  return val;\n}\n"]}