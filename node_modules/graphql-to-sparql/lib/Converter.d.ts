import { ArgumentNode, DefinitionNode, DirectiveNode, DocumentNode, FieldNode, FragmentDefinitionNode, NamedTypeNode, NameNode, SelectionNode, ValueNode } from "graphql";
import * as RDF from "rdf-js";
import { Algebra } from "sparqlalgebrajs";
/**
 * Translate GraphQL queries into SPARQL algebra.
 */
export declare class Converter {
    private readonly dataFactory;
    private readonly operationFactory;
    private readonly arraysToRdfLists;
    private readonly variableDelimiter;
    private readonly requireContext;
    private expressionVariableCounter;
    constructor(settings?: IConverterSettings);
    /**
     * Translates a GraphQL query into SPARQL algebra.
     * @param {string} graphqlQuery A GraphQL query string.
     * @param {IContext} context A JSON-LD context.
     * @param {IVariablesDictionary} variablesDict A variables dictionary.
     * @return {Operation}
     */
    graphqlToSparqlAlgebra(graphqlQuery: string, context: IContext, variablesDict?: IVariablesDictionary): Algebra.Operation;
    /**
     * Create an index of all fragment definitions in the given document.
     *
     * This will assign a new array of definition nodes without fragment definition.
     *
     * @param {DocumentNode} document A document node.
     * @return {{[p: string]: FragmentDefinitionNode}} An index of fragment definition nodes.
     */
    indexFragments(document: DocumentNode): {
        [name: string]: FragmentDefinitionNode;
    };
    /**
     * Convert a GraphQL definition node into an algebra operation.
     * @param {IConvertContext} convertContext A convert context.
     * @param {DefinitionNode} definition A GraphQL definition node.
     * @return {Operation} A SPARQL algebra operation.
     */
    definitionToPattern(convertContext: IConvertContext, definition: DefinitionNode): Algebra.Operation | null;
    /**
     * Convert a GraphQL selection node into an algebra operation.
     * @param {IConvertContext} convertContext A convert context.
     * @param {Term} subject The RDF term that should be used as subject.
     * @param {SelectionNode} selectionNode A GraphQL selection node.
     * @return {Pattern[]} An array of quad patterns.
     */
    selectionToPatterns(convertContext: IConvertContext, subject: RDF.Term, selectionNode: SelectionNode): Algebra.Operation;
    /**
     * Create a pattern with an rdf:type predicate.
     * @param {Term} subject The subject.
     * @param {NamedTypeNode} typeCondition The object name.
     * @param {IConvertContext} convertContext A convert context.
     * @return {Pattern} A pattern.
     */
    newTypePattern(subject: RDF.Term, typeCondition: NamedTypeNode, convertContext: IConvertContext): Algebra.Pattern;
    /**
     * Convert a field node to an operation.
     * @param {IConvertContext} convertContext A convert context.
     * @param {Term} subject The subject.
     * @param {FieldNode} fieldNode The field node to convert.
     * @param {boolean} pushTerminalVariables If terminal variables should be created.
     * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.
     * @return {Operation} The reslting operation.
     */
    fieldToOperation(convertContext: IConvertContext, subject: RDF.Term, fieldNode: FieldNode, pushTerminalVariables: boolean, auxiliaryPatterns?: Algebra.Pattern[]): Algebra.Operation;
    /**
     * Create a triple pattern when the predicate is a name node that needs to be translated using the context.
     * @param {Term} subject The subject.
     * @param {NameNode} predicateName The name node for the predicate.
     * @param {Term} object The object.
     * @param {IContext} context A context.
     * @return {Pattern} A triple pattern.
     */
    createTriplePattern(subject: RDF.Term, predicateName: NameNode, object: RDF.Term, context: IContext): Algebra.Pattern;
    /**
     * Check if the given node is a meta field, for things like introspection.
     * If so, return a new operation for this, otherwise, null is returned.
     * @param {IConvertContext} convertContext A convert context.
     * @param {Term} subject The subject.
     * @param {FieldNode} fieldNode The field node to convert.
     * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.
     * @return {Operation} An operation or null.
     */
    handleMetaField(convertContext: IConvertContext, subject: RDF.Term, fieldNode: FieldNode, auxiliaryPatterns?: Algebra.Pattern[]): Algebra.Operation;
    /**
     * Join the given array of operations.
     * If all operations are BGPs, then a single big BGP with all patterns from the given BGPs will be created.
     * @param {Operation[]} operations An array of operations.
     * @return {Operation} A single joined operation.
     */
    joinOperations(operations: Algebra.Operation[]): Algebra.Operation;
    /**
     * Convert a name node to a variable built from the node name and the current path inside the context.
     * @param {NameNode} name A name node.
     * @param {IConvertContext} convertContext A convert context.
     * @return {Variable} A variable.
     */
    nameToVariable(name: NameNode, convertContext: IConvertContext): RDF.Variable;
    /**
     * Convert a GraphQL term into a URI using the given context.
     * @param {string} value A GraphQL term.
     * @param {IContext} context A JSON-LD context.
     * @return {NamedNode} A named node.
     */
    valueToNamedNode(value: string, context: IContext): RDF.NamedNode;
    /**
     * Convert a GraphQL value into an RDF term.
     * @param {ValueNode} valueNode A GraphQL value node.
     * @param {IConvertContext} convertContext A convert context.
     * @param {string} argumentName The name of the argument this value is created for.
     *                              This might influence the literal language or datatype.
     * @return {Term} An RDF term.
     */
    valueToTerm(valueNode: ValueNode, convertContext: IConvertContext, argumentName: string): IValueToTermOutput;
    /**
     * Get an argument by name.
     * This will throw an error if the argument could not be found.
     * @param {ReadonlyArray<ArgumentNode>} args Arguments or null.
     * @param {string} name The name of an argument.
     * @return {ArgumentNode} The named argument.
     */
    getArgument(args: ReadonlyArray<ArgumentNode> | null, name: string): ArgumentNode;
    /**
     * Handle a directive.
     * @param {DirectiveNode} directive A directive.
     * @param {IConvertContext} convertContext A convert context.
     * @return {boolean} If processing of the active should continue.
     */
    handleDirective(directive: DirectiveNode, convertContext: IConvertContext): boolean;
    /**
     * Translates blank nodes inside the query to variables.
     * @param {Project} operation The operation to translate.
     * @return {Operation} The transformed operation.
     */
    translateBlankNodesToVariables(operation: Algebra.Project): Algebra.Operation;
}
/**
 * Constructor settings object interface for {@link Converter}.
 */
export interface IConverterSettings {
    /**
     * A custom datafactory.
     */
    dataFactory?: RDF.DataFactory;
    /**
     * If arrays should be converted to RDF lists.
     * Otherwise (default), arrays will be converted to multiple predicate-object links.
     */
    arraysToRdfLists?: boolean;
    /**
     * The string to join variable names by.
     * Defaults to '_'.
     */
    variableDelimiter?: string;
    /**
     * If the use of a context is required.
     * If true, and GraphQL nodes are not present in the context, an error will be thrown.
     */
    requireContext?: boolean;
}
/**
 * A context object that is passed through conversion steps.
 */
export interface IConvertContext {
    /**
     * A JSON-LD context.
     */
    context: IContext;
    /**
     * The current JSON path within the GraphQL query.
     */
    path: string[];
    /**
     * All variables that have no deeper child and should be selected withing the GraphQL query.
     */
    terminalVariables: RDF.Variable[];
    /**
     * All available fragment definitions.
     */
    fragmentDefinitions: {
        [name: string]: FragmentDefinitionNode;
    };
    /**
     * A variable dictionary in case there are dynamic arguments in the query.
     */
    variablesDict: IVariablesDictionary;
    /**
     * A dictionary of variable metadata.
     */
    variablesMetaDict: IVariablesMetaDictionary;
}
/**
 * A JSON-LD context.
 */
export interface IContext {
    [id: string]: string | any;
}
/**
 * A variable dictionary in case there are dynamic arguments in the query.
 */
export interface IVariablesDictionary {
    [id: string]: ValueNode;
}
/**
 * A dictionary of variable metadata.
 */
export interface IVariablesMetaDictionary {
    [id: string]: {
        mandatory: boolean;
        list: boolean;
        type: string;
    };
}
/**
 * The output of converting a value node to an RDF term.
 */
export interface IValueToTermOutput {
    terms: RDF.Term[];
    auxiliaryPatterns?: Algebra.Pattern[];
}
